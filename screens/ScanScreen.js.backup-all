import React, { useState, useEffect, useImperativeHandle, forwardRef, useRef } from 'react';
import { useIsFocused } from '@react-navigation/native';
import {
  StyleSheet,
  Text,
  TouchableOpacity,
  Alert,
  Modal,
  FlatList,
  SafeAreaView,
  TextInput,
  ActivityIndicator,
  StatusBar,
  Image,
  Keyboard,
  ScrollView,
  Platform,
  InteractionManager,
} from 'react-native';
import { Ionicons, MaterialCommunityIcons, MaterialIcons } from '@expo/vector-icons';
import AsyncStorage from '@react-native-async-storage/async-storage';
import firebaseService from '../services/firebaseService';
import dateUtils from '../utils/dateUtils';
import CustomView from '../components/CustomView';
import TourneeProgress from '../components/TourneeProgress';
import ScanHistoryItem from '../components/ScanHistoryItem';

// Renommer CustomView en View pour maintenir la compatibilité avec le code existant
const View = CustomView;

export default function ScanScreen({ navigation, route }) {
  const sessionData = route.params?.sessionData || {}; // ✅ Sécurise `sessionData`

  // ✅ Vérifie si `sessionData.tournee` et `sessionData.vehicule` existent
  const tournee = sessionData.tournee ? sessionData.tournee.nom || "Tournée inconnue" : "Tournée inconnue";
  const vehicule = sessionData.vehicule ? sessionData.vehicule.immatriculation || "Véhicule inconnu" : "Véhicule inconnu";
  // ID de la tournée pour le suivi
  const tourneeId = sessionData.tournee ? sessionData.tournee.id : null;

  const [siteScanned, setSiteScanned] = useState(false);
  const [siteCode, setSiteCode] = useState('');
  const [scannedContenants, setScannedContenants] = useState([]);
  const [errorMessage, setErrorMessage] = useState('');
  const [manualCodeInput, setManualCodeInput] = useState('');
  const [showHistoryModal, setShowHistoryModal] = useState(false);
  const [historicalScans, setHistoricalScans] = useState([]);
  const [loading, setLoading] = useState(false);
  const [siteDetails, setSiteDetails] = useState(null);
  const [isReadyForScan, setIsReadyForScan] = useState(false);
  const [scanMode, setScanMode] = useState(''); // 'site' ou 'contenant'
  const [scanning, setScanning] = useState(false);
  const [sessionId, setSessionId] = useState("");
  const [pole, setPole] = useState(null);
  const [sessionHistoryLoaded, setSessionHistoryLoaded] = useState(false);
  const [operationType, setOperationType] = useState('entree'); // 'entree' ou 'sortie'
  const [showOperationTypeSelection, setShowOperationTypeSelection] = useState(false); // Nouvel état pour la page de sélection
  const [takingCarePackages, setTakingCarePackages] = useState([]); // Paquets pris en charge
  // Ajouter l'état pour l'ID de session courant
  const [currentSessionId, setCurrentSessionId] = useState(null);

  // États pour les informations de session qui seront chargées
  const [currentTourneeName, setCurrentTourneeName] = useState(route.params?.tournee?.nom || route.params?.tourneeName || sessionData?.tournee?.nom || "Tournée inconnue");
  const [currentVehiculeImmat, setCurrentVehiculeImmat] = useState(route.params?.vehicule?.immatriculation || route.params?.vehiculeImmat || sessionData?.vehicule?.immatriculation || "Véhicule inconnu");
  // NOUVEL ETAT pour l'ID de la tournée - Initialisé directement
  const [currentTourneeId, setCurrentTourneeId] = useState(route.params?.tourneeId || sessionData?.tournee?.id || null);

  // Réduire les logs inutiles
  console.log = (message) => {
    if (message.includes('[SessionInit]') || message.includes('[loadHistoricalData]')) {
      // Filtrer les logs pour éviter les répétitions inutiles
      return;
    }
    console.info(message);
  };

  // Limiter les appels de log pour éviter les répétitions
  const logTourneeProgress = (message) => {
    if (!message.includes('restaurés depuis la tournée') && !message.includes('sauvegardés pour la tournée')) {
      console.log(message);
    }
  };

  // Remplacer les appels de console.log par logTourneeProgress
  logTourneeProgress(`[TourneeProgress] 1 sites visités restaurés depuis la tournée ${currentTourneeId}`);
  logTourneeProgress(`[TourneeProgress] 1 sites visités sauvegardés pour la tournée ${currentTourneeId}`);

  // Référence au composant TourneeProgress
  const tourneeProgressRef = useRef(null);

  // Effet pour initialiser la session au démarrage OU récupérer la session passée
  useEffect(() => {
    const initializeOrUseExistingSession = async () => {
      setIsLoading(true);
      try {
        let session = await firebaseService.getCurrentSession();
        console.log('[ScanScreen] Current session from FirebaseService:', session);

        if (session && session.id) {
          setCurrentSession(session);
          if (session.tourneeId) {
            const tourneeDetails = await firebaseService.getTourneeById(session.tourneeId);
            console.log('[ScanScreen] Tournee details:', tourneeDetails);
            setCurrentTourneeName(tourneeDetails?.name || 'Tournée inconnue');
            setCurrentTourneeId(session.tourneeId);
          } else {
            setCurrentTourneeName('Tournée inconnue');
            console.log('[ScanScreen] tourneeId non trouvé dans la session');
          }

          if (session.vehiculeId) {
            const vehiculeDetails = await firebaseService.getVehiculeById(session.vehiculeId);
            console.log('[ScanScreen] Vehicule details:', vehiculeDetails);
            setCurrentVehiculeImmat(vehiculeDetails?.immatriculation || 'Véhicule inconnu');
          } else {
            setCurrentVehiculeImmat('Véhicule inconnu');
            console.log('[ScanScreen] vehiculeId non trouvé dans la session');
          }

          if (session.visitedSiteIdentifiers) {
            setVisitedSites(new Set(session.visitedSiteIdentifiers));
          }

          // Récupérer les informations sur le pôle si disponible
          if (session.poleId) {
            const poleDetails = await firebaseService.getPoleById(session.poleId);
            setCurrentPoleName(poleDetails?.name || 'Pôle inconnu');
          } else {
            setCurrentPoleName('Pôle inconnu');
          }


        } else {
          console.log('[ScanScreen] Aucune session active trouvée ou sessionData non fourni. Redirection ou gestion.');
          // Si route.params.sessionData existe, cela signifie une nouvelle session est en cours de création
          if (route.params?.sessionData) {
            const { tournee, vehicule, pole, vehiculeCheck } = route.params.sessionData;
            console.log('[ScanScreen] Initialisation avec sessionData des route.params:', route.params.sessionData);
            
            const newSessionData = {
              tourneeId: tournee?.id,
              vehiculeId: vehicule?.id,
              poleId: pole?.id,
              vehiculeCheck: vehiculeCheck,
              visitedSiteIdentifiers: [], // Initialiser comme tableau vide
            };

            const sessionId = await firebaseService.saveSessionData(newSessionData);
            await AsyncStorage.setItem('current_session_id', sessionId);
            const newSession = await firebaseService.getSessionById(sessionId);
            setCurrentSession(newSession); // Mettre à jour la session actuelle avec celle qui vient d'être sauvegardée
            
            setCurrentTourneeName(tournee?.name || 'Tournée inconnue');
            setCurrentVehiculeImmat(vehicule?.immatriculation || 'Véhicule inconnu');
            setCurrentPoleName(pole?.name || 'Pôle inconnu');
            setCurrentTourneeId(tournee?.id);
            setVisitedSites(new Set()); // Initialiser pour une nouvelle session
          } else {
            // Gérer le cas où il n'y a ni session existante ni nouvelles données de session
            // Peut-être rediriger vers l'écran de sélection de tournée
            console.log('[ScanScreen] Pas de session active ni de données pour en créer une. Affichage des valeurs par défaut.');
            setCurrentTourneeName('Tournée inconnue');
            setCurrentVehiculeImmat('Véhicule inconnu');
            setCurrentPoleName('Pôle inconnu');
          }
        }
      } catch (error) {
        console.error("[ScanScreen] Erreur lors de l'initialisation de la session:", error);
        Alert.alert("Erreur", "Impossible d'initialiser la session.");
        setCurrentTourneeName('Tournée inconnue');
        setCurrentVehiculeImmat('Véhicule inconnu');
        setCurrentPoleName('Pôle inconnu');
      } finally {
        setIsLoading(false);
      }
    };

    if (isFocused) {
      initializeOrUseExistingSession();
    }

    // Gestion du rafraîchissement lorsque l'écran revient au premier plan
    const unsubscribeFocus = navigation.addListener('focus', () => {
      // Pas besoin de rappeler initializeOrUseExistingSession si isFocused le fait déjà bien.
      // Cependant, si des données spécifiques doivent être rechargées à chaque focus (ex: statut de sites)
      // cela pourrait être fait ici. Pour l'instant, on s'appuie sur la logique existante.
      console.log("[ScanScreen] Screen focused");
    });

    return () => {
      unsubscribeFocus();
    };
  }, [isFocused, route.params?.sessionData]); // Retrait de navigation et autres dépendances non nécessaires si gérées par isFocused et sessionData

  // Fonction correcte pour mettre à jour uniquement le suivi de tournée sans réinitialiser le site scanné
  const updateTourneeProgress = async () => {
    try {
      console.log("Mise à jour du suivi de tournée en cours...");

      // Utiliser l'ID de session de l'état
      if (!currentSessionId) {
        console.warn("[updateTourneeProgress] currentSessionId est null, impossible de rafraîchir TourneeProgress avec la session.");
        return;
      }
      
      // Appeler loadTourneeDetails sur la référence du composant TourneeProgress
      if (tourneeProgressRef.current) {
        await tourneeProgressRef.current.loadTourneeDetails(true);
        console.log("[updateTourneeProgress] Rechargement du composant TourneeProgress effectué.");
      } else {
        console.warn("[updateTourneeProgress] tourneeProgressRef.current est null, impossible de recharger TourneeProgress.");
      }
    } catch (error) {
      console.error("Erreur lors de la mise à jour de la progression de la tournée:", error);
    }
  };

  // Ajout des points-virgules manquants
  const refreshTourneeData = () => {
    console.log("Rafraîchissement des données de la tournée...");
    updateTourneeProgress();
  };

  // Ajout des accolades manquantes dans les blocs de code
  const handleZebraScan = (event) => {
    if (event && event.nativeEvent && event.nativeEvent.key === 'Enter' && scanMode) {
      if (manualCodeInput.trim()) {
        processScannedData(manualCodeInput.trim());
        setManualCodeInput('');
      }
    }
  };

  // Effet pour gérer les événements du clavier Zebra
  useEffect(() => {
    Keyboard.addListener('keyDown', handleZebraScan);

    return () => {
      Keyboard.removeListener('keyDown', handleZebraScan);
    };
  }, [scanMode, manualCodeInput]); // Dépendances nécessaires pour que handleZebraScan fonctionne correctement

  // Effet pour détecter le paramètre refresh et rafraîchir les données
  useEffect(() => {
    if (route.params?.refresh) {
      console.log("Rafraîchissement déclenché par le bouton d'en-tête:", route.params.refresh);
      refreshTourneeData();
    }
  }, [route.params?.refresh]);

  // Surveiller les changements de route.params pour détecter quand le bouton d'historique est pressé
  useEffect(() => {
    if (route.params?.showHistory) {
      setShowHistoryModal(true);
      // Réinitialiser le paramètre pour éviter de rouvrir la modale si on navigue ailleurs puis revient
      navigation.setParams({ showHistory: false });
    }
  }, [route.params?.showHistory]);

  // Chargement des scans historiques au démarrage et récupération des paquets en cours
  useEffect(() => {
    loadHistoricalData();
  }, []);

  // Fonction pour charger tous les données d'historique et de paquets en cours
  const loadHistoricalData = async () => {
    // Vérifier et synchroniser l'ID de la tournée si nécessaire
    if (!currentTourneeId && currentSessionId) {
      try {
        console.log('[loadHistoricalData] Tentative de récupération de l\'ID de tournée depuis la session', currentSessionId);
        const sessionDoc = await firebaseService.getSessionById(currentSessionId);
        if (sessionDoc && sessionDoc.tourneeId) {
          console.log(`[loadHistoricalData] ID de tournée trouvé dans la session: ${sessionDoc.tourneeId}`);
          setCurrentTourneeId(sessionDoc.tourneeId);
        }
      } catch (err) {
        console.error('[loadHistoricalData] Erreur lors de la récupération de la session:', err);
      }
    }
    
    // Charger l'historique des scans
    await loadHistoricalScans();
    await loadFirestoreScans();
    // Charger les paquets pris en charge
    await loadTakingCarePackages();
  };

  const loadHistoricalScans = async () => {
    try {
      const jsonValue = await AsyncStorage.getItem('scanHistory');
      if (jsonValue !== null) {
        const history = JSON.parse(jsonValue);
        
        // Récupérer l'ID de la tournée actuelle
        const currentSession = await firebaseService.getCurrentSession();
        const currentTourneeId = currentSession?.tournee?.id || sessionData?.tournee?.id || '';
        
        // Filtrer l'historique local
        const today = new Date();
        today.setHours(0, 0, 0, 0); // Début de la journée
        
        const filteredHistory = history.filter(item => {
          // Convertir la date de l'item en objet Date
          let itemDate;
          try {
            itemDate = new Date(item.date);
            if (isNaN(itemDate.getTime())) {
              // Si la date n'est pas valide, essayer un autre format
              const parts = item.date.split('/');
              if (parts.length === 3) {
                itemDate = new Date(parts[2], parts[1] - 1, parts[0]);
              }
            }
          } catch (e) {
            // En cas d'erreur, considérer cet item comme non valide pour le filtre
            return false;
          }

          // S'assurer que nous avons une date valide
          if (!itemDate || isNaN(itemDate.getTime())) return false;
          
          itemDate.setHours(0, 0, 0, 0); // Normaliser à minuit
          
          // Vérifier la tournée
          const isSameTournee = !currentTourneeId || item.tourneeId === currentTourneeId;
          
          // Vérifier le statut (inclut les visites sans colis)
          const hasValidStatus = item.status === 'en-cours' || item.status === 'livré';
          
          // L'item doit être du jour courant ET de la même tournée ET avoir un statut valide
          return itemDate.getTime() === today.getTime() && isSameTournee && hasValidStatus;
        });
        
        console.log(`Historique local filtré: ${filteredHistory.length} scans (jour + tournée + statut)`);
        
        // Consolider l'historique filtré avant de mettre à jour l'état
        const consolidatedHistory = consolidateAndSortScans([], filteredHistory);

        // Enrichir avec le nom complet du site depuis Firestore
        const enrichedHistory = await Promise.all(
          consolidatedHistory.map(async (scan) => {
            // Tenter de récupérer les détails du site en utilisant siteId ou code
            try {
              const siteIdentifier = scan.siteId || scan.code; // Utiliser ID ou code
              // Vérifier si l'identifiant est probablement un site avant d'appeler getSiteById
              if (siteIdentifier && 
                  !siteIdentifier.startsWith('TEST_CONTENANT_') && 
                  !siteIdentifier.match(/^[0-9]{13,}$/)) { 
                const siteInfo = await firebaseService.getSiteById(siteIdentifier);
                if (siteInfo) {
                  // Enrichir le scan avec les détails complets
                  return { 
                    ...scan, 
                    siteName: siteInfo.nom || siteInfo.name, // Ajouter le nom pour affichage facile
                    siteDetails: { ...siteInfo } 
                  };
                }
              }
            } catch (e) {
              console.warn(`[loadHistoricalScans] Erreur récupération détails site pour ${scan.code || scan.id}:`, e);
            }
            // Si non trouvé ou erreur, retourner le scan original
            return scan;
          })
        );
        
        // Mettre à jour l'état avec l'historique enrichi
        setHistoricalScans(enrichedHistory);
        setSessionHistoryLoaded(true);
      }
    } catch (error) {
      console.error('Erreur lors du chargement de l\'historique:', error);
    }
  };

  const loadFirestoreScans = async () => {
    try {
      // On ne charge les scans Firestore que si la session est active
      const userSessionActive = await AsyncStorage.getItem('userSessionActive');
      if (userSessionActive !== 'true') {
        // Si aucune session active, on ne charge pas l'historique Firestore
        return;
      }

      // Récupérer l'ID de session actuel
      const currentSessionId = await AsyncStorage.getItem('currentSessionId');
      console.log('Chargement des scans pour la session:', currentSessionId);

      // Récupérer l'ID de la tournée actuelle
      const currentSession = await firebaseService.getCurrentSession();
      const currentTourneeId = currentSession?.tournee?.id || sessionData?.tournee?.id || '';
      console.log('Tournée actuelle:', currentTourneeId);

      setLoading(true); // Afficher l'indicateur de chargement

      // Récupérer tous les scans de l'utilisateur (sans limite)
      const scans = await firebaseService.getScans();
      
      if (scans && scans.length > 0) {
        // Ne garder que les scans du jour (J0)
        const today = new Date();
        today.setHours(0, 0, 0, 0); // Début de la journée
        
        const filteredScans = scans.filter(scan => {
          // Convertir la date du scan en objet Date
          const scanDate = dateUtils.convertTimestampToDate(scan.scanDate || scan.createdAt);
          if (!scanDate) return false;
          
          // Récupérer juste la date (sans l'heure)
          const scanDateOnly = new Date(scanDate);
          scanDateOnly.setHours(0, 0, 0, 0);
          
          // Vérifier la tournée (si une tournée actuelle est définie)
          const isSameTournee = !currentTourneeId || scan.tourneeId === currentTourneeId;
          
          // Vérifier le statut (inclut "pas_de_colis")
          const hasValidStatus = scan.status === 'en-cours' || scan.status === 'livré';
          
          // Le scan doit être du jour courant ET de la même tournée ET avoir un statut valide
          return scanDateOnly.getTime() === today.getTime() && isSameTournee && hasValidStatus;
        });
        
        // Convertir les scans Firestore filtrés en format compatible avec l'historique local
        const formattedScans = filteredScans.map(scan => {
          // Déduire le statut si manquant, basé sur le type d'opération
          let status = scan.status;
          if (!status) {
            status = scan.operationType === 'sortie' ? 'livré' : 'en-cours';
          }
          
          return {
            id: scan.id || Date.now().toString(),
            code: scan.code,
            timeStamp: dateUtils.formatTime(scan.scanDate || scan.createdAt),
            date: dateUtils.formatDate(scan.scanDate || scan.createdAt),
            site: scan.site,
            fromFirestore: true,
            sessionId: scan.sessionId,
            // Utiliser le statut (corrigé si nécessaire)
            status: status, 
            // S'assurer que le type est aussi présent
            type: scan.operationType || (status === 'livré' ? 'sortie' : 'entree'), 
            tournee: scan.tournee || '',
            tourneeId: scan.tourneeId || '',
            scanDate: scan.scanDate ? dateUtils.convertTimestampToDate(scan.scanDate).toISOString() : (scan.createdAt ? dateUtils.convertTimestampToDate(scan.createdAt).toISOString() : new Date().toISOString()) // Garder une date ISO pour le tri
          };
        });
        
        // Consolider et trier
        const consolidatedScans = consolidateAndSortScans(historicalScans, formattedScans);
        // Enrichir avec le nom complet du site depuis Firestore
        const enrichedScans = await Promise.all(
          consolidatedScans.map(async (scan) => {
            try {
              // Tenter de récupérer les détails du site
              try {
                // Utiliser l'ID du site si disponible, sinon le code barre
                const siteIdentifier = scan.siteId || scan.code; // Assumer que siteId existe
                if (siteIdentifier && 
                    !siteIdentifier.startsWith('TEST_CONTENANT_') && 
                    !siteIdentifier.match(/^[0-9]{13,}$/)) {
                  // Utiliser une variable locale au lieu de réassigner l'état siteDetails
                  const siteInfo = await firebaseService.getSiteById(siteIdentifier); 
                  if (siteInfo) {
                    // Modifier l'objet scan directement
                    scan.siteName = siteInfo.nom || siteInfo.name; // Utiliser le nom du site s'il est trouvé
                    scan.siteDetails = siteInfo; // Ajouter les détails au scan
                  } else {
                     // Si siteInfo est null, indiquer le nom comme code
                     scan.siteName = scan.code; 
                  }
                } else {
                   scan.siteName = scan.code; // Fallback si aucun identifiant
                }
              } catch (siteError) {
                console.warn(`[loadFirestoreScans] Impossible de récupérer les détails du site pour l'identifiant ${scan.siteId || scan.code}:`, siteError);
                scan.siteName = scan.code; // Afficher le code si erreur
              }
              
              // Ne récupérer les informations sur le site que s'il ne s'agit pas d'un conteneur
              if (scan.site && 
                  !scan.site.startsWith('TEST_CONTENANT_') && 
                  !scan.site.match(/^[0-9]{13,}$/)) {
                const siteInfo = await firebaseService.getSiteById(scan.site);
                if (siteInfo) return { ...scan, siteDetails: { ...siteInfo } };
              }
            } catch (e) {
              console.error('Erreur récupération nom site Firestore:', e);
            }
            return scan;
          })
        );
        
        // Mettre à jour l'état avec l'historique enrichi
        setHistoricalScans(enrichedScans);
        setSessionHistoryLoaded(true);
        
        // Sauvegarder également dans AsyncStorage pour la persistance locale temporaire
        await AsyncStorage.setItem('scanHistory', JSON.stringify(enrichedScans));
      }
      
      setLoading(false); // Masquer l'indicateur de chargement
    } catch (error) {
      console.error('Erreur lors du chargement des scans depuis Firestore:', error);
      setLoading(false); // Masquer l'indicateur de chargement en cas d'erreur
    }
  };

  // --- AJOUTER CETTE FONCTION D'AIDE --- 
  // Fonction pour consolider et trier les scans
  const consolidateAndSortScans = (existingScans, newScans) => {
    const map = new Map();

    // Ajouter les scans existants à la map
    existingScans.forEach(scan => {
      if (scan.code) map.set(scan.code, scan);
    });

    // Mettre à jour ou ajouter les nouveaux scans
    newScans.forEach(scan => {
      if (scan.code) map.set(scan.code, scan);
    });

    // Convertir la map en tableau
    const consolidated = Array.from(map.values());

    // Trier
    consolidated.sort((a, b) => {
      const dateA = a.scanDate ? new Date(a.scanDate).getTime() : 0;
      const dateB = b.scanDate ? new Date(b.scanDate).getTime() : 0;
      if (isNaN(dateA) && isNaN(dateB)) return 0;
      if (isNaN(dateA)) return 1;
      if (isNaN(dateB)) return -1;
      return dateB - dateA;
    });

    return consolidated;
  };
  // --- FIN DE L'AJOUT ---

  const loadTakingCarePackages = async () => {
    try {
      const scansEnCours = await firebaseService.getScansEnCours();
      // Filtrer pour exclure les scans "pas_de_colis"
      const filteredScans = scansEnCours.filter(scan => 
        scan.status !== 'pas_de_colis' &&
        !(scan.code && scan.code.startsWith('SITE_'))
      );
      console.log(`✅ ${filteredScans.length} paquet(s) pris en charge récupéré(s) (sans les "pas_de_colis")`);
      setTakingCarePackages(filteredScans);
    } catch (error) {
      console.error('❌ Erreur lors du chargement des paquets pris en charge:', error);
    }
  };

  // 🔹 Simulation d'un scan avec des sites valides
  const simulateScan = () => {
    if (scanMode === 'site') {
      // Sites de test qui seront reconnus comme valides
      const sitesDemoValides = [
        'SITE123',
        'SITE456',
        'SITE789',
        'LAB001',
        '12345'
      ];
      
      // Sélectionner un site aléatoire parmi les sites valides pour la démo
      return sitesDemoValides[Math.floor(Math.random() * sitesDemoValides.length)];
    } else {
      // Si on est en mode sortie (dépôt), on doit scanner un colis déjà pris en charge
      if (operationType === 'sortie') {
        // Vérifier si des colis sont disponibles
        if (takingCarePackages.length > 0) {
          // Sélectionner un colis aléatoire parmi les colis pris en charge
          const randomPackage = takingCarePackages[Math.floor(Math.random() * takingCarePackages.length)];
          return randomPackage.code;
        } else {
          // Aucun colis disponible pour le dépôt - cette condition est gérée dans handleSimulatedScan
          return '';
        }
      } else {
        // Simuler un scan de contenant pour prise en charge
        // Utiliser un préfixe spécifique pour les tests afin de pouvoir les identifier facilement
        const testId = Date.now(); // Utiliser le timestamp actuel pour créer un ID unique
        return `TEST_CONTENANT_${testId}`;
      }
    }
  };

  // Modification pour les tests : fonction mock qui simule verifySiteCode
  const mockVerifySiteCode = async (siteCode) => {
    // Sites de test qui seront automatiquement validés
    const sitesDemoValides = {
      'SITE123': { nom: 'Site Test 1', adresse: '123 Rue Principale', ville: 'Paris', codePostal: '75001' },
      'SITE456': { nom: 'Site Test 2', adresse: '456 Avenue République', ville: 'Lyon', codePostal: '69001' },
      'SITE789': { nom: 'Site Test 3', adresse: '789 Boulevard des Tests', ville: 'Toulouse', codePostal: '31000' },
      '12345': { nom: 'Laboratoire Central', adresse: '12 Rue des Sciences', ville: 'Montpellier', codePostal: '34000' },
      'LAB001': { nom: 'Laboratoire Mobile', adresse: 'Zone Industrielle', ville: 'Bordeaux', codePostal: '33000' }
    };

    // Vérifier si le code scanné est dans notre liste de sites de test
    if (sitesDemoValides[siteCode]) {
      // Retourner une structure simulant la réponse de Firebase
      return {
        valid: true,
        site: {
          id: `mock_${siteCode}`,
          code: siteCode,
          nom: sitesDemoValides[siteCode].nom,
          adresse: sitesDemoValides[siteCode].adresse,
          ville: sitesDemoValides[siteCode].ville,
          codePostal: sitesDemoValides[siteCode].codePostal
        }
      };
    }

    // Si ce n'est pas un site de test, passer à la vérification normale dans Firebase
    return await firebaseService.verifySiteCode(siteCode);
  };

  const processScannedData = async (data) => {
    console.log('Code scanné:', data);
    try {
      // Cas 1: Nous n'avons pas encore scanné de site
      if (!siteScanned && scanMode === 'site') {
        console.log('[processScannedData] Mode: Scan de site. Données:', data);
        const siteVerification = await firebaseService.verifySiteCode(data);
        console.log('[processScannedData] Résultat de verifySiteCode:', JSON.stringify(siteVerification));

        if (siteVerification.site) {
          // Enregistrer les infos du site
          setSiteCode(data);
          setSiteDetails(siteVerification.site);
          // setSiteScanned(true); // Mis plus bas pour ne l'activer qu'après succès
          // setScanMode(''); // Mis plus bas
          // setShowOperationTypeSelection(true); // Mis plus bas

          // --- MODIFIÉ: Ne trouver que le premier site non visité avec ce nom ---
          let occurrenceIndex = null;
          if (tourneeProgressRef.current?.getSitesWithStatus) {
            const sitesList = tourneeProgressRef.current.getSitesWithStatus();
            console.log('[processScannedData] sitesList depuis tourneeProgressRef:', JSON.stringify(sitesList.map(s => ({ id: s.id, name: s.name, visited: s.visited, uniqueDisplayId: s.uniqueDisplayId }))));
            const siteNameToFind = siteVerification.site.nom || siteVerification.site.name;
            console.log('[processScannedData] Nom du site à trouver:', siteNameToFind);

            // Trouver le premier site non visité avec ce nom
            occurrenceIndex = sitesList.findIndex(s => !s.visited && (s.name === siteNameToFind || s.nom === siteNameToFind)); // Ajout de s.nom
            console.log(`[processScannedData] Occurrence index trouvée pour ${siteNameToFind}:`, occurrenceIndex);
            
            // Si aucun site non visité n'est trouvé, ne rien faire
            if (occurrenceIndex === -1) {
              Alert.alert(
                'Site déjà visité ou non trouvé', // Message mis à jour
                'Ce site a déjà été visité, ne fait pas partie de cette tournée, ou son nom ne correspond pas exactement.', // Message mis à jour
                [{ text: 'OK', onPress: () => {
                  // Réinitialiser l'état pour permettre un nouveau scan
                  setSiteScanned(false);
                  setSiteDetails(null);
                  setSiteCode('');
                  setShowOperationTypeSelection(false);
                }}]
              );
              return;
            }
          } else {
            console.warn('[processScannedData] tourneeProgressRef.current.getSitesWithStatus non disponible.');
            Alert.alert('Erreur', 'Impossible de récupérer la liste des sites de la tournée.');
            return;
          }

          // Marquage en session via l'index si trouvé, sinon par site.id
          const identifier = siteVerification.site.id || (siteVerification.site.code || data);
          console.log('[processScannedData] Identifier pour markSiteVisitedInSession:', identifier);
          console.log('[processScannedData] currentSessionId avant appel:', currentSessionId);
          console.log('[processScannedData] occurrenceIndex avant appel:', occurrenceIndex);

          if (!currentSessionId) {
            console.error('[processScannedData] ID de session manquant avant markSiteVisitedInSession');
            Alert.alert('Erreur Critique', 'ID de session manquant. Impossible de continuer.');
            return;
          }
          
          // Ne marquer qu'un seul site à la fois, en utilisant l'index spécifique
          if (occurrenceIndex !== -1 && occurrenceIndex !== null) { // Condition déjà présente, mais on log avant
            const markSuccess = await firebaseService.markSiteVisitedInSession(currentSessionId, identifier, occurrenceIndex);
            console.log('[processScannedData] Résultat de markSiteVisitedInSession:', markSuccess);
            
            if (markSuccess) {
              setSiteScanned(true); // Activer seulement si le marquage Firestore a réussi
              setScanMode(''); 
              setShowOperationTypeSelection(true);

              // Mise à jour du UI local - mettre à jour uniquement le site spécifique
              if (tourneeProgressRef.current?.markSiteAsVisitedLocally) {
                console.log('[processScannedData] Appel de markSiteAsVisitedLocally avec:', identifier, occurrenceIndex);
                await tourneeProgressRef.current.markSiteAsVisitedLocally(identifier, occurrenceIndex); // AJOUT DE AWAIT
                // Temporairement commenté pour tester si la coche se met à jour correctement sans rechargement immédiat
                // await updateTourneeProgress(); 
              } else if (tourneeProgressRef.current?.loadTourneeDetails) {
                console.log('[processScannedData] Appel de loadTourneeDetails(true) car markSiteAsVisitedLocally non dispo.');
                await tourneeProgressRef.current.loadTourneeDetails(true);
              }
            } else {
              Alert.alert('Erreur', 'Échec du marquage du site comme visité dans la session Firestore.');
              // Garder siteScanned à false, etc.
            }
            
            // Si updateTourneeProgress a été commenté, on peut appeler loadHistoricalData ici
            // si c'est nécessaire pour d'autres parties de l'UI non liées à TourneeProgress.
            // Pour l'instant, on isole le problème de la coche.
            // await loadHistoricalData(); 

          } else {
             console.warn('[processScannedData] occurrenceIndex invalide, markSiteVisitedInSession non appelé.');
             // Potentiellement une alerte ici si ce cas ne devrait pas arriver
          }
          return;
        } else { // siteVerification.site est null/undefined
          console.log('[processScannedData] Aucun site valide retourné par verifySiteCode pour le code:', data);
          Alert.alert('Site Inconnu', 'Le code scanné ne correspond à aucun site connu.');
           // Réinitialiser pour permettre un nouveau scan
          setSiteScanned(false);
          setSiteDetails(null);
          setSiteCode('');
          setShowOperationTypeSelection(false);
        }
      }
      
      // Cas 2: Site déjà scanné, nous scannons maintenant un contenant
      if (siteScanned && scanMode === 'contenant') {
        console.log('[processScannedData] Mode: Scan de contenant. Données:', data);
        handleContenantScan(data);
        // Rester en mode scan contenant pour permettre les scans multiples
        setScanMode('contenant');
      }
    } catch (error) {
      console.error('Erreur lors de la gestion du scan:', error);
      setErrorMessage('Erreur: ' + error.message); // Afficher l'erreur à l'utilisateur
      setScanMode(''); // Réinitialiser le mode scan
      // Optionnel: réinitialiser d'autres états si nécessaire
      setSiteScanned(false);
      setSiteDetails(null);
      setSiteCode('');
      setShowOperationTypeSelection(false);
    }
  };

  // Gérer la simulation d'un scan (pour le développement et les tests)
  const handleSimulatedScan = () => {
    // Vérifier si on est en mode sortie sans colis pris en charge
    if (scanMode === 'contenant' && operationType === 'sortie' && takingCarePackages.length === 0) {
      Alert.alert(
        "Aucun colis disponible",
        "Vous n'avez aucun colis en prise en charge à déposer.",
        [{ text: "OK" }]
      );
      return;
    }
    
    const fakeData = simulateScan();
    if (fakeData) {
      console.log(`Simulation de scan avec données: ${fakeData}`);
    processScannedData(fakeData);
    } else {
      console.error("Erreur lors de la simulation du scan: aucune donnée générée");
      Alert.alert(
        "Erreur",
        "Impossible de simuler un scan. Veuillez réessayer.",
        [{ text: "OK" }]
      );
    }
  };

  const handleManualScan = () => {
    if (manualCodeInput.trim() === '') {
      Alert.alert('Erreur', 'Veuillez entrer un code valide');
      return;
    }
    
    processScannedData(manualCodeInput.trim());
    setManualCodeInput('');
  };

  const activateSiteScan = () => {
    setScanMode('site');
    setErrorMessage('');
    setIsReadyForScan(true);
    
    // Montrer une alerte avec plusieurs options pour scanner
    Alert.alert(
      "Scanner un site",
      "Comment souhaitez-vous scanner le site ?",
      [
        {
          text: "Scanner manuellement",
          onPress: () => showManualSiteInput()
        },
        {
          text: "Simuler scan",
          onPress: handleSimulatedScan
        },
        {
          text: "Annuler",
          style: "cancel",
          onPress: () => setScanMode('')
        }
      ]
    );
  };

  // Fonction pour afficher une boîte de dialogue pour saisir manuellement le code du site
  const showManualSiteInput = () => {
    // Utiliser Alert.prompt sur iOS, mais sur Android, cette fonction n'existe pas
    // donc nous utilisons une méthode alternative
    if (Platform.OS === 'ios') {
      Alert.prompt(
        "Scanner site manuellement",
        "Entrez le code ou le nom du site",
        [
          { text: "Annuler", onPress: () => setScanMode(''), style: "cancel" },
          { 
            text: "Scanner", 
            onPress: (code) => {
              if (code && code.trim()) {
                processScannedData(code.trim());
              } else {
                setScanMode('');
                Alert.alert("Erreur", "Veuillez entrer un code de site valide");
              }
            }
          }
        ],
        "plain-text"
      );
    } else {
      // Sur Android, utiliser une solution simple avec TextInput
      Alert.alert(
        "Scanner site manuellement",
        "Entrez le code du site dans le champ de texte en haut de l'écran, puis appuyez sur Scanner",
        [
          { text: "OK" }
        ]
      );
      // Focus sur le champ de saisie manuelle
      // Note: ceci est une approche simplifiée, une solution plus robuste
      // utiliserait un modal personnalisé avec TextInput
      setManualCodeInput('');
      // On garde le mode scan actif pour que le bouton scanner manuel fonctionne
    }
  };

  // Afficher la page de sélection du type d'opération
  const showOperationSelection = () => {
    setShowOperationTypeSelection(true);
  };

  // Commencer le scan de contenant avec un type d'opération spécifique
  const startContenantScan = (type) => {
    setOperationType(type);
    setShowOperationTypeSelection(false);
    setScanMode('contenant');
    setErrorMessage('');
    setIsReadyForScan(true);
    
    // Message différent selon le type d'opération
    const message = type === 'entree' 
      ? "Veuillez scanner le code du contenant à prendre en charge" 
      : "Veuillez scanner le code du contenant à déposer";
    
    Alert.alert(
      type === 'entree' ? "Prise en charge" : "Dépôt",
      message,
      [{ text: "Annuler", onPress: () => setScanMode('') }]
    );
  };

  const handleContenantScan = async (code) => {
    if (!siteScanned) {
      Alert.alert('Erreur', 'Veuillez d\'abord scanner un site');
      return;
    }

    try {
      // Mode dépôt (sortie) - vérifier que le colis est dans la liste des colis pris en charge
      if (operationType === 'sortie') {
        const isInTakingCare = takingCarePackages.some(pkg => pkg.code === code);
        if (!isInTakingCare) {
          Alert.alert(
            "Colis non reconnu",
            "Ce colis ne fait pas partie des colis que vous avez en prise en charge.",
            [{ text: "OK" }]
          );
          return;
        }
        
        // Retirer le colis de la liste des colis pris en charge
        setTakingCarePackages(takingCarePackages.filter(pkg => pkg.code !== code));
      }

      // Obtenir la date actuelle au format approprié
      const currentDate = new Date();
      const currentDateISO = currentDate.toISOString();

      // Ajouter le contenant à la liste
      const newContenant = {
        id: Date.now().toString(),
        code: code,
        idColis: code,
        timeStamp: currentDate.toLocaleTimeString(),
        date: currentDate.toLocaleDateString(),
        scanDate: currentDateISO,
        site: siteCode,
        type: operationType, // Ajout du type d'opération (entrée/sortie)
      };
      
      setScannedContenants([newContenant, ...scannedContenants]);
    } catch (error) {
      console.error('Erreur lors de la gestion du scan:', error);
      setScanMode('');
    }
  };

  const renderScannedItem = ({ item }) => (
    <View style={[styles.contenantItem, item.type === 'sortie' ? styles.contenantItemSortie : styles.contenantItemEntree]}>
      <View style={styles.contenantInfo}>
        <Text style={styles.contenantCode}>{item.code}</Text>
        <View style={styles.contenantTypeRow}>
          <View style={item.type === 'sortie' ? styles.typeTagSortie : styles.typeTagEntree}>
            <Text style={styles.typeTagText}>{item.type === 'sortie' ? 'Dépôt' : 'Prise en charge'}</Text>
          </View>
          <Text style={styles.contenantTime}>{item.timeStamp}</Text>
        </View>
      </View>
      <TouchableOpacity
        style={styles.deleteContenantButton}
        onPress={() => removeScannedContenant(item.id)}
      >
        <Ionicons name="trash-outline" size={20} color="#e74c3c" />
      </TouchableOpacity>
    </View>
  );

  const removeScannedContenant = (id) => {
    setScannedContenants(scannedContenants.filter(contenant => contenant.id !== id));
  };

  const handleTransmit = async () => {
    if (scannedContenants.length === 0) {
      Alert.alert('Attention', 'Aucun contenant scanné à transmettre.');
      return;
    }

    setLoading(true);

    try {
      // Vérifier et afficher les données de la session pour le débogage
      console.log('Données de session:', JSON.stringify(sessionData, null, 2));
      console.log('Données de route:', JSON.stringify(route.params, null, 2));
      
      // Récupérer les données de la tournée et du véhicule avec plus de vérifications
      const tourneeName = sessionData.tournee?.nom || route.params?.tournee?.nom || '';
      const tourneeId = sessionData.tournee?.id || route.params?.tournee?.id || '';
      const vehiculeName = sessionData.vehicule?.immatriculation || route.params?.vehicule?.immatriculation || '';
      const vehiculeId = sessionData.vehicule?.id || route.params?.vehicule?.id || '';
      
      // Utiliser les détails du site validé s'ils sont disponibles
      let siteName, siteId, siteAdresse, siteCodePostal, siteVille;
      
      if (siteDetails) {
        // Utiliser les bonnes clés du siteDetails (nommage uniforme)
        siteName = siteDetails.name || siteCode;
        siteId = siteDetails.id || '';
        siteAdresse = siteDetails.address || '';
        siteCodePostal = siteDetails.codePostal || '';
        siteVille = siteDetails.city || '';
      } else {
        // Sinon on utilise ce qu'on a par défaut
        siteName = sessionData.tournee?.siteDepart || route.params?.tournee?.siteDepart || siteCode || 'Non spécifié';
        siteId = '';
      }
      
      console.log('Données récupérées pour les scans:', {
        tourneeName,
        tourneeId,
        vehiculeName,
        vehiculeId,
        siteName,
        siteId,
        siteCode
      });

      // Récupérer l'ID de session actuel
      const currentSessionId = await AsyncStorage.getItem('currentSessionId') || `session_${Date.now()}`;
      
      // Préparer les scans avec tous les champs nécessaires
      const scansToSubmit = scannedContenants.map(scan => {
        const scanDate = scan.scanDate || new Date().toISOString();
        
        // Le code du contenant devient l'ID du colis
        const scanItem = {
          code: scan.code,
          idColis: scan.code || scan.idColis,
          scanDate: scanDate,
          tournee: tourneeName,
          tourneeId: tourneeId,
          vehicule: vehiculeName,
          vehiculeId: vehiculeId,
          immatriculation: vehiculeName,
          site: siteName,
          siteId: siteId,
          siteCode: siteCode,
          siteDepart: siteName,
          siteDépart: siteName,
          sessionId: currentSessionId, // Ajouter l'ID de session pour le filtrage ultérieur
          operationType: scan.type || 'entree', // Ajout du type d'opération
          status: scan.type === 'sortie' ? 'livré' : 'en-cours', // Status basé sur le type d'opération
          type: scan.type || 'entree' // Assurer que le type est inclus explicitement
        };
        
        // Ajouter siteFin uniquement pour les colis livrés
        if (scan.type === 'sortie') {
          // Pour les opérations de sortie (dépôt), ajouter des informations spécifiques
          const currentDate = new Date();
          
          // Utiliser le nom du site actuel comme site d'arrivée
          scanItem.siteFin = siteName;
          // Ajouter date et heure d'arrivée au format correct
          scanItem.dateArrivee = currentDate.toLocaleDateString();
          scanItem.heureArrivee = currentDate.toLocaleTimeString();
          // Ajouter ces champs supplémentaires pour assurer la compatibilité
          scanItem.dateHeureFin = currentDate.toISOString();
          scanItem.statut = 'Livré';
          scanItem.status = 'livré'; // Assurez-vous que les deux formats sont présents
          scanItem.coursierLivraison = sessionData.coursierCharg || route.params?.coursierCharg || '';
        }
        
        // Ajouter les détails du site s'ils sont disponibles
        if (siteDetails) {
          scanItem.siteDetails = {
            adresse: siteAdresse,
            codePostal: siteCodePostal,
            ville: siteVille
          };
        }

        // Ajouter la localisation si disponible
        if (sessionData.location) {
          scanItem.location = {
            latitude: sessionData.location.coords.latitude,
            longitude: sessionData.location.coords.longitude,
            accuracy: sessionData.location.coords.accuracy
          };
        }

        return scanItem;
      });
      
      // Afficher les données qui seront transmises
      console.log('Transmission des scans:', JSON.stringify(scansToSubmit, null, 2)); // Décommenté pour débogage
      
      // Envoyer les scans à Firebase
      const result = await firebaseService.addScans(scansToSubmit);
      console.log('Résultat de la transmission:', result);
      
      // Si la transmission réussit, mettre à jour l'historique local
      if (result.success) {
        // --- Logique de consolidation --- 
        const updatedScansMap = new Map();
        historicalScans.forEach(scan => {
          // Assurer qu'on a un code pour la clé de la map
          if (scan.code) {
            updatedScansMap.set(scan.code, scan);
          }
        });
        scansToSubmit.forEach(scan => {
          if (scan.code) {
            const originalScan = scannedContenants.find(s => s.code === scan.code);
            const scanForHistory = {
              ...scan,
              timeStamp: originalScan?.timeStamp || dateUtils.formatTime(scan.scanDate),
            };
            updatedScansMap.set(scan.code, scanForHistory);
          }
        });
        const newHistory = Array.from(updatedScansMap.values());
        newHistory.sort((a, b) => {
          const dateA = a.scanDate ? new Date(a.scanDate).getTime() : 0;
          const dateB = b.scanDate ? new Date(b.scanDate).getTime() : 0;
          if (isNaN(dateA) && isNaN(dateB)) return 0;
          if (isNaN(dateA)) return 1;
          if (isNaN(dateB)) return -1;
          return dateB - dateA;
        });
        // --- Fin de la logique de consolidation ---

        // Sauvegarder l'historique consolidé dans AsyncStorage
        await AsyncStorage.setItem('scanHistory', JSON.stringify(newHistory));
        
        // Mise à jour de l'état React DIFFÉRÉE après les interactions
        InteractionManager.runAfterInteractions(() => {
          setHistoricalScans(newHistory);
        });
        
        // Mettre à jour la liste des paquets pris en charge
        if (operationType === 'entree') {
          setTakingCarePackages([...scansToSubmit, ...takingCarePackages]);
        } else if (operationType === 'sortie') {
          const codesDeposited = scansToSubmit.map(scan => scan.code);
          setTakingCarePackages(takingCarePackages.filter(pkg => pkg.code && !codesDeposited.includes(pkg.code)));
        }
        
        // Réinitialiser complètement l'état pour revenir à l'écran de scan de site
        resetScan(); // Cette fonction réinitialise les états de base

        // S'assurer que tous les états sont correctement réinitialisés pour revenir à l'écran initial
        setShowOperationTypeSelection(false);
        setOperationType('entree'); // Réinitialiser à l'entrée de colis par défaut
        
        // Important: Désactiver le chargement AVANT l'alerte
        setLoading(false);
        
        // Afficher l'alerte de succès
        Alert.alert(
          'Succès',
          `${scansToSubmit.length} scan(s) transmis avec succès`,
          [{ text: 'OK' }]
        );
      } else {
        setLoading(false);
        throw new Error(result.error || 'Échec de la transmission');
      }
    } catch (error) {
      console.error('Erreur lors de la transmission:', error);
      setLoading(false);
      Alert.alert('Erreur', `Échec de la transmission: ${error.message}`);
    }
  };

  const resetScan = () => {
    setScanMode('');
    setSiteScanned(false);
    setSiteCode('');
    setScannedContenants([]);
    setManualCodeInput('');
    setSiteDetails(null);
  };

  const navigateToHistory = () => {
    setShowHistoryModal(true);
  };

  // Fonction pour obtenir les détails de la session actuelle
  const getSessionDetails = async () => {
    try {
      const currentSession = await firebaseService.getCurrentSession();
      if (currentSession) {
        setSessionId(currentSession.id);
        setTournee(currentSession.tournee);
        setVehicule(currentSession.vehicule);
        setPole(currentSession.pole);
      }
    } catch (error) {
      console.error("Erreur lors de la récupération de la session:", error);
    }
  };

  // Fonction pour effacer l'historique des scans
  const clearHistoricalScans = async () => {
    try {
      Alert.alert(
        'Effacer l\'historique',
        'Voulez-vous vraiment effacer tout l\'historique des scans?',
        [
          {
            text: 'Annuler',
            style: 'cancel'
          },
          {
            text: 'Effacer',
            onPress: async () => {
              await AsyncStorage.removeItem('scanHistory');
              setHistoricalScans([]);
              Alert.alert('Succès', 'Historique effacé avec succès');
            },
            style: 'destructive'
          }
        ]
      );
    } catch (error) {
      console.error('Erreur lors de l\'effacement de l\'historique:', error);
      Alert.alert('Erreur', 'Impossible d\'effacer l\'historique');
    }
  };

  // Ajout d'une fonction pour effacer explicitement tous les scans de la session actuelle
  const clearCurrentSessionScans = async () => {
    try {
      const currentSessionId = await AsyncStorage.getItem('currentSessionId');
      if (!currentSessionId) {
        Alert.alert('Erreur', 'Impossible de déterminer la session actuelle');
        return;
      }
      
      Alert.alert(
        'Réinitialiser l\'historique',
        'Cette action va supprimer tous les scans associés à votre session actuelle. Continuer?',
        [
          {
            text: 'Annuler',
            style: 'cancel'
          },
          {
            text: 'Supprimer',
            onPress: async () => {
              try {
                // Supprimer les scans associés à la session actuelle
                setLoading(true);
                console.log(`Suppression des scans de la session ${currentSessionId}...`);
                
                // Fonction côté service qui devrait être implémentée
                // pour supprimer tous les scans de la session
                const result = await firebaseService.clearSessionScans(currentSessionId);
                
                // Supprimer l'historique local également
                await AsyncStorage.removeItem('scanHistory');
                setHistoricalScans([]);
                
                setLoading(false);
                Alert.alert('Succès', 'Historique réinitialisé avec succès');
              } catch (error) {
                setLoading(false);
                console.error('Erreur lors de la suppression des scans:', error);
                Alert.alert('Erreur', `Échec de la suppression: ${error.message}`);
              }
            },
            style: 'destructive'
          }
        ]
      );
    } catch (error) {
      console.error('Erreur:', error);
      Alert.alert('Erreur', 'Une erreur est survenue');
    }
  };

  // Handler de déconnexion avec effacement complet de l'historique
  const handleLogout = async () => {
    try {
      Alert.alert(
        'Déconnexion',
        'Voulez-vous vous déconnecter? L\'historique des scans sera effacé.',
        [
          {
            text: 'Annuler',
            style: 'cancel'
          },
          {
            text: 'Déconnecter',
            onPress: async () => {
              try {
                setLoading(true);
                console.log('Déconnexion en cours...');

                // Appeler la méthode de déconnexion de Firebase
                await firebaseService.logout();
                console.log('Déconnexion Firebase réussie');
                
                // Effacer toutes les données de session
                await AsyncStorage.removeItem('userSessionActive');
                // On conserve current_session_id pour que la tournée visitée reste en mémoire
                await AsyncStorage.removeItem('scanHistory');
                await AsyncStorage.removeItem('user_selas_id');
                
                // Réinitialiser les états
                setHistoricalScans([]);
                setScannedContenants([]);
                setSiteScanned(false);
                setSiteCode('');
                
                setLoading(false);
                
                // Rediriger vers l'écran de connexion
                navigation.reset({
                  index: 0,
                  routes: [{ name: 'Login' }]
                });
              } catch (error) {
                setLoading(false);
                console.error('Erreur lors du processus de déconnexion:', error);
                Alert.alert('Erreur', 'Impossible de se déconnecter. Veuillez réessayer.');
              }
            }
          }
        ]
      );
    } catch (error) {
      console.error('Erreur lors de la déconnexion:', error);
    }
  };

  // Utiliser directement les fonctions de formatage de dateUtils
  // au lieu de redéfinir des fonctions similaires

  // Effet pour écouter les événements de scan Zebra
  useEffect(() => {
    if (isReadyForScan) {
      // Afficher un message pour indiquer que l'application est prête pour le scan
      console.log('Prêt à recevoir des scans du scanner Zebra');
      
      // Configuration pour recevoir les scans du matériel Zebra
      const handleZebraScan = (event) => {
        // Le scanner Zebra envoie généralement les données comme des entrées clavier
        // Nous devons vérifier que nous sommes en mode scan et traiter les données
        if (event && event.nativeEvent && event.nativeEvent.key === 'Enter' && scanMode) {
          // Récupérer le texte scanné (par exemple depuis un champ de texte caché ou via une API Zebra)
          // Pour les besoins de cet exemple, nous utiliserons la valeur de manualCodeInput
          if (manualCodeInput.trim()) {
            processScannedData(manualCodeInput.trim());
            setManualCodeInput(''); // Réinitialiser après le traitement
          }
        }
      };
      
      // Ajoutez ici l'initialisation spécifique au scanner Zebra si nécessaire
      // Exemple : ZebraScanner.initialize() si une API Zebra est disponible
      
      // Pour cet exemple, on simule en utilisant l'écouteur de clavier (pour Enter)
      Keyboard.addListener('keyDown', handleZebraScan);
      
      return () => {
        // Nettoyage lors du démontage
        Keyboard.removeListener('keyDown', handleZebraScan);
        // Désinitialiser le scanner Zebra si nécessaire
        // Exemple : ZebraScanner.deinitialize()
      };
    }
  }, [isReadyForScan, scanMode, manualCodeInput]);


  const loadHistoricalScans = async () => {
    try {
      const jsonValue = await AsyncStorage.getItem('scanHistory');
      if (jsonValue !== null) {
        const history = JSON.parse(jsonValue);
        
        // Récupérer l'ID de la tournée actuelle
        const currentSession = await firebaseService.getCurrentSession();
        const currentTourneeId = currentSession?.tournee?.id || sessionData?.tournee?.id || '';
        
        // Filtrer l'historique local
        const today = new Date();
        today.setHours(0, 0, 0, 0); // Début de la journée
        
        const filteredHistory = history.filter(item => {
          // Convertir la date de l'item en objet Date
          let itemDate;
          try {
            itemDate = new Date(item.date);
            if (isNaN(itemDate.getTime())) {
              // Si la date n'est pas valide, essayer un autre format
              const parts = item.date.split('/');
              if (parts.length === 3) {
                itemDate = new Date(parts[2], parts[1] - 1, parts[0]);
              }
            }
          } catch (e) {
            // En cas d'erreur, considérer cet item comme non valide pour le filtre
            return false;
          }

          // S'assurer que nous avons une date valide
          if (!itemDate || isNaN(itemDate.getTime())) return false;
          
          itemDate.setHours(0, 0, 0, 0); // Normaliser à minuit
          
          // Vérifier la tournée
          const isSameTournee = !currentTourneeId || item.tourneeId === currentTourneeId;
          
          // Vérifier le statut (inclut les visites sans colis)
          const hasValidStatus = item.status === 'en-cours' || item.status === 'livré';
          
          // L'item doit être du jour courant ET de la même tournée ET avoir un statut valide
          return itemDate.getTime() === today.getTime() && isSameTournee && hasValidStatus;
        });
        
        console.log(`Historique local filtré: ${filteredHistory.length} scans (jour + tournée + statut)`);
        
        // Consolider l'historique filtré avant de mettre à jour l'état
        const consolidatedHistory = consolidateAndSortScans([], filteredHistory);

        // Enrichir avec le nom complet du site depuis Firestore
        const enrichedHistory = await Promise.all(
          consolidatedHistory.map(async (scan) => {
            // Tenter de récupérer les détails du site en utilisant siteId ou code
            try {
              const siteIdentifier = scan.siteId || scan.code; // Utiliser ID ou code
              // Vérifier si l'identifiant est probablement un site avant d'appeler getSiteById
              if (siteIdentifier && 
                  !siteIdentifier.startsWith('TEST_CONTENANT_') && 
                  !siteIdentifier.match(/^[0-9]{13,}$/)) { 
                const siteInfo = await firebaseService.getSiteById(siteIdentifier);
                if (siteInfo) {
                  // Enrichir le scan avec les détails complets
                  return { 
                    ...scan, 
                    siteName: siteInfo.nom || siteInfo.name, // Ajouter le nom pour affichage facile
                    siteDetails: { ...siteInfo } 
                  };
                }
              }
            } catch (e) {
              console.warn(`[loadHistoricalScans] Erreur récupération détails site pour ${scan.code || scan.id}:`, e);
            }
            // Si non trouvé ou erreur, retourner le scan original
            return scan;
          })
        );
        
        // Mettre à jour l'état avec l'historique enrichi
        setHistoricalScans(enrichedHistory);
        setSessionHistoryLoaded(true);
      }
    } catch (error) {
      console.error('Erreur lors du chargement de l\'historique:', error);
    }
  };

  const loadFirestoreScans = async () => {
    try {
      // On ne charge les scans Firestore que si la session est active
      const userSessionActive = await AsyncStorage.getItem('userSessionActive');
      if (userSessionActive !== 'true') {
        // Si aucune session active, on ne charge pas l'historique Firestore
        return;
      }

      // Récupérer l'ID de session actuel
      const currentSessionId = await AsyncStorage.getItem('currentSessionId');
      console.log('Chargement des scans pour la session:', currentSessionId);

      // Récupérer l'ID de la tournée actuelle
      const currentSession = await firebaseService.getCurrentSession();
      const currentTourneeId = currentSession?.tournee?.id || sessionData?.tournee?.id || '';
      console.log('Tournée actuelle:', currentTourneeId);

      setLoading(true); // Afficher l'indicateur de chargement

      // Récupérer tous les scans de l'utilisateur (sans limite)
      const scans = await firebaseService.getScans();
      
      if (scans && scans.length > 0) {
        // Ne garder que les scans du jour (J0)
        const today = new Date();
        today.setHours(0, 0, 0, 0); // Début de la journée
        
        const filteredScans = scans.filter(scan => {
          // Convertir la date du scan en objet Date
          const scanDate = dateUtils.convertTimestampToDate(scan.scanDate || scan.createdAt);
          if (!scanDate) return false;
          
          // Récupérer juste la date (sans l'heure)
          const scanDateOnly = new Date(scanDate);
          scanDateOnly.setHours(0, 0, 0, 0);
          
          // Vérifier la tournée (si une tournée actuelle est définie)
          const isSameTournee = !currentTourneeId || scan.tourneeId === currentTourneeId;
          
          // Vérifier le statut (inclut "pas_de_colis")
          const hasValidStatus = scan.status === 'en-cours' || scan.status === 'livré';
          
          // Le scan doit être du jour courant ET de la même tournée ET avoir un statut valide
          return scanDateOnly.getTime() === today.getTime() && isSameTournee && hasValidStatus;
        });
        
        // Convertir les scans Firestore filtrés en format compatible avec l'historique local
        const formattedScans = filteredScans.map(scan => {
          // Déduire le statut si manquant, basé sur le type d'opération
          let status = scan.status;
          if (!status) {
            status = scan.operationType === 'sortie' ? 'livré' : 'en-cours';
          }
          
          return {
            id: scan.id || Date.now().toString(),
            code: scan.code,
            timeStamp: dateUtils.formatTime(scan.scanDate || scan.createdAt),
            date: dateUtils.formatDate(scan.scanDate || scan.createdAt),
            site: scan.site,
            fromFirestore: true,
            sessionId: scan.sessionId,
            // Utiliser le statut (corrigé si nécessaire)
            status: status, 
            // S'assurer que le type est aussi présent
            type: scan.operationType || (status === 'livré' ? 'sortie' : 'entree'), 
            tournee: scan.tournee || '',
            tourneeId: scan.tourneeId || '',
            scanDate: scan.scanDate ? dateUtils.convertTimestampToDate(scan.scanDate).toISOString() : (scan.createdAt ? dateUtils.convertTimestampToDate(scan.createdAt).toISOString() : new Date().toISOString()) // Garder une date ISO pour le tri
          };
        });
        
        // Consolider et trier
        const consolidatedScans = consolidateAndSortScans(historicalScans, formattedScans);
        // Enrichir avec le nom complet du site depuis Firestore
        const enrichedScans = await Promise.all(
          consolidatedScans.map(async (scan) => {
            try {
              // Tenter de récupérer les détails du site
              try {
                // Utiliser l'ID du site si disponible, sinon le code barre
                const siteIdentifier = scan.siteId || scan.code; // Assumer que siteId existe
                if (siteIdentifier && 
                    !siteIdentifier.startsWith('TEST_CONTENANT_') && 
                    !siteIdentifier.match(/^[0-9]{13,}$/)) {
                  // Utiliser une variable locale au lieu de réassigner l'état siteDetails
                  const siteInfo = await firebaseService.getSiteById(siteIdentifier); 
                  if (siteInfo) {
                    // Modifier l'objet scan directement
                    scan.siteName = siteInfo.nom || siteInfo.name; // Utiliser le nom du site s'il est trouvé
                    scan.siteDetails = siteInfo; // Ajouter les détails au scan
                  } else {
                     // Si siteInfo est null, indiquer le nom comme code
                     scan.siteName = scan.code; 
                  }
                } else {
                   scan.siteName = scan.code; // Fallback si aucun identifiant
                }
              } catch (siteError) {
                console.warn(`[loadFirestoreScans] Impossible de récupérer les détails du site pour l'identifiant ${scan.siteId || scan.code}:`, siteError);
                scan.siteName = scan.code; // Afficher le code si erreur
              }
              
              // Ne récupérer les informations sur le site que s'il ne s'agit pas d'un conteneur
              if (scan.site && 
                  !scan.site.startsWith('TEST_CONTENANT_') && 
                  !scan.site.match(/^[0-9]{13,}$/)) {
                const siteInfo = await firebaseService.getSiteById(scan.site);
                if (siteInfo) return { ...scan, siteDetails: { ...siteInfo } };
              }
            } catch (e) {
              console.error('Erreur récupération nom site Firestore:', e);
            }
            return scan;
          })
        );
        
        // Mettre à jour l'état avec l'historique enrichi
        setHistoricalScans(enrichedScans);
        setSessionHistoryLoaded(true);
        
        // Sauvegarder également dans AsyncStorage pour la persistance locale temporaire
        await AsyncStorage.setItem('scanHistory', JSON.stringify(enrichedScans));
      }
      
      setLoading(false); // Masquer l'indicateur de chargement
    } catch (error) {
      console.error('Erreur lors du chargement des scans depuis Firestore:', error);
      setLoading(false); // Masquer l'indicateur de chargement en cas d'erreur
    }
  };

  // --- AJOUTER CETTE FONCTION D'AIDE --- 
  // Fonction pour consolider et trier les scans
  const consolidateAndSortScans = (existingScans, newScans) => {
    const map = new Map();

    // Ajouter les scans existants à la map
    existingScans.forEach(scan => {
      if (scan.code) map.set(scan.code, scan);
    });

    // Mettre à jour ou ajouter les nouveaux scans
    newScans.forEach(scan => {
      if (scan.code) map.set(scan.code, scan);
    });

    // Convertir la map en tableau
    const consolidated = Array.from(map.values());

    // Trier
    consolidated.sort((a, b) => {
      const dateA = a.scanDate ? new Date(a.scanDate).getTime() : 0;
      const dateB = b.scanDate ? new Date(b.scanDate).getTime() : 0;
      if (isNaN(dateA) && isNaN(dateB)) return 0;
      if (isNaN(dateA)) return 1;
      if (isNaN(dateB)) return -1;
      return dateB - dateA;
    });

    return consolidated;
  };
  // --- FIN DE L'AJOUT ---

  const loadTakingCarePackages = async () => {
    try {
      const scansEnCours = await firebaseService.getScansEnCours();
      // Filtrer pour exclure les scans "pas_de_colis"
      const filteredScans = scansEnCours.filter(scan => 
        scan.status !== 'pas_de_colis' &&
        !(scan.code && scan.code.startsWith('SITE_'))
      );
      console.log(`✅ ${filteredScans.length} paquet(s) pris en charge récupéré(s) (sans les "pas_de_colis")`);
      setTakingCarePackages(filteredScans);
    } catch (error) {
      console.error('❌ Erreur lors du chargement des paquets pris en charge:', error);
    }
  };

  // 🔹 Simulation d'un scan avec des sites valides
  const simulateScan = () => {
    if (scanMode === 'site') {
      // Sites de test qui seront reconnus comme valides
      const sitesDemoValides = [
        'SITE123',
        'SITE456',
        'SITE789',
        'LAB001',
        '12345'
      ];
      
      // Sélectionner un site aléatoire parmi les sites valides pour la démo
      return sitesDemoValides[Math.floor(Math.random() * sitesDemoValides.length)];
    } else {
      // Si on est en mode sortie (dépôt), on doit scanner un colis déjà pris en charge
      if (operationType === 'sortie') {
        // Vérifier si des colis sont disponibles
        if (takingCarePackages.length > 0) {
          // Sélectionner un colis aléatoire parmi les colis pris en charge
          const randomPackage = takingCarePackages[Math.floor(Math.random() * takingCarePackages.length)];
          return randomPackage.code;
        } else {
          // Aucun colis disponible pour le dépôt - cette condition est gérée dans handleSimulatedScan
          return '';
        }
      } else {
        // Simuler un scan de contenant pour prise en charge
        // Utiliser un préfixe spécifique pour les tests afin de pouvoir les identifier facilement
        const testId = Date.now(); // Utiliser le timestamp actuel pour créer un ID unique
        return `TEST_CONTENANT_${testId}`;
      }
    }
  };

  // Modification pour les tests : fonction mock qui simule verifySiteCode
  const mockVerifySiteCode = async (siteCode) => {
    // Sites de test qui seront automatiquement validés
    const sitesDemoValides = {
      'SITE123': { nom: 'Site Test 1', adresse: '123 Rue Principale', ville: 'Paris', codePostal: '75001' },
      'SITE456': { nom: 'Site Test 2', adresse: '456 Avenue République', ville: 'Lyon', codePostal: '69001' },
      'SITE789': { nom: 'Site Test 3', adresse: '789 Boulevard des Tests', ville: 'Toulouse', codePostal: '31000' },
      '12345': { nom: 'Laboratoire Central', adresse: '12 Rue des Sciences', ville: 'Montpellier', codePostal: '34000' },
      'LAB001': { nom: 'Laboratoire Mobile', adresse: 'Zone Industrielle', ville: 'Bordeaux', codePostal: '33000' }
    };

    // Vérifier si le code scanné est dans notre liste de sites de test
    if (sitesDemoValides[siteCode]) {
      // Retourner une structure simulant la réponse de Firebase
      return {
        valid: true,
        site: {
          id: `mock_${siteCode}`,
          code: siteCode,
          nom: sitesDemoValides[siteCode].nom,
          adresse: sitesDemoValides[siteCode].adresse,
          ville: sitesDemoValides[siteCode].ville,
          codePostal: sitesDemoValides[siteCode].codePostal
        }
      };
    }

    // Si ce n'est pas un site de test, passer à la vérification normale dans Firebase
    return await firebaseService.verifySiteCode(siteCode);
  };

  const processScannedData = async (data) => {
    console.log('Code scanné:', data);
    try {
      // Cas 1: Nous n'avons pas encore scanné de site
      if (!siteScanned && scanMode === 'site') {
        console.log('[processScannedData] Mode: Scan de site. Données:', data);
        const siteVerification = await firebaseService.verifySiteCode(data);
        console.log('[processScannedData] Résultat de verifySiteCode:', JSON.stringify(siteVerification));

        if (siteVerification.site) {
          // Enregistrer les infos du site
          setSiteCode(data);
          setSiteDetails(siteVerification.site);
          // setSiteScanned(true); // Mis plus bas pour ne l'activer qu'après succès
          // setScanMode(''); // Mis plus bas
          // setShowOperationTypeSelection(true); // Mis plus bas

          // --- MODIFIÉ: Ne trouver que le premier site non visité avec ce nom ---
          let occurrenceIndex = null;
          if (tourneeProgressRef.current?.getSitesWithStatus) {
            const sitesList = tourneeProgressRef.current.getSitesWithStatus();
            console.log('[processScannedData] sitesList depuis tourneeProgressRef:', JSON.stringify(sitesList.map(s => ({ id: s.id, name: s.name, visited: s.visited, uniqueDisplayId: s.uniqueDisplayId }))));
            const siteNameToFind = siteVerification.site.nom || siteVerification.site.name;
            console.log('[processScannedData] Nom du site à trouver:', siteNameToFind);

            // Trouver le premier site non visité avec ce nom
            occurrenceIndex = sitesList.findIndex(s => !s.visited && (s.name === siteNameToFind || s.nom === siteNameToFind)); // Ajout de s.nom
            console.log(`[processScannedData] Occurrence index trouvée pour ${siteNameToFind}:`, occurrenceIndex);
            
            // Si aucun site non visité n'est trouvé, ne rien faire
            if (occurrenceIndex === -1) {
              Alert.alert(
                'Site déjà visité ou non trouvé', // Message mis à jour
                'Ce site a déjà été visité, ne fait pas partie de cette tournée, ou son nom ne correspond pas exactement.', // Message mis à jour
                [{ text: 'OK', onPress: () => {
                  // Réinitialiser l'état pour permettre un nouveau scan
                  setSiteScanned(false);
                  setSiteDetails(null);
                  setSiteCode('');
                  setShowOperationTypeSelection(false);
                }}]
              );
              return;
            }
          } else {
            console.warn('[processScannedData] tourneeProgressRef.current.getSitesWithStatus non disponible.');
            Alert.alert('Erreur', 'Impossible de récupérer la liste des sites de la tournée.');
            return;
          }

          // Marquage en session via l'index si trouvé, sinon par site.id
          const identifier = siteVerification.site.id || (siteVerification.site.code || data);
          console.log('[processScannedData] Identifier pour markSiteVisitedInSession:', identifier);
          console.log('[processScannedData] currentSessionId avant appel:', currentSessionId);
          console.log('[processScannedData] occurrenceIndex avant appel:', occurrenceIndex);

          if (!currentSessionId) {
            console.error('[processScannedData] ID de session manquant avant markSiteVisitedInSession');
            Alert.alert('Erreur Critique', 'ID de session manquant. Impossible de continuer.');
            return;
          }
          
          // Ne marquer qu'un seul site à la fois, en utilisant l'index spécifique
          if (occurrenceIndex !== -1 && occurrenceIndex !== null) { // Condition déjà présente, mais on log avant
            const markSuccess = await firebaseService.markSiteVisitedInSession(currentSessionId, identifier, occurrenceIndex);
            console.log('[processScannedData] Résultat de markSiteVisitedInSession:', markSuccess);
            
            if (markSuccess) {
              setSiteScanned(true); // Activer seulement si le marquage Firestore a réussi
              setScanMode(''); 
              setShowOperationTypeSelection(true);

              // Mise à jour du UI local - mettre à jour uniquement le site spécifique
              if (tourneeProgressRef.current?.markSiteAsVisitedLocally) {
                console.log('[processScannedData] Appel de markSiteAsVisitedLocally avec:', identifier, occurrenceIndex);
                await tourneeProgressRef.current.markSiteAsVisitedLocally(identifier, occurrenceIndex); // AJOUT DE AWAIT
                // Temporairement commenté pour tester si la coche se met à jour correctement sans rechargement immédiat
                // await updateTourneeProgress(); 
              } else if (tourneeProgressRef.current?.loadTourneeDetails) {
                console.log('[processScannedData] Appel de loadTourneeDetails(true) car markSiteAsVisitedLocally non dispo.');
                await tourneeProgressRef.current.loadTourneeDetails(true);
              }
            } else {
              Alert.alert('Erreur', 'Échec du marquage du site comme visité dans la session Firestore.');
              // Garder siteScanned à false, etc.
            }
            
            // Si updateTourneeProgress a été commenté, on peut appeler loadHistoricalData ici
            // si c'est nécessaire pour d'autres parties de l'UI non liées à TourneeProgress.
            // Pour l'instant, on isole le problème de la coche.
            // await loadHistoricalData(); 

          } else {
             console.warn('[processScannedData] occurrenceIndex invalide, markSiteVisitedInSession non appelé.');
             // Potentiellement une alerte ici si ce cas ne devrait pas arriver
          }
          return;
        } else { // siteVerification.site est null/undefined
          console.log('[processScannedData] Aucun site valide retourné par verifySiteCode pour le code:', data);
          Alert.alert('Site Inconnu', 'Le code scanné ne correspond à aucun site connu.');
           // Réinitialiser pour permettre un nouveau scan
          setSiteScanned(false);
          setSiteDetails(null);
          setSiteCode('');
          setShowOperationTypeSelection(false);
        }
      }
      
      // Cas 2: Site déjà scanné, nous scannons maintenant un contenant
      if (siteScanned && scanMode === 'contenant') {
        console.log('[processScannedData] Mode: Scan de contenant. Données:', data);
        handleContenantScan(data);
        // Rester en mode scan contenant pour permettre les scans multiples
        setScanMode('contenant');
      }
    } catch (error) {
      console.error('Erreur lors de la gestion du scan:', error);
      setErrorMessage('Erreur: ' + error.message); // Afficher l'erreur à l'utilisateur
      setScanMode(''); // Réinitialiser le mode scan
      // Optionnel: réinitialiser d'autres états si nécessaire
      setSiteScanned(false);
      setSiteDetails(null);
      setSiteCode('');
      setShowOperationTypeSelection(false);
    }
  };

  // Gérer la simulation d'un scan (pour le développement et les tests)
  const handleSimulatedScan = () => {
    // Vérifier si on est en mode sortie sans colis pris en charge
    if (scanMode === 'contenant' && operationType === 'sortie' && takingCarePackages.length === 0) {
      Alert.alert(
        "Aucun colis disponible",
        "Vous n'avez aucun colis en prise en charge à déposer.",
        [{ text: "OK" }]
      );
      return;
    }
    
    const fakeData = simulateScan();
    if (fakeData) {
      console.log(`Simulation de scan avec données: ${fakeData}`);
    processScannedData(fakeData);
    } else {
      console.error("Erreur lors de la simulation du scan: aucune donnée générée");
      Alert.alert(
        "Erreur",
        "Impossible de simuler un scan. Veuillez réessayer.",
        [{ text: "OK" }]
      );
    }
  };

  const handleManualScan = () => {
    if (manualCodeInput.trim() === '') {
      Alert.alert('Erreur', 'Veuillez entrer un code valide');
      return;
    }
    
    processScannedData(manualCodeInput.trim());
    setManualCodeInput('');
  };

  const activateSiteScan = () => {
    setScanMode('site');
    setErrorMessage('');
    setIsReadyForScan(true);
    
    // Montrer une alerte avec plusieurs options pour scanner
    Alert.alert(
      "Scanner un site",
      "Comment souhaitez-vous scanner le site ?",
      [
        {
          text: "Scanner manuellement",
          onPress: () => showManualSiteInput()
        },
        {
          text: "Simuler scan",
          onPress: handleSimulatedScan
        },
        {
          text: "Annuler",
          style: "cancel",
          onPress: () => setScanMode('')
        }
      ]
    );
  };

  // Fonction pour afficher une boîte de dialogue pour saisir manuellement le code du site
  const showManualSiteInput = () => {
    // Utiliser Alert.prompt sur iOS, mais sur Android, cette fonction n'existe pas
    // donc nous utilisons une méthode alternative
    if (Platform.OS === 'ios') {
      Alert.prompt(
        "Scanner site manuellement",
        "Entrez le code ou le nom du site",
        [
          { text: "Annuler", onPress: () => setScanMode(''), style: "cancel" },
          { 
            text: "Scanner", 
            onPress: (code) => {
              if (code && code.trim()) {
                processScannedData(code.trim());
              } else {
                setScanMode('');
                Alert.alert("Erreur", "Veuillez entrer un code de site valide");
              }
            }
          }
        ],
        "plain-text"
      );
    } else {
      // Sur Android, utiliser une solution simple avec TextInput
      Alert.alert(
        "Scanner site manuellement",
        "Entrez le code du site dans le champ de texte en haut de l'écran, puis appuyez sur Scanner",
        [
          { text: "OK" }
        ]
      );
      // Focus sur le champ de saisie manuelle
      // Note: ceci est une approche simplifiée, une solution plus robuste
      // utiliserait un modal personnalisé avec TextInput
      setManualCodeInput('');
      // On garde le mode scan actif pour que le bouton scanner manuel fonctionne
    }
  };

  // Afficher la page de sélection du type d'opération
  const showOperationSelection = () => {
    setShowOperationTypeSelection(true);
  };

  // Commencer le scan de contenant avec un type d'opération spécifique
  const startContenantScan = (type) => {
    setOperationType(type);
    setShowOperationTypeSelection(false);
    setScanMode('contenant');
    setErrorMessage('');
    setIsReadyForScan(true);
    
    // Message différent selon le type d'opération
    const message = type === 'entree' 
      ? "Veuillez scanner le code du contenant à prendre en charge" 
      : "Veuillez scanner le code du contenant à déposer";
    
    Alert.alert(
      type === 'entree' ? "Prise en charge" : "Dépôt",
      message,
      [{ text: "Annuler", onPress: () => setScanMode('') }]
    );
  };

  const handleContenantScan = async (code) => {
    if (!siteScanned) {
      Alert.alert('Erreur', 'Veuillez d\'abord scanner un site');
      return;
    }

    try {
      // Mode dépôt (sortie) - vérifier que le colis est dans la liste des colis pris en charge
      if (operationType === 'sortie') {
        const isInTakingCare = takingCarePackages.some(pkg => pkg.code === code);
        if (!isInTakingCare) {
          Alert.alert(
            "Colis non reconnu",
            "Ce colis ne fait pas partie des colis que vous avez en prise en charge.",
            [{ text: "OK" }]
          );
          return;
        }
        
        // Retirer le colis de la liste des colis pris en charge
        setTakingCarePackages(takingCarePackages.filter(pkg => pkg.code !== code));
      }

      // Obtenir la date actuelle au format approprié
      const currentDate = new Date();
      const currentDateISO = currentDate.toISOString();

      // Ajouter le contenant à la liste
      const newContenant = {
        id: Date.now().toString(),
        code: code,
        idColis: code,
        timeStamp: currentDate.toLocaleTimeString(),
        date: currentDate.toLocaleDateString(),
        scanDate: currentDateISO,
        site: siteCode,
        type: operationType, // Ajout du type d'opération (entrée/sortie)
      };
      
      setScannedContenants([newContenant, ...scannedContenants]);
    } catch (error) {
      console.error('Erreur lors de la gestion du scan:', error);
      setScanMode('');
    }
  };

  const renderScannedItem = ({ item }) => (
    <View style={[styles.contenantItem, item.type === 'sortie' ? styles.contenantItemSortie : styles.contenantItemEntree]}>
      <View style={styles.contenantInfo}>
        <Text style={styles.contenantCode}>{item.code}</Text>
        <View style={styles.contenantTypeRow}>
          <View style={item.type === 'sortie' ? styles.typeTagSortie : styles.typeTagEntree}>
            <Text style={styles.typeTagText}>{item.type === 'sortie' ? 'Dépôt' : 'Prise en charge'}</Text>
          </View>
          <Text style={styles.contenantTime}>{item.timeStamp}</Text>
        </View>
      </View>
      <TouchableOpacity
        style={styles.deleteContenantButton}
        onPress={() => removeScannedContenant(item.id)}
      >
        <Ionicons name="trash-outline" size={20} color="#e74c3c" />
      </TouchableOpacity>
    </View>
  );

  const removeScannedContenant = (id) => {
    setScannedContenants(scannedContenants.filter(contenant => contenant.id !== id));
  };

  const handleTransmit = async () => {
    if (scannedContenants.length === 0) {
      Alert.alert('Attention', 'Aucun contenant scanné à transmettre.');
      return;
    }

    setLoading(true);

    try {
      // Vérifier et afficher les données de la session pour le débogage
      console.log('Données de session:', JSON.stringify(sessionData, null, 2));
      console.log('Données de route:', JSON.stringify(route.params, null, 2));
      
      // Récupérer les données de la tournée et du véhicule avec plus de vérifications
      const tourneeName = sessionData.tournee?.nom || route.params?.tournee?.nom || '';
      const tourneeId = sessionData.tournee?.id || route.params?.tournee?.id || '';
      const vehiculeName = sessionData.vehicule?.immatriculation || route.params?.vehicule?.immatriculation || '';
      const vehiculeId = sessionData.vehicule?.id || route.params?.vehicule?.id || '';
      
      // Utiliser les détails du site validé s'ils sont disponibles
      let siteName, siteId, siteAdresse, siteCodePostal, siteVille;
      
      if (siteDetails) {
        // Utiliser les bonnes clés du siteDetails (nommage uniforme)
        siteName = siteDetails.name || siteCode;
        siteId = siteDetails.id || '';
        siteAdresse = siteDetails.address || '';
        siteCodePostal = siteDetails.codePostal || '';
        siteVille = siteDetails.city || '';
      } else {
        // Sinon on utilise ce qu'on a par défaut
        siteName = sessionData.tournee?.siteDepart || route.params?.tournee?.siteDepart || siteCode || 'Non spécifié';
        siteId = '';
      }
      
      console.log('Données récupérées pour les scans:', {
        tourneeName,
        tourneeId,
        vehiculeName,
        vehiculeId,
        siteName,
        siteId,
        siteCode
      });

      // Récupérer l'ID de session actuel
      const currentSessionId = await AsyncStorage.getItem('currentSessionId') || `session_${Date.now()}`;
      
      // Préparer les scans avec tous les champs nécessaires
      const scansToSubmit = scannedContenants.map(scan => {
        const scanDate = scan.scanDate || new Date().toISOString();
        
        // Le code du contenant devient l'ID du colis
        const scanItem = {
          code: scan.code,
          idColis: scan.code || scan.idColis,
          scanDate: scanDate,
          tournee: tourneeName,
          tourneeId: tourneeId,
          vehicule: vehiculeName,
          vehiculeId: vehiculeId,
          immatriculation: vehiculeName,
          site: siteName,
          siteId: siteId,
          siteCode: siteCode,
          siteDepart: siteName,
          siteDépart: siteName,
          sessionId: currentSessionId, // Ajouter l'ID de session pour le filtrage ultérieur
          operationType: scan.type || 'entree', // Ajout du type d'opération
          status: scan.type === 'sortie' ? 'livré' : 'en-cours', // Status basé sur le type d'opération
          type: scan.type || 'entree' // Assurer que le type est inclus explicitement
        };
        
        // Ajouter siteFin uniquement pour les colis livrés
        if (scan.type === 'sortie') {
          // Pour les opérations de sortie (dépôt), ajouter des informations spécifiques
          const currentDate = new Date();
          
          // Utiliser le nom du site actuel comme site d'arrivée
          scanItem.siteFin = siteName;
          // Ajouter date et heure d'arrivée au format correct
          scanItem.dateArrivee = currentDate.toLocaleDateString();
          scanItem.heureArrivee = currentDate.toLocaleTimeString();
          // Ajouter ces champs supplémentaires pour assurer la compatibilité
          scanItem.dateHeureFin = currentDate.toISOString();
          scanItem.statut = 'Livré';
          scanItem.status = 'livré'; // Assurez-vous que les deux formats sont présents
          scanItem.coursierLivraison = sessionData.coursierCharg || route.params?.coursierCharg || '';
        }
        
        // Ajouter les détails du site s'ils sont disponibles
        if (siteDetails) {
          scanItem.siteDetails = {
            adresse: siteAdresse,
            codePostal: siteCodePostal,
            ville: siteVille
          };
        }

        // Ajouter la localisation si disponible
        if (sessionData.location) {
          scanItem.location = {
            latitude: sessionData.location.coords.latitude,
            longitude: sessionData.location.coords.longitude,
            accuracy: sessionData.location.coords.accuracy
          };
        }

        return scanItem;
      });
      
      // Afficher les données qui seront transmises
      console.log('Transmission des scans:', JSON.stringify(scansToSubmit, null, 2)); // Décommenté pour débogage
      
      // Envoyer les scans à Firebase
      const result = await firebaseService.addScans(scansToSubmit);
      console.log('Résultat de la transmission:', result);
      
      // Si la transmission réussit, mettre à jour l'historique local
      if (result.success) {
        // --- Logique de consolidation --- 
        const updatedScansMap = new Map();
        historicalScans.forEach(scan => {
          // Assurer qu'on a un code pour la clé de la map
          if (scan.code) {
            updatedScansMap.set(scan.code, scan);
          }
        });
        scansToSubmit.forEach(scan => {
          if (scan.code) {
            const originalScan = scannedContenants.find(s => s.code === scan.code);
            const scanForHistory = {
              ...scan,
              timeStamp: originalScan?.timeStamp || dateUtils.formatTime(scan.scanDate),
            };
            updatedScansMap.set(scan.code, scanForHistory);
          }
        });
        const newHistory = Array.from(updatedScansMap.values());
        newHistory.sort((a, b) => {
          const dateA = a.scanDate ? new Date(a.scanDate).getTime() : 0;
          const dateB = b.scanDate ? new Date(b.scanDate).getTime() : 0;
          if (isNaN(dateA) && isNaN(dateB)) return 0;
          if (isNaN(dateA)) return 1;
          if (isNaN(dateB)) return -1;
          return dateB - dateA;
        });
        // --- Fin de la logique de consolidation ---

        // Sauvegarder l'historique consolidé dans AsyncStorage
        await AsyncStorage.setItem('scanHistory', JSON.stringify(newHistory));
        
        // Mise à jour de l'état React DIFFÉRÉE après les interactions
        InteractionManager.runAfterInteractions(() => {
          setHistoricalScans(newHistory);
        });
        
        // Mettre à jour la liste des paquets pris en charge
        if (operationType === 'entree') {
          setTakingCarePackages([...scansToSubmit, ...takingCarePackages]);
        } else if (operationType === 'sortie') {
          const codesDeposited = scansToSubmit.map(scan => scan.code);
          setTakingCarePackages(takingCarePackages.filter(pkg => pkg.code && !codesDeposited.includes(pkg.code)));
        }
        
        // Réinitialiser complètement l'état pour revenir à l'écran de scan de site
        resetScan(); // Cette fonction réinitialise les états de base

        // S'assurer que tous les états sont correctement réinitialisés pour revenir à l'écran initial
        setShowOperationTypeSelection(false);
        setOperationType('entree'); // Réinitialiser à l'entrée de colis par défaut
        
        // Important: Désactiver le chargement AVANT l'alerte
        setLoading(false);
        
        // Afficher l'alerte de succès
        Alert.alert(
          'Succès',
          `${scansToSubmit.length} scan(s) transmis avec succès`,
          [{ text: 'OK' }]
        );
      } else {
        setLoading(false);
        throw new Error(result.error || 'Échec de la transmission');
      }
    } catch (error) {
      console.error('Erreur lors de la transmission:', error);
      setLoading(false);
      Alert.alert('Erreur', `Échec de la transmission: ${error.message}`);
    }
  };

  const resetScan = () => {
    setScanMode('');
    setSiteScanned(false);
    setSiteCode('');
    setScannedContenants([]);
    setManualCodeInput('');
    setSiteDetails(null);
  };

  const navigateToHistory = () => {
    setShowHistoryModal(true);
  };

  // Fonction pour obtenir les détails de la session actuelle
  const getSessionDetails = async () => {
    try {
      const currentSession = await firebaseService.getCurrentSession();
      if (currentSession) {
        setSessionId(currentSession.id);
        setTournee(currentSession.tournee);
        setVehicule(currentSession.vehicule);
        setPole(currentSession.pole);
      }
    } catch (error) {
      console.error("Erreur lors de la récupération de la session:", error);
    }
  };

  // Fonction pour effacer l'historique des scans
  const clearHistoricalScans = async () => {
    try {
      Alert.alert(
        'Effacer l\'historique',
        'Voulez-vous vraiment effacer tout l\'historique des scans?',
        [
          {
            text: 'Annuler',
            style: 'cancel'
          },
          {
            text: 'Effacer',
            onPress: async () => {
              await AsyncStorage.removeItem('scanHistory');
              setHistoricalScans([]);
              Alert.alert('Succès', 'Historique effacé avec succès');
            },
            style: 'destructive'
          }
        ]
      );
    } catch (error) {
      console.error('Erreur lors de l\'effacement de l\'historique:', error);
      Alert.alert('Erreur', 'Impossible d\'effacer l\'historique');
    }
  };

  // Ajout d'une fonction pour effacer explicitement tous les scans de la session actuelle
  const clearCurrentSessionScans = async () => {
    try {
      const currentSessionId = await AsyncStorage.getItem('currentSessionId');
      if (!currentSessionId) {
        Alert.alert('Erreur', 'Impossible de déterminer la session actuelle');
        return;
      }
      
      Alert.alert(
        'Réinitialiser l\'historique',
        'Cette action va supprimer tous les scans associés à votre session actuelle. Continuer?',
        [
          {
            text: 'Annuler',
            style: 'cancel'
          },
          {
            text: 'Supprimer',
            onPress: async () => {
              try {
                // Supprimer les scans associés à la session actuelle
                setLoading(true);
                console.log(`Suppression des scans de la session ${currentSessionId}...`);
                
                // Fonction côté service qui devrait être implémentée
                // pour supprimer tous les scans de la session
                const result = await firebaseService.clearSessionScans(currentSessionId);
                
                // Supprimer l'historique local également
                await AsyncStorage.removeItem('scanHistory');
                setHistoricalScans([]);
                
                setLoading(false);
                Alert.alert('Succès', 'Historique réinitialisé avec succès');
              } catch (error) {
                setLoading(false);
                console.error('Erreur lors de la suppression des scans:', error);
                Alert.alert('Erreur', `Échec de la suppression: ${error.message}`);
              }
            },
            style: 'destructive'
          }
        ]
      );
    } catch (error) {
      console.error('Erreur:', error);
      Alert.alert('Erreur', 'Une erreur est survenue');
    }
  };

  // Handler de déconnexion avec effacement complet de l'historique
  const handleLogout = async () => {
    try {
      Alert.alert(
        'Déconnexion',
        'Voulez-vous vous déconnecter? L\'historique des scans sera effacé.',
        [
          {
            text: 'Annuler',
            style: 'cancel'
          },
          {
            text: 'Déconnecter',
            onPress: async () => {
              try {
                setLoading(true);
                console.log('Déconnexion en cours...');

                // Appeler la méthode de déconnexion de Firebase
                await firebaseService.logout();
                console.log('Déconnexion Firebase réussie');
                
                // Effacer toutes les données de session
                await AsyncStorage.removeItem('userSessionActive');
                // On conserve current_session_id pour que la tournée visitée reste en mémoire
                await AsyncStorage.removeItem('scanHistory');
                await AsyncStorage.removeItem('user_selas_id');
                
                // Réinitialiser les états
                setHistoricalScans([]);
                setScannedContenants([]);
                setSiteScanned(false);
                setSiteCode('');
                
                setLoading(false);
                
                // Rediriger vers l'écran de connexion
                navigation.reset({
                  index: 0,
                  routes: [{ name: 'Login' }]
                });
              } catch (error) {
                setLoading(false);
                console.error('Erreur lors du processus de déconnexion:', error);
                Alert.alert('Erreur', 'Impossible de se déconnecter. Veuillez réessayer.');
              }
            }
          }
        ]
      );
    } catch (error) {
      console.error('Erreur lors de la déconnexion:', error);
    }
  };

  // Utiliser directement les fonctions de formatage de dateUtils
  // au lieu de redéfinir des fonctions similaires

  // Effet pour écouter les événements de scan Zebra
  useEffect(() => {
    if (isReadyForScan) {
      // Afficher un message pour indiquer que l'application est prête pour le scan
      console.log('Prêt à recevoir des scans du scanner Zebra');
      
      // Configuration pour recevoir les scans du matériel Zebra
      const handleZebraScan = (event) => {
        // Le scanner Zebra envoie généralement les données comme des entrées clavier
        // Nous devons vérifier que nous sommes en mode scan et traiter les données
        if (event && event.nativeEvent && event.nativeEvent.key === 'Enter' && scanMode) {
          // Récupérer le texte scanné (par exemple depuis un champ de texte caché ou via une API Zebra)
          // Pour les besoins de cet exemple, nous utiliserons la valeur de manualCodeInput
          if (manualCodeInput.trim()) {
            processScannedData(manualCodeInput.trim());
            setManualCodeInput(''); // Réinitialiser après le traitement
          }
        }
      };
      
      // Ajoutez ici l'initialisation spécifique au scanner Zebra si nécessaire
      // Exemple : ZebraScanner.initialize() si une API Zebra est disponible
      
      // Pour cet exemple, on simule en utilisant l'écouteur de clavier (pour Enter)
      Keyboard.addListener('keyDown', handleZebraScan);
      
      return () => {
        // Nettoyage lors du démontage
        Keyboard.removeListener('keyDown', handleZebraScan);
        // Désinitialiser le scanner Zebra si nécessaire
        // Exemple : ZebraScanner.deinitialize()
      };
    }
  }, [isReadyForScan, scanMode, manualCodeInput]);


  const loadHistoricalScans = async () => {
    try {
      const jsonValue = await AsyncStorage.getItem('scanHistory');
      if (jsonValue !== null) {
        const history = JSON.parse(jsonValue);
        
        // Récupérer l'ID de la tournée actuelle
        const currentSession = await firebaseService.getCurrentSession();
        const currentTourneeId = currentSession?.tournee?.id || sessionData?.tournee?.id || '';
        
        // Filtrer l'historique local
        const today = new Date();
        today.setHours(0, 0, 0, 0); // Début de la journée
        
        const filteredHistory = history.filter(item => {
          // Convertir la date de l'item en objet Date
          let itemDate;
          try {
            itemDate = new Date(item.date);
            if (isNaN(itemDate.getTime())) {
              // Si la date n'est pas valide, essayer un autre format
              const parts = item.date.split('/');
              if (parts.length === 3) {
                itemDate = new Date(parts[2], parts[1] - 1, parts[0]);
              }
            }
          } catch (e) {
            // En cas d'erreur, considérer cet item comme non valide pour le filtre
            return false;
          }

          // S'assurer que nous avons une date valide
          if (!itemDate || isNaN(itemDate.getTime())) return false;
          
          itemDate.setHours(0, 0, 0, 0); // Normaliser à minuit
          
          // Vérifier la tournée
          const isSameTournee = !currentTourneeId || item.tourneeId === currentTourneeId;
          
          // Vérifier le statut (inclut les visites sans colis)
          const hasValidStatus = item.status === 'en-cours' || item.status === 'livré';
          
          // L'item doit être du jour courant ET de la même tournée ET avoir un statut valide
          return itemDate.getTime() === today.getTime() && isSameTournee && hasValidStatus;
        });
        
        console.log(`Historique local filtré: ${filteredHistory.length} scans (jour + tournée + statut)`);
        
        // Consolider l'historique filtré avant de mettre à jour l'état
        const consolidatedHistory = consolidateAndSortScans([], filteredHistory);

        // Enrichir avec le nom complet du site depuis Firestore
        const enrichedHistory = await Promise.all(
          consolidatedHistory.map(async (scan) => {
            // Tenter de récupérer les détails du site en utilisant siteId ou code
            try {
              const siteIdentifier = scan.siteId || scan.code; // Utiliser ID ou code
              // Vérifier si l'identifiant est probablement un site avant d'appeler getSiteById
              if (siteIdentifier && 
                  !siteIdentifier.startsWith('TEST_CONTENANT_') && 
                  !siteIdentifier.match(/^[0-9]{13,}$/)) { 
                const siteInfo = await firebaseService.getSiteById(siteIdentifier);
                if (siteInfo) {
                  // Enrichir le scan avec les détails complets
                  return { 
                    ...scan, 
                    siteName: siteInfo.nom || siteInfo.name, // Ajouter le nom pour affichage facile
                    siteDetails: { ...siteInfo } 
                  };
                }
              }
            } catch (e) {
              console.warn(`[loadHistoricalScans] Erreur récupération détails site pour ${scan.code || scan.id}:`, e);
            }
            // Si non trouvé ou erreur, retourner le scan original
            return scan;
          })
        );
        
        // Mettre à jour l'état avec l'historique enrichi
        setHistoricalScans(enrichedHistory);
        setSessionHistoryLoaded(true);
      }
    } catch (error) {
      console.error('Erreur lors du chargement de l\'historique:', error);
    }
  };

  const loadFirestoreScans = async () => {
    try {
      // On ne charge les scans Firestore que si la session est active
      const userSessionActive = await AsyncStorage.getItem('userSessionActive');
      if (userSessionActive !== 'true') {
        // Si aucune session active, on ne charge pas l'historique Firestore
        return;
      }

      // Récupérer l'ID de session actuel
      const currentSessionId = await AsyncStorage.getItem('currentSessionId');
      console.log('Chargement des scans pour la session:', currentSessionId);

      // Récupérer l'ID de la tournée actuelle
      const currentSession = await firebaseService.getCurrentSession();
      const currentTourneeId = currentSession?.tournee?.id || sessionData?.tournee?.id || '';
      console.log('Tournée actuelle:', currentTourneeId);

      setLoading(true); // Afficher l'indicateur de chargement

      // Récupérer tous les scans de l'utilisateur (sans limite)
      const scans = await firebaseService.getScans();
      
      if (scans && scans.length > 0) {
        // Ne garder que les scans du jour (J0)
        const today = new Date();
        today.setHours(0, 0, 0, 0); // Début de la journée
        
        const filteredScans = scans.filter(scan => {
          // Convertir la date du scan en objet Date
          const scanDate = dateUtils.convertTimestampToDate(scan.scanDate || scan.createdAt);
          if (!scanDate) return false;
          
          // Récupérer juste la date (sans l'heure)
          const scanDateOnly = new Date(scanDate);
          scanDateOnly.setHours(0, 0, 0, 0);
          
          // Vérifier la tournée (si une tournée actuelle est définie)
          const isSameTournee = !currentTourneeId || scan.tourneeId === currentTourneeId;
          
          // Vérifier le statut (inclut "pas_de_colis")
          const hasValidStatus = scan.status === 'en-cours' || scan.status === 'livré';
          
          // Le scan doit être du jour courant ET de la même tournée ET avoir un statut valide
          return scanDateOnly.getTime() === today.getTime() && isSameTournee && hasValidStatus;
        });
        
        // Convertir les scans Firestore filtrés en format compatible avec l'historique local
        const formattedScans = filteredScans.map(scan => {
          // Déduire le statut si manquant, basé sur le type d'opération
          let status = scan.status;
          if (!status) {
            status = scan.operationType === 'sortie' ? 'livré' : 'en-cours';
          }
          
          return {
            id: scan.id || Date.now().toString(),
            code: scan.code,
            timeStamp: dateUtils.formatTime(scan.scanDate || scan.createdAt),
            date: dateUtils.formatDate(scan.scanDate || scan.createdAt),
            site: scan.site,
            fromFirestore: true,
            sessionId: scan.sessionId,
            // Utiliser le statut (corrigé si nécessaire)
            status: status, 
            // S'assurer que le type est aussi présent
            type: scan.operationType || (status === 'livré' ? 'sortie' : 'entree'), 
            tournee: scan.tournee || '',
            tourneeId: scan.tourneeId || '',
            scanDate: scan.scanDate ? dateUtils.convertTimestampToDate(scan.scanDate).toISOString() : (scan.createdAt ? dateUtils.convertTimestampToDate(scan.createdAt).toISOString() : new Date().toISOString()) // Garder une date ISO pour le tri
          };
        });
        
        // Consolider et trier
        const consolidatedScans = consolidateAndSortScans(historicalScans, formattedScans);
        // Enrichir avec le nom complet du site depuis Firestore
        const enrichedScans = await Promise.all(
          consolidatedScans.map(async (scan) => {
            try {
              // Tenter de récupérer les détails du site
              try {
                // Utiliser l'ID du site si disponible, sinon le code barre
                const siteIdentifier = scan.siteId || scan.code; // Assumer que siteId existe
                if (siteIdentifier && 
                    !siteIdentifier.startsWith('TEST_CONTENANT_') && 
                    !siteIdentifier.match(/^[0-9]{13,}$/)) {
                  // Utiliser une variable locale au lieu de réassigner l'état siteDetails
                  const siteInfo = await firebaseService.getSiteById(siteIdentifier); 
                  if (siteInfo) {
                    // Modifier l'objet scan directement
                    scan.siteName = siteInfo.nom || siteInfo.name; // Utiliser le nom du site s'il est trouvé
                    scan.siteDetails = siteInfo; // Ajouter les détails au scan
                  } else {
                     // Si siteInfo est null, indiquer le nom comme code
                     scan.siteName = scan.code; 
                  }
                } else {
                   scan.siteName = scan.code; // Fallback si aucun identifiant
                }
              } catch (siteError) {
                console.warn(`[loadFirestoreScans] Impossible de récupérer les détails du site pour l'identifiant ${scan.siteId || scan.code}:`, siteError);
                scan.siteName = scan.code; // Afficher le code si erreur
              }
              
              // Ne récupérer les informations sur le site que s'il ne s'agit pas d'un conteneur
              if (scan.site && 
                  !scan.site.startsWith('TEST_CONTENANT_') && 
                  !scan.site.match(/^[0-9]{13,}$/)) {
                const siteInfo = await firebaseService.getSiteById(scan.site);
                if (siteInfo) return { ...scan, siteDetails: { ...siteInfo } };
              }
            } catch (e) {
              console.error('Erreur récupération nom site Firestore:', e);
            }
            return scan;
          })
        );
        
        // Mettre à jour l'état avec l'historique enrichi
        setHistoricalScans(enrichedScans);
        setSessionHistoryLoaded(true);
        
        // Sauvegarder également dans AsyncStorage pour la persistance locale temporaire
        await AsyncStorage.setItem('scanHistory', JSON.stringify(enrichedScans));
      }
      
      setLoading(false); // Masquer l'indicateur de chargement
    } catch (error) {
      console.error('Erreur lors du chargement des scans depuis Firestore:', error);
      setLoading(false); // Masquer l'indicateur de chargement en cas d'erreur
    }
  };

  // --- AJOUTER CETTE FONCTION D'AIDE --- 
  // Fonction pour consolider et trier les scans
  const consolidateAndSortScans = (existingScans, newScans) => {
    const map = new Map();

    // Ajouter les scans existants à la map
    existingScans.forEach(scan => {
      if (scan.code) map.set(scan.code, scan);
    });

    // Mettre à jour ou ajouter les nouveaux scans
    newScans.forEach(scan => {
      if (scan.code) map.set(scan.code, scan);
    });

    // Convertir la map en tableau
    const consolidated = Array.from(map.values());

    // Trier
    consolidated.sort((a, b) => {
      const dateA = a.scanDate ? new Date(a.scanDate).getTime() : 0;
      const dateB = b.scanDate ? new Date(b.scanDate).getTime() : 0;
      if (isNaN(dateA) && isNaN(dateB)) return 0;
      if (isNaN(dateA)) return 1;
      if (isNaN(dateB)) return -1;
      return dateB - dateA;
    });

    return consolidated;
  };
  // --- FIN DE L'AJOUT ---

  const loadTakingCarePackages = async () => {
    try {
      const scansEnCours = await firebaseService.getScansEnCours();
      // Filtrer pour exclure les scans "pas_de_colis"
      const filteredScans = scansEnCours.filter(scan => 
        scan.status !== 'pas_de_colis' &&
        !(scan.code && scan.code.startsWith('SITE_'))
      );
      console.log(`✅ ${filteredScans.length} paquet(s) pris en charge récupéré(s) (sans les "pas_de_colis")`);
      setTakingCarePackages(filteredScans);
    } catch (error) {
      console.error('❌ Erreur lors du chargement des paquets pris en charge:', error);
    }
  };

  // 🔹 Simulation d'un scan avec des sites valides
  const simulateScan = () => {
    if (scanMode === 'site') {
      // Sites de test qui seront reconnus comme valides
      const sitesDemoValides = [
        'SITE123',
        'SITE456',
        'SITE789',
        'LAB001',
        '12345'
      ];
      
      // Sélectionner un site aléatoire parmi les sites valides pour la démo
      return sitesDemoValides[Math.floor(Math.random() * sitesDemoValides.length)];
    } else {
      // Si on est en mode sortie (dépôt), on doit scanner un colis déjà pris en charge
      if (operationType === 'sortie') {
        // Vérifier si des colis sont disponibles
        if (takingCarePackages.length > 0) {
          // Sélectionner un colis aléatoire parmi les colis pris en charge
          const randomPackage = takingCarePackages[Math.floor(Math.random() * takingCarePackages.length)];
          return randomPackage.code;
        } else {
          // Aucun colis disponible pour le dépôt - cette condition est gérée dans handleSimulatedScan
          return '';
        }
      } else {
        // Simuler un scan de contenant pour prise en charge
        // Utiliser un préfixe spécifique pour les tests afin de pouvoir les identifier facilement
        const testId = Date.now(); // Utiliser le timestamp actuel pour créer un ID unique
        return `TEST_CONTENANT_${testId}`;
      }
    }
  };

  // Modification pour les tests : fonction mock qui simule verifySiteCode
  const mockVerifySiteCode = async (siteCode) => {
    // Sites de test qui seront automatiquement validés
    const sitesDemoValides = {
      'SITE123': { nom: 'Site Test 1', adresse: '123 Rue Principale', ville: 'Paris', codePostal: '75001' },
      'SITE456': { nom: 'Site Test 2', adresse: '456 Avenue République', ville: 'Lyon', codePostal: '69001' },
      'SITE789': { nom: 'Site Test 3', adresse: '789 Boulevard des Tests', ville: 'Toulouse', codePostal: '31000' },
      '12345': { nom: 'Laboratoire Central', adresse: '12 Rue des Sciences', ville: 'Montpellier', codePostal: '34000' },
      'LAB001': { nom: 'Laboratoire Mobile', adresse: 'Zone Industrielle', ville: 'Bordeaux', codePostal: '33000' }
    };

    // Vérifier si le code scanné est dans notre liste de sites de test
    if (sitesDemoValides[siteCode]) {
      // Retourner une structure simulant la réponse de Firebase
      return {
        valid: true,
        site: {
          id: `mock_${siteCode}`,
          code: siteCode,
          nom: sitesDemoValides[siteCode].nom,
          adresse: sitesDemoValides[siteCode].adresse,
          ville: sitesDemoValides[siteCode].ville,
          codePostal: sitesDemoValides[siteCode].codePostal
        }
      };
    }

    // Si ce n'est pas un site de test, passer à la vérification normale dans Firebase
    return await firebaseService.verifySiteCode(siteCode);
  };

  const processScannedData = async (data) => {
    console.log('Code scanné:', data);
    try {
      // Cas 1: Nous n'avons pas encore scanné de site
      if (!siteScanned && scanMode === 'site') {
        console.log('[processScannedData] Mode: Scan de site. Données:', data);
        const siteVerification = await firebaseService.verifySiteCode(data);
        console.log('[processScannedData] Résultat de verifySiteCode:', JSON.stringify(siteVerification));

        if (siteVerification.site) {
          // Enregistrer les infos du site
          setSiteCode(data);
          setSiteDetails(siteVerification.site);
          // setSiteScanned(true); // Mis plus bas pour ne l'activer qu'après succès
          // setScanMode(''); // Mis plus bas
          // setShowOperationTypeSelection(true); // Mis plus bas

          // --- MODIFIÉ: Ne trouver que le premier site non visité avec ce nom ---
          let occurrenceIndex = null;
          if (tourneeProgressRef.current?.getSitesWithStatus) {
            const sitesList = tourneeProgressRef.current.getSitesWithStatus();
            console.log('[processScannedData] sitesList depuis tourneeProgressRef:', JSON.stringify(sitesList.map(s => ({ id: s.id, name: s.name, visited: s.visited, uniqueDisplayId: s.uniqueDisplayId }))));
            const siteNameToFind = siteVerification.site.nom || siteVerification.site.name;
            console.log('[processScannedData] Nom du site à trouver:', siteNameToFind);

            // Trouver le premier site non visité avec ce nom
            occurrenceIndex = sitesList.findIndex(s => !s.visited && (s.name === siteNameToFind || s.nom === siteNameToFind)); // Ajout de s.nom
            console.log(`[processScannedData] Occurrence index trouvée pour ${siteNameToFind}:`, occurrenceIndex);
            
            // Si aucun site non visité n'est trouvé, ne rien faire
            if (occurrenceIndex === -1) {
              Alert.alert(
                'Site déjà visité ou non trouvé', // Message mis à jour
                'Ce site a déjà été visité, ne fait pas partie de cette tournée, ou son nom ne correspond pas exactement.', // Message mis à jour
                [{ text: 'OK', onPress: () => {
                  // Réinitialiser l'état pour permettre un nouveau scan
                  setSiteScanned(false);
                  setSiteDetails(null);
                  setSiteCode('');
                  setShowOperationTypeSelection(false);
                }}]
              );
              return;
            }
          } else {
            console.warn('[processScannedData] tourneeProgressRef.current.getSitesWithStatus non disponible.');
            Alert.alert('Erreur', 'Impossible de récupérer la liste des sites de la tournée.');
            return;
          }

          // Marquage en session via l'index si trouvé, sinon par site.id
          const identifier = siteVerification.site.id || (siteVerification.site.code || data);
          console.log('[processScannedData] Identifier pour markSiteVisitedInSession:', identifier);
          console.log('[processScannedData] currentSessionId avant appel:', currentSessionId);
          console.log('[processScannedData] occurrenceIndex avant appel:', occurrenceIndex);

          if (!currentSessionId) {
            console.error('[processScannedData] ID de session manquant avant markSiteVisitedInSession');
            Alert.alert('Erreur Critique', 'ID de session manquant. Impossible de continuer.');
            return;
          }
          
          // Ne marquer qu'un seul site à la fois, en utilisant l'index spécifique
          if (occurrenceIndex !== -1 && occurrenceIndex !== null) { // Condition déjà présente, mais on log avant
            const markSuccess = await firebaseService.markSiteVisitedInSession(currentSessionId, identifier, occurrenceIndex);
            console.log('[processScannedData] Résultat de markSiteVisitedInSession:', markSuccess);
            
            if (markSuccess) {
              setSiteScanned(true); // Activer seulement si le marquage Firestore a réussi
              setScanMode(''); 
              setShowOperationTypeSelection(true);

              // Mise à jour du UI local - mettre à jour uniquement le site spécifique
              if (tourneeProgressRef.current?.markSiteAsVisitedLocally) {
                console.log('[processScannedData] Appel de markSiteAsVisitedLocally avec:', identifier, occurrenceIndex);
                await tourneeProgressRef.current.markSiteAsVisitedLocally(identifier, occurrenceIndex); // AJOUT DE AWAIT
                // Temporairement commenté pour tester si la coche se met à jour correctement sans rechargement immédiat
                // await updateTourneeProgress(); 
              } else if (tourneeProgressRef.current?.loadTourneeDetails) {
                console.log('[processScannedData] Appel de loadTourneeDetails(true) car markSiteAsVisitedLocally non dispo.');
                await tourneeProgressRef.current.loadTourneeDetails(true);
              }
            } else {
              Alert.alert('Erreur', 'Échec du marquage du site comme visité dans la session Firestore.');
              // Garder siteScanned à false, etc.
            }
            
            // Si updateTourneeProgress a été commenté, on peut appeler loadHistoricalData ici
            // si c'est nécessaire pour d'autres parties de l'UI non liées à TourneeProgress.
            // Pour l'instant, on isole le problème de la coche.
            // await loadHistoricalData(); 

          } else {
             console.warn('[processScannedData] occurrenceIndex invalide, markSiteVisitedInSession non appelé.');
             // Potentiellement une alerte ici si ce cas ne devrait pas arriver
          }
          return;
        } else { // siteVerification.site est null/undefined
          console.log('[processScannedData] Aucun site valide retourné par verifySiteCode pour le code:', data);
          Alert.alert('Site Inconnu', 'Le code scanné ne correspond à aucun site connu.');
           // Réinitialiser pour permettre un nouveau scan
          setSiteScanned(false);
          setSiteDetails(null);
          setSiteCode('');
          setShowOperationTypeSelection(false);
        }
      }
      
      // Cas 2: Site déjà scanné, nous scannons maintenant un contenant
      if (siteScanned && scanMode === 'contenant') {
        console.log('[processScannedData] Mode: Scan de contenant. Données:', data);
        handleContenantScan(data);
        // Rester en mode scan contenant pour permettre les scans multiples
        setScanMode('contenant');
      }
    } catch (error) {
      console.error('Erreur lors de la gestion du scan:', error);
      setErrorMessage('Erreur: ' + error.message); // Afficher l'erreur à l'utilisateur
      setScanMode(''); // Réinitialiser le mode scan
      // Optionnel: réinitialiser d'autres états si nécessaire
      setSiteScanned(false);
      setSiteDetails(null);
      setSiteCode('');
      setShowOperationTypeSelection(false);
    }
  };

  // Gérer la simulation d'un scan (pour le développement et les tests)
  const handleSimulatedScan = () => {
    // Vérifier si on est en mode sortie sans colis pris en charge
    if (scanMode === 'contenant' && operationType === 'sortie' && takingCarePackages.length === 0) {
      Alert.alert(
        "Aucun colis disponible",
        "Vous n'avez aucun colis en prise en charge à déposer.",
        [{ text: "OK" }]
      );
      return;
    }
    
    const fakeData = simulateScan();
    if (fakeData) {
      console.log(`Simulation de scan avec données: ${fakeData}`);
    processScannedData(fakeData);
    } else {
      console.error("Erreur lors de la simulation du scan: aucune donnée générée");
      Alert.alert(
        "Erreur",
        "Impossible de simuler un scan. Veuillez réessayer.",
        [{ text: "OK" }]
      );
    }
  };

  const handleManualScan = () => {
    if (manualCodeInput.trim() === '') {
      Alert.alert('Erreur', 'Veuillez entrer un code valide');
      return;
    }
    
    processScannedData(manualCodeInput.trim());
    setManualCodeInput('');
  };

  const activateSiteScan = () => {
    setScanMode('site');
    setErrorMessage('');
    setIsReadyForScan(true);
    
    // Montrer une alerte avec plusieurs options pour scanner
    Alert.alert(
      "Scanner un site",
      "Comment souhaitez-vous scanner le site ?",
      [
        {
          text: "Scanner manuellement",
          onPress: () => showManualSiteInput()
        },
        {
          text: "Simuler scan",
          onPress: handleSimulatedScan
        },
        {
          text: "Annuler",
          style: "cancel",
          onPress: () => setScanMode('')
        }
      ]
    );
  };

  // Fonction pour afficher une boîte de dialogue pour saisir manuellement le code du site
  const showManualSiteInput = () => {
    // Utiliser Alert.prompt sur iOS, mais sur Android, cette fonction n'existe pas
    // donc nous utilisons une méthode alternative
    if (Platform.OS === 'ios') {
      Alert.prompt(
        "Scanner site manuellement",
        "Entrez le code ou le nom du site",
        [
          { text: "Annuler", onPress: () => setScanMode(''), style: "cancel" },
          { 
            text: "Scanner", 
            onPress: (code) => {
              if (code && code.trim()) {
                processScannedData(code.trim());
              } else {
                setScanMode('');
                Alert.alert("Erreur", "Veuillez entrer un code de site valide");
              }
            }
          }
        ],
        "plain-text"
      );
    } else {
      // Sur Android, utiliser une solution simple avec TextInput
      Alert.alert(
        "Scanner site manuellement",
        "Entrez le code du site dans le champ de texte en haut de l'écran, puis appuyez sur Scanner",
        [
          { text: "OK" }
        ]
      );
      // Focus sur le champ de saisie manuelle
      // Note: ceci est une approche simplifiée, une solution plus robuste
      // utiliserait un modal personnalisé avec TextInput
      setManualCodeInput('');
      // On garde le mode scan actif pour que le bouton scanner manuel fonctionne
    }
  };

  // Afficher la page de sélection du type d'opération
  const showOperationSelection = () => {
    setShowOperationTypeSelection(true);
  };

  // Commencer le scan de contenant avec un type d'opération spécifique
  const startContenantScan = (type) => {
    setOperationType(type);
    setShowOperationTypeSelection(false);
    setScanMode('contenant');
    setErrorMessage('');
    setIsReadyForScan(true);
    
    // Message différent selon le type d'opération
    const message = type === 'entree' 
      ? "Veuillez scanner le code du contenant à prendre en charge" 
      : "Veuillez scanner le code du contenant à déposer";
    
    Alert.alert(
      type === 'entree' ? "Prise en charge" : "Dépôt",
      message,
      [{ text: "Annuler", onPress: () => setScanMode('') }]
    );
  };

  const handleContenantScan = async (code) => {
    if (!siteScanned) {
      Alert.alert('Erreur', 'Veuillez d\'abord scanner un site');
      return;
    }

    try {
      // Mode dépôt (sortie) - vérifier que le colis est dans la liste des colis pris en charge
      if (operationType === 'sortie') {
        const isInTakingCare = takingCarePackages.some(pkg => pkg.code === code);
        if (!isInTakingCare) {
          Alert.alert(
            "Colis non reconnu",
            "Ce colis ne fait pas partie des colis que vous avez en prise en charge.",
            [{ text: "OK" }]
          );
          return;
        }
        
        // Retirer le colis de la liste des colis pris en charge
        setTakingCarePackages(takingCarePackages.filter(pkg => pkg.code !== code));
      }

      // Obtenir la date actuelle au format approprié
      const currentDate = new Date();
      const currentDateISO = currentDate.toISOString();

      // Ajouter le contenant à la liste
      const newContenant = {
        id: Date.now().toString(),
        code: code,
        idColis: code,
        timeStamp: currentDate.toLocaleTimeString(),
        date: currentDate.toLocaleDateString(),
        scanDate: currentDateISO,
        site: siteCode,
        type: operationType, // Ajout du type d'opération (entrée/sortie)
      };
      
      setScannedContenants([newContenant, ...scannedContenants]);
    } catch (error) {
      console.error('Erreur lors de la gestion du scan:', error);
      setScanMode('');
    }
  };

  const renderScannedItem = ({ item }) => (
    <View style={[styles.contenantItem, item.type === 'sortie' ? styles.contenantItemSortie : styles.contenantItemEntree]}>
      <View style={styles.contenantInfo}>
        <Text style={styles.contenantCode}>{item.code}</Text>
        <View style={styles.contenantTypeRow}>
          <View style={item.type === 'sortie' ? styles.typeTagSortie : styles.typeTagEntree}>
            <Text style={styles.typeTagText}>{item.type === 'sortie' ? 'Dépôt' : 'Prise en charge'}</Text>
          </View>
          <Text style={styles.contenantTime}>{item.timeStamp}</Text>
        </View>
      </View>
      <TouchableOpacity
        style={styles.deleteContenantButton}
        onPress={() => removeScannedContenant(item.id)}
      >
        <Ionicons name="trash-outline" size={20} color="#e74c3c" />
      </TouchableOpacity>
    </View>
  );

  const removeScannedContenant = (id) => {
    setScannedContenants(scannedContenants.filter(contenant => contenant.id !== id));
  };

  const handleTransmit = async () => {
    if (scannedContenants.length === 0) {
      Alert.alert('Attention', 'Aucun contenant scanné à transmettre.');
      return;
    }

    setLoading(true);

    try {
      // Vérifier et afficher les données de la session pour le débogage
      console.log('Données de session:', JSON.stringify(sessionData, null, 2));
      console.log('Données de route:', JSON.stringify(route.params, null, 2));
      
      // Récupérer les données de la tournée et du véhicule avec plus de vérifications
      const tourneeName = sessionData.tournee?.nom || route.params?.tournee?.nom || '';
      const tourneeId = sessionData.tournee?.id || route.params?.tournee?.id || '';
      const vehiculeName = sessionData.vehicule?.immatriculation || route.params?.vehicule?.immatriculation || '';
      const vehiculeId = sessionData.vehicule?.id || route.params?.vehicule?.id || '';
      
      // Utiliser les détails du site validé s'ils sont disponibles
      let siteName, siteId, siteAdresse, siteCodePostal, siteVille;
      
      if (siteDetails) {
        // Utiliser les bonnes clés du siteDetails (nommage uniforme)
        siteName = siteDetails.name || siteCode;
        siteId = siteDetails.id || '';
        siteAdresse = siteDetails.address || '';
        siteCodePostal = siteDetails.codePostal || '';
        siteVille = siteDetails.city || '';
      } else {
        // Sinon on utilise ce qu'on a par défaut
        siteName = sessionData.tournee?.siteDepart || route.params?.tournee?.siteDepart || siteCode || 'Non spécifié';
        siteId = '';
      }
      
      console.log('Données récupérées pour les scans:', {
        tourneeName,
        tourneeId,
        vehiculeName,
        vehiculeId,
        siteName,
        siteId,
        siteCode
      });

      // Récupérer l'ID de session actuel
      const currentSessionId = await AsyncStorage.getItem('currentSessionId') || `session_${Date.now()}`;
      
      // Préparer les scans avec tous les champs nécessaires
      const scansToSubmit = scannedContenants.map(scan => {
        const scanDate = scan.scanDate || new Date().toISOString();
        
        // Le code du contenant devient l'ID du colis
        const scanItem = {
          code: scan.code,
          idColis: scan.code || scan.idColis,
          scanDate: scanDate,
          tournee: tourneeName,
          tourneeId: tourneeId,
          vehicule: vehiculeName,
          vehiculeId: vehiculeId,
          immatriculation: vehiculeName,
          site: siteName,
          siteId: siteId,
          siteCode: siteCode,
          siteDepart: siteName,
          siteDépart: siteName,
          sessionId: currentSessionId, // Ajouter l'ID de session pour le filtrage ultérieur
          operationType: scan.type || 'entree', // Ajout du type d'opération
          status: scan.type === 'sortie' ? 'livré' : 'en-cours', // Status basé sur le type d'opération
          type: scan.type || 'entree' // Assurer que le type est inclus explicitement
        };
        
        // Ajouter siteFin uniquement pour les colis livrés
        if (scan.type === 'sortie') {
          // Pour les opérations de sortie (dépôt), ajouter des informations spécifiques
          const currentDate = new Date();
          
          // Utiliser le nom du site actuel comme site d'arrivée
          scanItem.siteFin = siteName;
          // Ajouter date et heure d'arrivée au format correct
          scanItem.dateArrivee = currentDate.toLocaleDateString();
          scanItem.heureArrivee = currentDate.toLocaleTimeString();
          // Ajouter ces champs supplémentaires pour assurer la compatibilité
          scanItem.dateHeureFin = currentDate.toISOString();
          scanItem.statut = 'Livré';
          scanItem.status = 'livré'; // Assurez-vous que les deux formats sont présents
          scanItem.coursierLivraison = sessionData.coursierCharg || route.params?.coursierCharg || '';
        }
        
        // Ajouter les détails du site s'ils sont disponibles
        if (siteDetails) {
          scanItem.siteDetails = {
            adresse: siteAdresse,
            codePostal: siteCodePostal,
            ville: siteVille
          };
        }

        // Ajouter la localisation si disponible
        if (sessionData.location) {
          scanItem.location = {
            latitude: sessionData.location.coords.latitude,
            longitude: sessionData.location.coords.longitude,
            accuracy: sessionData.location.coords.accuracy
          };
        }

        return scanItem;
      });
      
      // Afficher les données qui seront transmises
      console.log('Transmission des scans:', JSON.stringify(scansToSubmit, null, 2)); // Décommenté pour débogage
      
      // Envoyer les scans à Firebase
      const result = await firebaseService.addScans(scansToSubmit);
      console.log('Résultat de la transmission:', result);
      
      // Si la transmission réussit, mettre à jour l'historique local
      if (result.success) {
        // --- Logique de consolidation --- 
        const updatedScansMap = new Map();
        historicalScans.forEach(scan => {
          // Assurer qu'on a un code pour la clé de la map
          if (scan.code) {
            updatedScansMap.set(scan.code, scan);
          }
        });
        scansToSubmit.forEach(scan => {
          if (scan.code) {
            const originalScan = scannedContenants.find(s => s.code === scan.code);
            const scanForHistory = {
              ...scan,
              timeStamp: originalScan?.timeStamp || dateUtils.formatTime(scan.scanDate),
            };
            updatedScansMap.set(scan.code, scanForHistory);
          }
        });
        const newHistory = Array.from(updatedScansMap.values());
        newHistory.sort((a, b) => {
          const dateA = a.scanDate ? new Date(a.scanDate).getTime() : 0;
          const dateB = b.scanDate ? new Date(b.scanDate).getTime() : 0;
          if (isNaN(dateA) && isNaN(dateB)) return 0;
          if (isNaN(dateA)) return 1;
          if (isNaN(dateB)) return -1;
          return dateB - dateA;
        });
        // --- Fin de la logique de consolidation ---

        // Sauvegarder l'historique consolidé dans AsyncStorage
        await AsyncStorage.setItem('scanHistory', JSON.stringify(newHistory));
        
        // Mise à jour de l'état React DIFFÉRÉE après les interactions
        InteractionManager.runAfterInteractions(() => {
          setHistoricalScans(newHistory);
        });
        
        // Mettre à jour la liste des paquets pris en charge
        if (operationType === 'entree') {
          setTakingCarePackages([...scansToSubmit, ...takingCarePackages]);
        } else if (operationType === 'sortie') {
          const codesDeposited = scansToSubmit.map(scan => scan.code);
          setTakingCarePackages(takingCarePackages.filter(pkg => pkg.code && !codesDeposited.includes(pkg.code)));
        }
        
        // Réinitialiser complètement l'état pour revenir à l'écran de scan de site
        resetScan(); // Cette fonction réinitialise les états de base

        // S'assurer que tous les états sont correctement réinitialisés pour revenir à l'écran initial
        setShowOperationTypeSelection(false);
        setOperationType('entree'); // Réinitialiser à l'entrée de colis par défaut
        
        // Important: Désactiver le chargement AVANT l'alerte
        setLoading(false);
        
        // Afficher l'alerte de succès
        Alert.alert(
          'Succès',
          `${scansToSubmit.length} scan(s) transmis avec succès`,
          [{ text: 'OK' }]
        );
      } else {
        setLoading(false);
        throw new Error(result.error || 'Échec de la transmission');
      }
    } catch (error) {
      console.error('Erreur lors de la transmission:', error);
      setLoading(false);
      Alert.alert('Erreur', `Échec de la transmission: ${error.message}`);
    }
  };

  const resetScan = () => {
    setScanMode('');
    setSiteScanned(false);
    setSiteCode('');
    setScannedContenants([]);
    setManualCodeInput('');
    setSiteDetails(null);
  };

  const navigateToHistory = () => {
    setShowHistoryModal(true);
  };

  // Fonction pour obtenir les détails de la session actuelle
  const getSessionDetails = async () => {
    try {
      const currentSession = await firebaseService.getCurrentSession();
      if (currentSession) {
        setSessionId(currentSession.id);
        setTournee(currentSession.tournee);
        setVehicule(currentSession.vehicule);
        setPole(currentSession.pole);
      }
    } catch (error) {
      console.error("Erreur lors de la récupération de la session:", error);
    }
  };

  // Fonction pour effacer l'historique des scans
  const clearHistoricalScans = async () => {
    try {
      Alert.alert(
        'Effacer l\'historique',
        'Voulez-vous vraiment effacer tout l\'historique des scans?',
        [
          {
            text: 'Annuler',
            style: 'cancel'
          },
          {
            text: 'Effacer',
            onPress: async () => {
              await AsyncStorage.removeItem('scanHistory');
              setHistoricalScans([]);
              Alert.alert('Succès', 'Historique effacé avec succès');
            },
            style: 'destructive'
          }
        ]
      );
    } catch (error) {
      console.error('Erreur lors de l\'effacement de l\'historique:', error);
      Alert.alert('Erreur', 'Impossible d\'effacer l\'historique');
    }
  };

  // Ajout d'une fonction pour effacer explicitement tous les scans de la session actuelle
  const clearCurrentSessionScans = async () => {
    try {
      const currentSessionId = await AsyncStorage.getItem('currentSessionId');
      if (!currentSessionId) {
        Alert.alert('Erreur', 'Impossible de déterminer la session actuelle');
        return;
      }
      
      Alert.alert(
        'Réinitialiser l\'historique',
        'Cette action va supprimer tous les scans associés à votre session actuelle. Continuer?',
        [
          {
            text: 'Annuler',
            style: 'cancel'
          },
          {
            text: 'Supprimer',
            onPress: async () => {
              try {
                // Supprimer les scans associés à la session actuelle
                setLoading(true);
                console.log(`Suppression des scans de la session ${currentSessionId}...`);
                
                // Fonction côté service qui devrait être implémentée
                // pour supprimer tous les scans de la session
                const result = await firebaseService.clearSessionScans(currentSessionId);
                
                // Supprimer l'historique local également
                await AsyncStorage.removeItem('scanHistory');
                setHistoricalScans([]);
                
                setLoading(false);
                Alert.alert('Succès', 'Historique réinitialisé avec succès');
              } catch (error) {
                setLoading(false);
                console.error('Erreur lors de la suppression des scans:', error);
                Alert.alert('Erreur', `Échec de la suppression: ${error.message}`);
              }
            },
            style: 'destructive'
          }
        ]
      );
    } catch (error) {
      console.error('Erreur:', error);
      Alert.alert('Erreur', 'Une erreur est survenue');
    }
  };

  // Handler de déconnexion avec effacement complet de l'historique
  const handleLogout = async () => {
    try {
      Alert.alert(
        'Déconnexion',
        'Voulez-vous vous déconnecter? L\'historique des scans sera effacé.',
        [
          {
            text: 'Annuler',
            style: 'cancel'
          },
          {
            text: 'Déconnecter',
            onPress: async () => {
              try {
                setLoading(true);
                console.log('Déconnexion en cours...');

                // Appeler la méthode de déconnexion de Firebase
                await firebaseService.logout();
                console.log('Déconnexion Firebase réussie');
                
                // Effacer toutes les données de session
                await AsyncStorage.removeItem('userSessionActive');
                // On conserve current_session_id pour que la tournée visitée reste en mémoire
                await AsyncStorage.removeItem('scanHistory');
                await AsyncStorage.removeItem('user_selas_id');
                
                // Réinitialiser les états
                setHistoricalScans([]);
                setScannedContenants([]);
                setSiteScanned(false);
                setSiteCode('');
                
                setLoading(false);
                
                // Rediriger vers l'écran de connexion
                navigation.reset({
                  index: 0,
                  routes: [{ name: 'Login' }]
                });
              } catch (error) {
                setLoading(false);
                console.error('Erreur lors du processus de déconnexion:', error);
                Alert.alert('Erreur', 'Impossible de se déconnecter. Veuillez réessayer.');
              }
            }
          }
        ]
      );
    } catch (error) {
      console.error('Erreur lors de la déconnexion:', error);
    }
  };

  // Utiliser directement les fonctions de formatage de dateUtils
  // au lieu de redéfinir des fonctions similaires

  // Effet pour écouter les événements de scan Zebra
  useEffect(() => {
    if (isReadyForScan) {
      // Afficher un message pour indiquer que l'application est prête pour le scan
      console.log('Prêt à recevoir des scans du scanner Zebra');
      
      // Configuration pour recevoir les scans du matériel Zebra
      const handleZebraScan = (event) => {
        // Le scanner Zebra envoie généralement les données comme des entrées clavier
        // Nous devons vérifier que nous sommes en mode scan et traiter les données
        if (event && event.nativeEvent && event.nativeEvent.key === 'Enter' && scanMode) {
          // Récupérer le texte scanné (par exemple depuis un champ de texte caché ou via une API Zebra)
          // Pour les besoins de cet exemple, nous utiliserons la valeur de manualCodeInput
          if (manualCodeInput.trim()) {
            processScannedData(manualCodeInput.trim());
            setManualCodeInput(''); // Réinitialiser après le traitement
          }
        }
      };
      
      // Ajoutez ici l'initialisation spécifique au scanner Zebra si nécessaire
      // Exemple : ZebraScanner.initialize() si une API Zebra est disponible
      
      // Pour cet exemple, on simule en utilisant l'écouteur de clavier (pour Enter)
      Keyboard.addListener('keyDown', handleZebraScan);
      
      return () => {
        // Nettoyage lors du démontage
        Keyboard.removeListener('keyDown', handleZebraScan);
        // Désinitialiser le scanner Zebra si nécessaire
        // Exemple : ZebraScanner.deinitialize()
      };
    }
  }, [isReadyForScan, scanMode, manualCodeInput]);


  const loadHistoricalScans = async () => {
    try {
      const jsonValue = await AsyncStorage.getItem('scanHistory');
      if (jsonValue !== null) {
        const history = JSON.parse(jsonValue);
        
        // Récupérer l'ID de la tournée actuelle
        const currentSession = await firebaseService.getCurrentSession();
        const currentTourneeId = currentSession?.tournee?.id || sessionData?.tournee?.id || '';
        
        // Filtrer l'historique local
        const today = new Date();
        today.setHours(0, 0, 0, 0); // Début de la journée
        
        const filteredHistory = history.filter(item => {
          // Convertir la date de l'item en objet Date
          let itemDate;
          try {
            itemDate = new Date(item.date);
            if (isNaN(itemDate.getTime())) {
              // Si la date n'est pas valide, essayer un autre format
              const parts = item.date.split('/');
              if (parts.length === 3) {
                itemDate = new Date(parts[2], parts[1] - 1, parts[0]);
              }
            }
          } catch (e) {
            // En cas d'erreur, considérer cet item comme non valide pour le filtre
            return false;
          }

          // S'assurer que nous avons une date valide
          if (!itemDate || isNaN(itemDate.getTime())) return false;
          
          itemDate.setHours(0, 0, 0, 0); // Normaliser à minuit
          
          // Vérifier la tournée
          const isSameTournee = !currentTourneeId || item.tourneeId === currentTourneeId;
          
          // Vérifier le statut (inclut les visites sans colis)
          const hasValidStatus = item.status === 'en-cours' || item.status === 'livré';
          
          // L'item doit être du jour courant ET de la même tournée ET avoir un statut valide
          return itemDate.getTime() === today.getTime() && isSameTournee && hasValidStatus;
        });
        
        console.log(`Historique local filtré: ${filteredHistory.length} scans (jour + tournée + statut)`);
        
        // Consolider l'historique filtré avant de mettre à jour l'état
        const consolidatedHistory = consolidateAndSortScans([], filteredHistory);

        // Enrichir avec le nom complet du site depuis Firestore
        const enrichedHistory = await Promise.all(
          consolidatedHistory.map(async (scan) => {
            // Tenter de récupérer les détails du site en utilisant siteId ou code
            try {
              const siteIdentifier = scan.siteId || scan.code; // Utiliser ID ou code
              // Vérifier si l'identifiant est probablement un site avant d'appeler getSiteById
              if (siteIdentifier && 
                  !siteIdentifier.startsWith('TEST_CONTENANT_') && 
                  !siteIdentifier.match(/^[0-9]{13,}$/)) { 
                const siteInfo = await firebaseService.getSiteById(siteIdentifier);
                if (siteInfo) {
                  // Enrichir le scan avec les détails complets
                  return { 
                    ...scan, 
                    siteName: siteInfo.nom || siteInfo.name, // Ajouter le nom pour affichage facile
                    siteDetails: { ...siteInfo } 
                  };
                }
              }
            } catch (e) {
              console.warn(`[loadHistoricalScans] Erreur récupération détails site pour ${scan.code || scan.id}:`, e);
            }
            // Si non trouvé ou erreur, retourner le scan original
            return scan;
          })
        );
        
        // Mettre à jour l'état avec l'historique enrichi
        setHistoricalScans(enrichedHistory);
        setSessionHistoryLoaded(true);
      }
    } catch (error) {
      console.error('Erreur lors du chargement de l\'historique:', error);
    }
  };

  const loadFirestoreScans = async () => {
    try {
      // On ne charge les scans Firestore que si la session est active
      const userSessionActive = await AsyncStorage.getItem('userSessionActive');
      if (userSessionActive !== 'true') {
        // Si aucune session active, on ne charge pas l'historique Firestore
        return;
      }

      // Récupérer l'ID de session actuel
      const currentSessionId = await AsyncStorage.getItem('currentSessionId');
      console.log('Chargement des scans pour la session:', currentSessionId);

      // Récupérer l'ID de la tournée actuelle
      const currentSession = await firebaseService.getCurrentSession();
      const currentTourneeId = currentSession?.tournee?.id || sessionData?.tournee?.id || '';
      console.log('Tournée actuelle:', currentTourneeId);

      setLoading(true); // Afficher l'indicateur de chargement

      // Récupérer tous les scans de l'utilisateur (sans limite)
      const scans = await firebaseService.getScans();
      
      if (scans && scans.length > 0) {
        // Ne garder que les scans du jour (J0)
        const today = new Date();
        today.setHours(0, 0, 0, 0); // Début de la journée
        
        const filteredScans = scans.filter(scan => {
          // Convertir la date du scan en objet Date
          const scanDate = dateUtils.convertTimestampToDate(scan.scanDate || scan.createdAt);
          if (!scanDate) return false;
          
          // Récupérer juste la date (sans l'heure)
          const scanDateOnly = new Date(scanDate);
          scanDateOnly.setHours(0, 0, 0, 0);
          
          // Vérifier la tournée (si une tournée actuelle est définie)
          const isSameTournee = !currentTourneeId || scan.tourneeId === currentTourneeId;
          
          // Vérifier le statut (inclut "pas_de_colis")
          const hasValidStatus = scan.status === 'en-cours' || scan.status === 'livré';
          
          // Le scan doit être du jour courant ET de la même tournée ET avoir un statut valide
          return scanDateOnly.getTime() === today.getTime() && isSameTournee && hasValidStatus;
        });
        
        // Convertir les scans Firestore filtrés en format compatible avec l'historique local
        const formattedScans = filteredScans.map(scan => {
          // Déduire le statut si manquant, basé sur le type d'opération
          let status = scan.status;
          if (!status) {
            status = scan.operationType === 'sortie' ? 'livré' : 'en-cours';
          }
          
          return {
            id: scan.id || Date.now().toString(),
            code: scan.code,
            timeStamp: dateUtils.formatTime(scan.scanDate || scan.createdAt),
            date: dateUtils.formatDate(scan.scanDate || scan.createdAt),
            site: scan.site,
            fromFirestore: true,
            sessionId: scan.sessionId,
            // Utiliser le statut (corrigé si nécessaire)
            status: status, 
            // S'assurer que le type est aussi présent
            type: scan.operationType || (status === 'livré' ? 'sortie' : 'entree'), 
            tournee: scan.tournee || '',
            tourneeId: scan.tourneeId || '',
            scanDate: scan.scanDate ? dateUtils.convertTimestampToDate(scan.scanDate).toISOString() : (scan.createdAt ? dateUtils.convertTimestampToDate(scan.createdAt).toISOString() : new Date().toISOString()) // Garder une date ISO pour le tri
          };
        });
        
        // Consolider et trier
        const consolidatedScans = consolidateAndSortScans(historicalScans, formattedScans);
        // Enrichir avec le nom complet du site depuis Firestore
        const enrichedScans = await Promise.all(
          consolidatedScans.map(async (scan) => {
            try {
              // Tenter de récupérer les détails du site
              try {
                // Utiliser l'ID du site si disponible, sinon le code barre
                const siteIdentifier = scan.siteId || scan.code; // Assumer que siteId existe
                if (siteIdentifier && 
                    !siteIdentifier.startsWith('TEST_CONTENANT_') && 
                    !siteIdentifier.match(/^[0-9]{13,}$/)) {
                  // Utiliser une variable locale au lieu de réassigner l'état siteDetails
                  const siteInfo = await firebaseService.getSiteById(siteIdentifier); 
                  if (siteInfo) {
                    // Modifier l'objet scan directement
                    scan.siteName = siteInfo.nom || siteInfo.name; // Utiliser le nom du site s'il est trouvé
                    scan.siteDetails = siteInfo; // Ajouter les détails au scan
                  } else {
                     // Si siteInfo est null, indiquer le nom comme code
                     scan.siteName = scan.code; 
                  }
                } else {
                   scan.siteName = scan.code; // Fallback si aucun identifiant
                }
              } catch (siteError) {
                console.warn(`[loadFirestoreScans] Impossible de récupérer les détails du site pour l'identifiant ${scan.siteId || scan.code}:`, siteError);
                scan.siteName = scan.code; // Afficher le code si erreur
              }
              
              // Ne récupérer les informations sur le site que s'il ne s'agit pas d'un conteneur
              if (scan.site && 
                  !scan.site.startsWith('TEST_CONTENANT_') && 
                  !scan.site.match(/^[0-9]{13,}$/)) {
                const siteInfo = await firebaseService.getSiteById(scan.site);
                if (siteInfo) return { ...scan, siteDetails: { ...siteInfo } };
              }
            } catch (e) {
              console.error('Erreur récupération nom site Firestore:', e);
            }
            return scan;
          })
        );
        
        // Mettre à jour l'état avec l'historique enrichi
        setHistoricalScans(enrichedScans);
        setSessionHistoryLoaded(true);
        
        // Sauvegarder également dans AsyncStorage pour la persistance locale temporaire
        await AsyncStorage.setItem('scanHistory', JSON.stringify(enrichedScans));
      }
      
      setLoading(false); // Masquer l'indicateur de chargement
    } catch (error) {
      console.error('Erreur lors du chargement des scans depuis Firestore:', error);
      setLoading(false); // Masquer l'indicateur de chargement en cas d'erreur
    }
  };

  // --- AJOUTER CETTE FONCTION D'AIDE --- 
  // Fonction pour consolider et trier les scans
  const consolidateAndSortScans = (existingScans, newScans) => {
    const map = new Map();

    // Ajouter les scans existants à la map
    existingScans.forEach(scan => {
      if (scan.code) map.set(scan.code, scan);
    });

    // Mettre à jour ou ajouter les nouveaux scans
    newScans.forEach(scan => {
      if (scan.code) map.set(scan.code, scan);
    });

    // Convertir la map en tableau
    const consolidated = Array.from(map.values());

    // Trier
    consolidated.sort((a, b) => {
      const dateA = a.scanDate ? new Date(a.scanDate).getTime() : 0;
      const dateB = b.scanDate ? new Date(b.scanDate).getTime() : 0;
      if (isNaN(dateA) && isNaN(dateB)) return 0;
      if (isNaN(dateA)) return 1;
      if (isNaN(dateB)) return -1;
      return dateB - dateA;
    });

    return consolidated;
  };
  // --- FIN DE L'AJOUT ---

  const loadTakingCarePackages = async () => {
    try {
      const scansEnCours = await firebaseService.getScansEnCours();
      // Filtrer pour exclure les scans "pas_de_colis"
      const filteredScans = scansEnCours.filter(scan => 
        scan.status !== 'pas_de_colis' &&
        !(scan.code && scan.code.startsWith('SITE_'))
      );
      console.log(`✅ ${filteredScans.length} paquet(s) pris en charge récupéré(s) (sans les "pas_de_colis")`);
      setTakingCarePackages(filteredScans);
    } catch (error) {
      console.error('❌ Erreur lors du chargement des paquets pris en charge:', error);
    }
  };

  // 🔹 Simulation d'un scan avec des sites valides
  const simulateScan = () => {
    if (scanMode === 'site') {
      // Sites de test qui seront reconnus comme valides
      const sitesDemoValides = [
        'SITE123',
        'SITE456',
        'SITE789',
        'LAB001',
        '12345'
      ];
      
      // Sélectionner un site aléatoire parmi les sites valides pour la démo
      return sitesDemoValides[Math.floor(Math.random() * sitesDemoValides.length)];
    } else {
      // Si on est en mode sortie (dépôt), on doit scanner un colis déjà pris en charge
      if (operationType === 'sortie') {
        // Vérifier si des colis sont disponibles
        if (takingCarePackages.length > 0) {
          // Sélectionner un colis aléatoire parmi les colis pris en charge
          const randomPackage = takingCarePackages[Math.floor(Math.random() * takingCarePackages.length)];
          return randomPackage.code;
        } else {
          // Aucun colis disponible pour le dépôt - cette condition est gérée dans handleSimulatedScan
          return '';
        }
      } else {
        // Simuler un scan de contenant pour prise en charge
        // Utiliser un préfixe spécifique pour les tests afin de pouvoir les identifier facilement
        const testId = Date.now(); // Utiliser le timestamp actuel pour créer un ID unique
        return `TEST_CONTENANT_${testId}`;
      }
    }
  };

  // Modification pour les tests : fonction mock qui simule verifySiteCode
  const mockVerifySiteCode = async (siteCode) => {
    // Sites de test qui seront automatiquement validés
    const sitesDemoValides = {
      'SITE123': { nom: 'Site Test 1', adresse: '123 Rue Principale', ville: 'Paris', codePostal: '75001' },
      'SITE456': { nom: 'Site Test 2', adresse: '456 Avenue République', ville: 'Lyon', codePostal: '69001' },
      'SITE789': { nom: 'Site Test 3', adresse: '789 Boulevard des Tests', ville: 'Toulouse', codePostal: '31000' },
      '12345': { nom: 'Laboratoire Central', adresse: '12 Rue des Sciences', ville: 'Montpellier', codePostal: '34000' },
      'LAB001': { nom: 'Laboratoire Mobile', adresse: 'Zone Industrielle', ville: 'Bordeaux', codePostal: '33000' }
    };

    // Vérifier si le code scanné est dans notre liste de sites de test
    if (sitesDemoValides[siteCode]) {
      // Retourner une structure simulant la réponse de Firebase
      return {
        valid: true,
        site: {
          id: `mock_${siteCode}`,
          code: siteCode,
          nom: sitesDemoValides[siteCode].nom,
          adresse: sitesDemoValides[siteCode].adresse,
          ville: sitesDemoValides[siteCode].ville,
          codePostal: sitesDemoValides[siteCode].codePostal
        }
      };
    }

    // Si ce n'est pas un site de test, passer à la vérification normale dans Firebase
    return await firebaseService.verifySiteCode(siteCode);
  };

  const processScannedData = async (data) => {
    console.log('Code scanné:', data);
    try {
      // Cas 1: Nous n'avons pas encore scanné de site
      if (!siteScanned && scanMode === 'site') {
        console.log('[processScannedData] Mode: Scan de site. Données:', data);
        const siteVerification = await firebaseService.verifySiteCode(data);
        console.log('[processScannedData] Résultat de verifySiteCode:', JSON.stringify(siteVerification));

        if (siteVerification.site) {
          // Enregistrer les infos du site
          setSiteCode(data);
          setSiteDetails(siteVerification.site);
          // setSiteScanned(true); // Mis plus bas pour ne l'activer qu'après succès
          // setScanMode(''); // Mis plus bas
          // setShowOperationTypeSelection(true); // Mis plus bas

          // --- MODIFIÉ: Ne trouver que le premier site non visité avec ce nom ---
          let occurrenceIndex = null;
          if (tourneeProgressRef.current?.getSitesWithStatus) {
            const sitesList = tourneeProgressRef.current.getSitesWithStatus();
            console.log('[processScannedData] sitesList depuis tourneeProgressRef:', JSON.stringify(sitesList.map(s => ({ id: s.id, name: s.name, visited: s.visited, uniqueDisplayId: s.uniqueDisplayId }))));
            const siteNameToFind = siteVerification.site.nom || siteVerification.site.name;
            console.log('[processScannedData] Nom du site à trouver:', siteNameToFind);

            // Trouver le premier site non visité avec ce nom
            occurrenceIndex = sitesList.findIndex(s => !s.visited && (s.name === siteNameToFind || s.nom === siteNameToFind)); // Ajout de s.nom
            console.log(`[processScannedData] Occurrence index trouvée pour ${siteNameToFind}:`, occurrenceIndex);
            
            // Si aucun site non visité n'est trouvé, ne rien faire
            if (occurrenceIndex === -1) {
              Alert.alert(
                'Site déjà visité ou non trouvé', // Message mis à jour
                'Ce site a déjà été visité, ne fait pas partie de cette tournée, ou son nom ne correspond pas exactement.', // Message mis à jour
                [{ text: 'OK', onPress: () => {
                  // Réinitialiser l'état pour permettre un nouveau scan
                  setSiteScanned(false);
                  setSiteDetails(null);
                  setSiteCode('');
                  setShowOperationTypeSelection(false);
                }}]
              );
              return;
            }
          } else {
            console.warn('[processScannedData] tourneeProgressRef.current.getSitesWithStatus non disponible.');
            Alert.alert('Erreur', 'Impossible de récupérer la liste des sites de la tournée.');
            return;
          }

          // Marquage en session via l'index si trouvé, sinon par site.id
          const identifier = siteVerification.site.id || (siteVerification.site.code || data);
          console.log('[processScannedData] Identifier pour markSiteVisitedInSession:', identifier);
          console.log('[processScannedData] currentSessionId avant appel:', currentSessionId);
          console.log('[processScannedData] occurrenceIndex avant appel:', occurrenceIndex);

          if (!currentSessionId) {
            console.error('[processScannedData] ID de session manquant avant markSiteVisitedInSession');
            Alert.alert('Erreur Critique', 'ID de session manquant. Impossible de continuer.');
            return;
          }
          
          // Ne marquer qu'un seul site à la fois, en utilisant l'index spécifique
          if (occurrenceIndex !== -1 && occurrenceIndex !== null) { // Condition déjà présente, mais on log avant
            const markSuccess = await firebaseService.markSiteVisitedInSession(currentSessionId, identifier, occurrenceIndex);
            console.log('[processScannedData] Résultat de markSiteVisitedInSession:', markSuccess);
            
            if (markSuccess) {
              setSiteScanned(true); // Activer seulement si le marquage Firestore a réussi
              setScanMode(''); 
              setShowOperationTypeSelection(true);

              // Mise à jour du UI local - mettre à jour uniquement le site spécifique
              if (tourneeProgressRef.current?.markSiteAsVisitedLocally) {
                console.log('[processScannedData] Appel de markSiteAsVisitedLocally avec:', identifier, occurrenceIndex);
                await tourneeProgressRef.current.markSiteAsVisitedLocally(identifier, occurrenceIndex); // AJOUT DE AWAIT
                // Temporairement commenté pour tester si la coche se met à jour correctement sans rechargement immédiat
                // await updateTourneeProgress(); 
              } else if (tourneeProgressRef.current?.loadTourneeDetails) {
                console.log('[processScannedData] Appel de loadTourneeDetails(true) car markSiteAsVisitedLocally non dispo.');
                await tourneeProgressRef.current.loadTourneeDetails(true);
              }
            } else {
              Alert.alert('Erreur', 'Échec du marquage du site comme visité dans la session Firestore.');
              // Garder siteScanned à false, etc.
            }
            
            // Si updateTourneeProgress a été commenté, on peut appeler loadHistoricalData ici
            // si c'est nécessaire pour d'autres parties de l'UI non liées à TourneeProgress.
            // Pour l'instant, on isole le problème de la coche.
            // await loadHistoricalData(); 

          } else {
             console.warn('[processScannedData] occurrenceIndex invalide, markSiteVisitedInSession non appelé.');
             // Potentiellement une alerte ici si ce cas ne devrait pas arriver
          }
          return;
        } else { // siteVerification.site est null/undefined
          console.log('[processScannedData] Aucun site valide retourné par verifySiteCode pour le code:', data);
          Alert.alert('Site Inconnu', 'Le code scanné ne correspond à aucun site connu.');
           // Réinitialiser pour permettre un nouveau scan
          setSiteScanned(false);
          setSiteDetails(null);
          setSiteCode('');
          setShowOperationTypeSelection(false);
        }
      }
      
      // Cas 2: Site déjà scanné, nous scannons maintenant un contenant
      if (siteScanned && scanMode === 'contenant') {
        console.log('[processScannedData] Mode: Scan de contenant. Données:', data);
        handleContenantScan(data);
        // Rester en mode scan contenant pour permettre les scans multiples
        setScanMode('contenant');
      }
    } catch (error) {
      console.error('Erreur lors de la gestion du scan:', error);
      setErrorMessage('Erreur: ' + error.message); // Afficher l'erreur à l'utilisateur
      setScanMode(''); // Réinitialiser le mode scan
      // Optionnel: réinitialiser d'autres états si nécessaire
      setSiteScanned(false);
      setSiteDetails(null);
      setSiteCode('');
      setShowOperationTypeSelection(false);
    }
  };

  // Gérer la simulation d'un scan (pour le développement et les tests)
  const handleSimulatedScan = () => {
    // Vérifier si on est en mode sortie sans colis pris en charge
    if (scanMode === 'contenant' && operationType === 'sortie' && takingCarePackages.length === 0) {
      Alert.alert(
        "Aucun colis disponible",
        "Vous n'avez aucun colis en prise en charge à déposer.",
        [{ text: "OK" }]
      );
      return;
    }
    
    const fakeData = simulateScan();
    if (fakeData) {
      console.log(`Simulation de scan avec données: ${fakeData}`);
    processScannedData(fakeData);
    } else {
      console.error("Erreur lors de la simulation du scan: aucune donnée générée");
      Alert.alert(
        "Erreur",
        "Impossible de simuler un scan. Veuillez réessayer.",
        [{ text: "OK" }]
      );
    }
  };

  const handleManualScan = () => {
    if (manualCodeInput.trim() === '') {
      Alert.alert('Erreur', 'Veuillez entrer un code valide');
      return;
    }
    
    processScannedData(manualCodeInput.trim());
    setManualCodeInput('');
  };

  const activateSiteScan = () => {
    setScanMode('site');
    setErrorMessage('');
    setIsReadyForScan(true);
    
    // Montrer une alerte avec plusieurs options pour scanner
    Alert.alert(
      "Scanner un site",
      "Comment souhaitez-vous scanner le site ?",
      [
        {
          text: "Scanner manuellement",
          onPress: () => showManualSiteInput()
        },
        {
          text: "Simuler scan",
          onPress: handleSimulatedScan
        },
        {
          text: "Annuler",
          style: "cancel",
          onPress: () => setScanMode('')
        }
      ]
    );
  };

  // Fonction pour afficher une boîte de dialogue pour saisir manuellement le code du site
  const showManualSiteInput = () => {
    // Utiliser Alert.prompt sur iOS, mais sur Android, cette fonction n'existe pas
    // donc nous utilisons une méthode alternative
    if (Platform.OS === 'ios') {
      Alert.prompt(
        "Scanner site manuellement",
        "Entrez le code ou le nom du site",
        [
          { text: "Annuler", onPress: () => setScanMode(''), style: "cancel" },
          { 
            text: "Scanner", 
            onPress: (code) => {
              if (code && code.trim()) {
                processScannedData(code.trim());
              } else {
                setScanMode('');
                Alert.alert("Erreur", "Veuillez entrer un code de site valide");
              }
            }
          }
        ],
        "plain-text"
      );
    } else {
      // Sur Android, utiliser une solution simple avec TextInput
      Alert.alert(
        "Scanner site manuellement",
        "Entrez le code du site dans le champ de texte en haut de l'écran, puis appuyez sur Scanner",
        [
          { text: "OK" }
        ]
      );
      // Focus sur le champ de saisie manuelle
      // Note: ceci est une approche simplifiée, une solution plus robuste
      // utiliserait un modal personnalisé avec TextInput
      setManualCodeInput('');
      // On garde le mode scan actif pour que le bouton scanner manuel fonctionne
    }
  };

  // Afficher la page de sélection du type d'opération
  const showOperationSelection = () => {
    setShowOperationTypeSelection(true);
  };

  // Commencer le scan de contenant avec un type d'opération spécifique
  const startContenantScan = (type) => {
    setOperationType(type);
    setShowOperationTypeSelection(false);
    setScanMode('contenant');
    setErrorMessage('');
    setIsReadyForScan(true);
    
    // Message différent selon le type d'opération
    const message = type === 'entree' 
      ? "Veuillez scanner le code du contenant à prendre en charge" 
      : "Veuillez scanner le code du contenant à déposer";
    
    Alert.alert(
      type === 'entree' ? "Prise en charge" : "Dépôt",
      message,
      [{ text: "Annuler", onPress: () => setScanMode('') }]
    );
  };

  const handleContenantScan = async (code) => {
    if (!siteScanned) {
      Alert.alert('Erreur', 'Veuillez d\'abord scanner un site');
      return;
    }

    try {
      // Mode dépôt (sortie) - vérifier que le colis est dans la liste des colis pris en charge
      if (operationType === 'sortie') {
        const isInTakingCare = takingCarePackages.some(pkg => pkg.code === code);
        if (!isInTakingCare) {
          Alert.alert(
            "Colis non reconnu",
            "Ce colis ne fait pas partie des colis que vous avez en prise en charge.",
            [{ text: "OK" }]
          );
          return;
        }
        
        // Retirer le colis de la liste des colis pris en charge
        setTakingCarePackages(takingCarePackages.filter(pkg => pkg.code !== code));
      }

      // Obtenir la date actuelle au format approprié
      const currentDate = new Date();
      const currentDateISO = currentDate.toISOString();

      // Ajouter le contenant à la liste
      const newContenant = {
        id: Date.now().toString(),
        code: code,
        idColis: code,
        timeStamp: currentDate.toLocaleTimeString(),
        date: currentDate.toLocaleDateString(),
        scanDate: currentDateISO,
        site: siteCode,
        type: operationType, // Ajout du type d'opération (entrée/sortie)
      };
      
      setScannedContenants([newContenant, ...scannedContenants]);
    } catch (error) {
      console.error('Erreur lors de la gestion du scan:', error);
      setScanMode('');
    }
  };

  const renderScannedItem = ({ item }) => (
    <View style={[styles.contenantItem, item.type === 'sortie' ? styles.contenantItemSortie : styles.contenantItemEntree]}>
      <View style={styles.contenantInfo}>
        <Text style={styles.contenantCode}>{item.code}</Text>
        <View style={styles.contenantTypeRow}>
          <View style={item.type === 'sortie' ? styles.typeTagSortie : styles.typeTagEntree}>
            <Text style={styles.typeTagText}>{item.type === 'sortie' ? 'Dépôt' : 'Prise en charge'}</Text>
          </View>
          <Text style={styles.contenantTime}>{item.timeStamp}</Text>
        </View>
      </View>
      <TouchableOpacity
        style={styles.deleteContenantButton}
        onPress={() => removeScannedContenant(item.id)}
      >
        <Ionicons name="trash-outline" size={20} color="#e74c3c" />
      </TouchableOpacity>
    </View>
  );

  const removeScannedContenant = (id) => {
    setScannedContenants(scannedContenants.filter(contenant => contenant.id !== id));
  };

  const handleTransmit = async () => {
    if (scannedContenants.length === 0) {
      Alert.alert('Attention', 'Aucun contenant scanné à transmettre.');
      return;
    }

    setLoading(true);

    try {
      // Vérifier et afficher les données de la session pour le débogage
      console.log('Données de session:', JSON.stringify(sessionData, null, 2));
      console.log('Données de route:', JSON.stringify(route.params, null, 2));
      
      // Récupérer les données de la tournée et du véhicule avec plus de vérifications
      const tourneeName = sessionData.tournee?.nom || route.params?.tournee?.nom || '';
      const tourneeId = sessionData.tournee?.id || route.params?.tournee?.id || '';
      const vehiculeName = sessionData.vehicule?.immatriculation || route.params?.vehicule?.immatriculation || '';
      const vehiculeId = sessionData.vehicule?.id || route.params?.vehicule?.id || '';
      
      // Utiliser les détails du site validé s'ils sont disponibles
      let siteName, siteId, siteAdresse, siteCodePostal, siteVille;
      
      if (siteDetails) {
        // Utiliser les bonnes clés du siteDetails (nommage uniforme)
        siteName = siteDetails.name || siteCode;
        siteId = siteDetails.id || '';
        siteAdresse = siteDetails.address || '';
        siteCodePostal = siteDetails.codePostal || '';
        siteVille = siteDetails.city || '';
      } else {
        // Sinon on utilise ce qu'on a par défaut
        siteName = sessionData.tournee?.siteDepart || route.params?.tournee?.siteDepart || siteCode || 'Non spécifié';
        siteId = '';
      }
      
      console.log('Données récupérées pour les scans:', {
        tourneeName,
        tourneeId,
        vehiculeName,
        vehiculeId,
        siteName,
        siteId,
        siteCode
      });

      // Récupérer l'ID de session actuel
      const currentSessionId = await AsyncStorage.getItem('currentSessionId') || `session_${Date.now()}`;
      
      // Préparer les scans avec tous les champs nécessaires
      const scansToSubmit = scannedContenants.map(scan => {
        const scanDate = scan.scanDate || new Date().toISOString();
        
        // Le code du contenant devient l'ID du colis
        const scanItem = {
          code: scan.code,
          idColis: scan.code || scan.idColis,
          scanDate: scanDate,
          tournee: tourneeName,
          tourneeId: tourneeId,
          vehicule: vehiculeName,
          vehiculeId: vehiculeId,
          immatriculation: vehiculeName,
          site: siteName,
          siteId: siteId,
          siteCode: siteCode,
          siteDepart: siteName,
          siteDépart: siteName,
          sessionId: currentSessionId, // Ajouter l'ID de session pour le filtrage ultérieur
          operationType: scan.type || 'entree', // Ajout du type d'opération
          status: scan.type === 'sortie' ? 'livré' : 'en-cours', // Status basé sur le type d'opération
          type: scan.type || 'entree' // Assurer que le type est inclus explicitement
        };
        
        // Ajouter siteFin uniquement pour les colis livrés
        if (scan.type === 'sortie') {
          // Pour les opérations de sortie (dépôt), ajouter des informations spécifiques
          const currentDate = new Date();
          
          // Utiliser le nom du site actuel comme site d'arrivée
          scanItem.siteFin = siteName;
          // Ajouter date et heure d'arrivée au format correct
          scanItem.dateArrivee = currentDate.toLocaleDateString();
          scanItem.heureArrivee = currentDate.toLocaleTimeString();
          // Ajouter ces champs supplémentaires pour assurer la compatibilité
          scanItem.dateHeureFin = currentDate.toISOString();
          scanItem.statut = 'Livré';
          scanItem.status = 'livré'; // Assurez-vous que les deux formats sont présents
          scanItem.coursierLivraison = sessionData.coursierCharg || route.params?.coursierCharg || '';
        }
        
        // Ajouter les détails du site s'ils sont disponibles
        if (siteDetails) {
          scanItem.siteDetails = {
            adresse: siteAdresse,
            codePostal: siteCodePostal,
            ville: siteVille
          };
        }

        // Ajouter la localisation si disponible
        if (sessionData.location) {
          scanItem.location = {
            latitude: sessionData.location.coords.latitude,
            longitude: sessionData.location.coords.longitude,
            accuracy: sessionData.location.coords.accuracy
          };
        }

        return scanItem;
      });
      
      // Afficher les données qui seront transmises
      console.log('Transmission des scans:', JSON.stringify(scansToSubmit, null, 2)); // Décommenté pour débogage
      
      // Envoyer les scans à Firebase
      const result = await firebaseService.addScans(scansToSubmit);
      console.log('Résultat de la transmission:', result);
      
      // Si la transmission réussit, mettre à jour l'historique local
      if (result.success) {
        // --- Logique de consolidation --- 
        const updatedScansMap = new Map();
        historicalScans.forEach(scan => {
          // Assurer qu'on a un code pour la clé de la map
          if (scan.code) {
            updatedScansMap.set(scan.code, scan);
          }
        });
        scansToSubmit.forEach(scan => {
          if (scan.code) {
            const originalScan = scannedContenants.find(s => s.code === scan.code);
            const scanForHistory = {
              ...scan,
              timeStamp: originalScan?.timeStamp || dateUtils.formatTime(scan.scanDate),
            };
            updatedScansMap.set(scan.code, scanForHistory);
          }
        });
        const newHistory = Array.from(updatedScansMap.values());
        newHistory.sort((a, b) => {
          const dateA = a.scanDate ? new Date(a.scanDate).getTime() : 0;
          const dateB = b.scanDate ? new Date(b.scanDate).getTime() : 0;
          if (isNaN(dateA) && isNaN(dateB)) return 0;
          if (isNaN(dateA)) return 1;
          if (isNaN(dateB)) return -1;
          return dateB - dateA;
        });
        // --- Fin de la logique de consolidation ---

        // Sauvegarder l'historique consolidé dans AsyncStorage
        await AsyncStorage.setItem('scanHistory', JSON.stringify(newHistory));
        
        // Mise à jour de l'état React DIFFÉRÉE après les interactions
        InteractionManager.runAfterInteractions(() => {
          setHistoricalScans(newHistory);
        });
        
        // Mettre à jour la liste des paquets pris en charge
        if (operationType === 'entree') {
          setTakingCarePackages([...scansToSubmit, ...takingCarePackages]);
        } else if (operationType === 'sortie') {
          const codesDeposited = scansToSubmit.map(scan => scan.code);
          setTakingCarePackages(takingCarePackages.filter(pkg => pkg.code && !codesDeposited.includes(pkg.code)));
        }
        
        // Réinitialiser complètement l'état pour revenir à l'écran de scan de site
        resetScan(); // Cette fonction réinitialise les états de base

        // S'assurer que tous les états sont correctement réinitialisés pour revenir à l'écran initial
        setShowOperationTypeSelection(false);
        setOperationType('entree'); // Réinitialiser à l'entrée de colis par défaut
        
        // Important: Désactiver le chargement AVANT l'alerte
        setLoading(false);
        
        // Afficher l'alerte de succès
        Alert.alert(
          'Succès',
          `${scansToSubmit.length} scan(s) transmis avec succès`,
          [{ text: 'OK' }]
        );
      } else {
        setLoading(false);
        throw new Error(result.error || 'Échec de la transmission');
      }
    } catch (error) {
      console.error('Erreur lors de la transmission:', error);
      setLoading(false);
      Alert.alert('Erreur', `Échec de la transmission: ${error.message}`);
    }
  };

  const resetScan = () => {
    setScanMode('');
    setSiteScanned(false);
    setSiteCode('');
    setScannedContenants([]);
    setManualCodeInput('');
    setSiteDetails(null);
  };

  const navigateToHistory = () => {
    setShowHistoryModal(true);
  };

  // Fonction pour obtenir les détails de la session actuelle
  const getSessionDetails = async () => {
    try {
      const currentSession = await firebaseService.getCurrentSession();
      if (currentSession) {
        setSessionId(currentSession.id);
        setTournee(currentSession.tournee);
        setVehicule(currentSession.vehicule);
        setPole(currentSession.pole);
      }
    } catch (error) {
      console.error("Erreur lors de la récupération de la session:", error);
    }
  };

  // Fonction pour effacer l'historique des scans
  const clearHistoricalScans = async () => {
    try {
      Alert.alert(
        'Effacer l\'historique',
        'Voulez-vous vraiment effacer tout l\'historique des scans?',
        [
          {
            text: 'Annuler',
            style: 'cancel'
          },
          {
            text: 'Effacer',
            onPress: async () => {
              await AsyncStorage.removeItem('scanHistory');
              setHistoricalScans([]);
              Alert.alert('Succès', 'Historique effacé avec succès');
            },
            style: 'destructive'
          }
        ]
      );
    } catch (error) {
      console.error('Erreur lors de l\'effacement de l\'historique:', error);
      Alert.alert('Erreur', 'Impossible d\'effacer l\'historique');
    }
  };

  // Ajout d'une fonction pour effacer explicitement tous les scans de la session actuelle
  const clearCurrentSessionScans = async () => {
    try {
      const currentSessionId = await AsyncStorage.getItem('currentSessionId');
      if (!currentSessionId) {
        Alert.alert('Erreur', 'Impossible de déterminer la session actuelle');
        return;
      }
      
      Alert.alert(
        'Réinitialiser l\'historique',
        'Cette action va supprimer tous les scans associés à votre session actuelle. Continuer?',
        [
          {
            text: 'Annuler',
            style: 'cancel'
          },
          {
            text: 'Supprimer',
            onPress: async () => {
              try {
                // Supprimer les scans associés à la session actuelle
                setLoading(true);
                console.log(`Suppression des scans de la session ${currentSessionId}...`);
                
                // Fonction côté service qui devrait être implémentée
                // pour supprimer tous les scans de la session
                const result = await firebaseService.clearSessionScans(currentSessionId);
                
                // Supprimer l'historique local également
                await AsyncStorage.removeItem('scanHistory');
                setHistoricalScans([]);
                
                setLoading(false);
                Alert.alert('Succès', 'Historique réinitialisé avec succès');
              } catch (error) {
                setLoading(false);
                console.error('Erreur lors de la suppression des scans:', error);
                Alert.alert('Erreur', `Échec de la suppression: ${error.message}`);
              }
            },
            style: 'destructive'
          }
        ]
      );
    } catch (error) {
      console.error('Erreur:', error);
      Alert.alert('Erreur', 'Une erreur est survenue');
    }
  };

  // Handler de déconnexion avec effacement complet de l'historique
  const handleLogout = async () => {
    try {
      Alert.alert(
        'Déconnexion',
        'Voulez-vous vous déconnecter? L\'historique des scans sera effacé.',
        [
          {
            text: 'Annuler',
            style: 'cancel'
          },
          {
            text: 'Déconnecter',
            onPress: async () => {
              try {
                setLoading(true);
                console.log('Déconnexion en cours...');

                // Appeler la méthode de déconnexion de Firebase
                await firebaseService.logout();
                console.log('Déconnexion Firebase réussie');
                
                // Effacer toutes les données de session
                await AsyncStorage.removeItem('userSessionActive');
                // On conserve current_session_id pour que la tournée visitée reste en mémoire
                await AsyncStorage.removeItem('scanHistory');
                await AsyncStorage.removeItem('user_selas_id');
                
                // Réinitialiser les états
                setHistoricalScans([]);
                setScannedContenants([]);
                setSiteScanned(false);
                setSiteCode('');
                
                setLoading(false);
                
                // Rediriger vers l'écran de connexion
                navigation.reset({
                  index: 0,
                  routes: [{ name: 'Login' }]
                });
              } catch (error) {
                setLoading(false);
                console.error('Erreur lors du processus de déconnexion:', error);
                Alert.alert('Erreur', 'Impossible de se déconnecter. Veuillez réessayer.');
              }
            }
          }
        ]
      );
    } catch (error) {
      console.error('Erreur lors de la déconnexion:', error);
    }
  };

  // Utiliser directement les fonctions de formatage de dateUtils
  // au lieu de redéfinir des fonctions similaires

  // Effet pour écouter les événements de scan Zebra
  useEffect(() => {
    if (isReadyForScan) {
      // Afficher un message pour indiquer que l'application est prête pour le scan
      console.log('Prêt à recevoir des scans du scanner Zebra');
      
      // Configuration pour recevoir les scans du matériel Zebra
      const handleZebraScan = (event) => {
        // Le scanner Zebra envoie généralement les données comme des entrées clavier
        // Nous devons vérifier que nous sommes en mode scan et traiter les données
        if (event && event.nativeEvent && event.nativeEvent.key === 'Enter' && scanMode) {
          // Récupérer le texte scanné (par exemple depuis un champ de texte caché ou via une API Zebra)
          // Pour les besoins de cet exemple, nous utiliserons la valeur de manualCodeInput
          if (manualCodeInput.trim()) {
            processScannedData(manualCodeInput.trim());
            setManualCodeInput(''); // Réinitialiser après le traitement
          }
        }
      };
      
      // Ajoutez ici l'initialisation spécifique au scanner Zebra si nécessaire
      // Exemple : ZebraScanner.initialize() si une API Zebra est disponible
      
      // Pour cet exemple, on simule en utilisant l'écouteur de clavier (pour Enter)
      Keyboard.addListener('keyDown', handleZebraScan);
      
      return () => {
        // Nettoyage lors du démontage
        Keyboard.removeListener('keyDown', handleZebraScan);
        // Désinitialiser le scanner Zebra si nécessaire
        // Exemple : ZebraScanner.deinitialize()
      };
    }
  }, [isReadyForScan, scanMode, manualCodeInput]);


  const loadHistoricalScans = async () => {
    try {
      const jsonValue = await AsyncStorage.getItem('scanHistory');
      if (jsonValue !== null) {
        const history = JSON.parse(jsonValue);
        
        // Récupérer l'ID de la tournée actuelle
        const currentSession = await firebaseService.getCurrentSession();
        const currentTourneeId = currentSession?.tournee?.id || sessionData?.tournee?.id || '';
        
        // Filtrer l'historique local
        const today = new Date();
        today.setHours(0, 0, 0, 0); // Début de la journée
        
        const filteredHistory = history.filter(item => {
          // Convertir la date de l'item en objet Date
          let itemDate;
          try {
            itemDate = new Date(item.date);
            if (isNaN(itemDate.getTime())) {
              // Si la date n'est pas valide, essayer un autre format
              const parts = item.date.split('/');
              if (parts.length === 3) {
                itemDate = new Date(parts[2], parts[1] - 1, parts[0]);
              }
            }
          } catch (e) {
            // En cas d'erreur, considérer cet item comme non valide pour le filtre
            return false;
          }

          // S'assurer que nous avons une date valide
          if (!itemDate || isNaN(itemDate.getTime())) return false;
          
          itemDate.setHours(0, 0, 0, 0); // Normaliser à minuit
          
          // Vérifier la tournée
          const isSameTournee = !currentTourneeId || item.tourneeId === currentTourneeId;
          
          // Vérifier le statut (inclut les visites sans colis)
          const hasValidStatus = item.status === 'en-cours' || item.status === 'livré';
          
          // L'item doit être du jour courant ET de la même tournée ET avoir un statut valide
          return itemDate.getTime() === today.getTime() && isSameTournee && hasValidStatus;
        });
        
        console.log(`Historique local filtré: ${filteredHistory.length} scans (jour + tournée + statut)`);
        
        // Consolider l'historique filtré avant de mettre à jour l'état
        const consolidatedHistory = consolidateAndSortScans([], filteredHistory);

        // Enrichir avec le nom complet du site depuis Firestore
        const enrichedHistory = await Promise.all(
          consolidatedHistory.map(async (scan) => {
            // Tenter de récupérer les détails du site en utilisant siteId ou code
            try {
              const siteIdentifier = scan.siteId || scan.code; // Utiliser ID ou code
              // Vérifier si l'identifiant est probablement un site avant d'appeler getSiteById
              if (siteIdentifier && 
                  !siteIdentifier.startsWith('TEST_CONTENANT_') && 
                  !siteIdentifier.match(/^[0-9]{13,}$/)) { 
                const siteInfo = await firebaseService.getSiteById(siteIdentifier);
                if (siteInfo) {
                  // Enrichir le scan avec les détails complets
                  return { 
                    ...scan, 
                    siteName: siteInfo.nom || siteInfo.name, // Ajouter le nom pour affichage facile
                    siteDetails: { ...siteInfo } 
                  };
                }
              }
            } catch (e) {
              console.warn(`[loadHistoricalScans] Erreur récupération détails site pour ${scan.code || scan.id}:`, e);
            }
            // Si non trouvé ou erreur, retourner le scan original
            return scan;
          })
        );
        
        // Mettre à jour l'état avec l'historique enrichi
        setHistoricalScans(enrichedHistory);
        setSessionHistoryLoaded(true);
      }
    } catch (error) {
      console.error('Erreur lors du chargement de l\'historique:', error);
    }
  };

  const loadFirestoreScans = async () => {
    try {
      // On ne charge les scans Firestore que si la session est active
      const userSessionActive = await AsyncStorage.getItem('userSessionActive');
      if (userSessionActive !== 'true') {
        // Si aucune session active, on ne charge pas l'historique Firestore
        return;
      }

      // Récupérer l'ID de session actuel
      const currentSessionId = await AsyncStorage.getItem('currentSessionId');
      console.log('Chargement des scans pour la session:', currentSessionId);

      // Récupérer l'ID de la tournée actuelle
      const currentSession = await firebaseService.getCurrentSession();
      const currentTourneeId = currentSession?.tournee?.id || sessionData?.tournee?.id || '';
      console.log('Tournée actuelle:', currentTourneeId);

      setLoading(true); // Afficher l'indicateur de chargement

      // Récupérer tous les scans de l'utilisateur (sans limite)
      const scans = await firebaseService.getScans();
      
      if (scans && scans.length > 0) {
        // Ne garder que les scans du jour (J0)
        const today = new Date();
        today.setHours(0, 0, 0, 0); // Début de la journée
        
        const filteredScans = scans.filter(scan => {
          // Convertir la date du scan en objet Date
          const scanDate = dateUtils.convertTimestampToDate(scan.scanDate || scan.createdAt);
          if (!scanDate) return false;
          
          // Récupérer juste la date (sans l'heure)
          const scanDateOnly = new Date(scanDate);
          scanDateOnly.setHours(0, 0, 0, 0);
          
          // Vérifier la tournée (si une tournée actuelle est définie)
          const isSameTournee = !currentTourneeId || scan.tourneeId === currentTourneeId;
          
          // Vérifier le statut (inclut "pas_de_colis")
          const hasValidStatus = scan.status === 'en-cours' || scan.status === 'livré';
          
          // Le scan doit être du jour courant ET de la même tournée ET avoir un statut valide
          return scanDateOnly.getTime() === today.getTime() && isSameTournee && hasValidStatus;
        });
        
        // Convertir les scans Firestore filtrés en format compatible avec l'historique local
        const formattedScans = filteredScans.map(scan => {
          // Déduire le statut si manquant, basé sur le type d'opération
          let status = scan.status;
          if (!status) {
            status = scan.operationType === 'sortie' ? 'livré' : 'en-cours';
          }
          
          return {
            id: scan.id || Date.now().toString(),
            code: scan.code,
            timeStamp: dateUtils.formatTime(scan.scanDate || scan.createdAt),
            date: dateUtils.formatDate(scan.scanDate || scan.createdAt),
            site: scan.site,
            fromFirestore: true,
            sessionId: scan.sessionId,
            // Utiliser le statut (corrigé si nécessaire)
            status: status, 
            // S'assurer que le type est aussi présent
            type: scan.operationType || (status === 'livré' ? 'sortie' : 'entree'), 
            tournee: scan.tournee || '',
            tourneeId: scan.tourneeId || '',
            scanDate: scan.scanDate ? dateUtils.convertTimestampToDate(scan.scanDate).toISOString() : (scan.createdAt ? dateUtils.convertTimestampToDate(scan.createdAt).toISOString() : new Date().toISOString()) // Garder une date ISO pour le tri
          };
        });
        
        // Consolider et trier
        const consolidatedScans = consolidateAndSortScans(historicalScans, formattedScans);
        // Enrichir avec le nom complet du site depuis Firestore
        const enrichedScans = await Promise.all(
          consolidatedScans.map(async (scan) => {
            try {
              // Tenter de récupérer les détails du site
              try {
                // Utiliser l'ID du site si disponible, sinon le code barre
                const siteIdentifier = scan.siteId || scan.code; // Assumer que siteId existe
                if (siteIdentifier && 
                    !siteIdentifier.startsWith('TEST_CONTENANT_') && 
                    !siteIdentifier.match(/^[0-9]{13,}$/)) {
                  // Utiliser une variable locale au lieu de réassigner l'état siteDetails
                  const siteInfo = await firebaseService.getSiteById(siteIdentifier); 
                  if (siteInfo) {
                    // Modifier l'objet scan directement
                    scan.siteName = siteInfo.nom || siteInfo.name; // Utiliser le nom du site s'il est trouvé
                    scan.siteDetails = siteInfo; // Ajouter les détails au scan
                  } else {
                     // Si siteInfo est null, indiquer le nom comme code
                     scan.siteName = scan.code; 
                  }
                } else {
                   scan.siteName = scan.code; // Fallback si aucun identifiant
                }
              } catch (siteError) {
                console.warn(`[loadFirestoreScans] Impossible de récupérer les détails du site pour l'identifiant ${scan.siteId || scan.code}:`, siteError);
                scan.siteName = scan.code; // Afficher le code si erreur
              }
              
              // Ne récupérer les informations sur le site que s'il ne s'agit pas d'un conteneur
              if (scan.site && 
                  !scan.site.startsWith('TEST_CONTENANT_') && 
                  !scan.site.match(/^[0-9]{13,}$/)) {
                const siteInfo = await firebaseService.getSiteById(scan.site);
                if (siteInfo) return { ...scan, siteDetails: { ...siteInfo } };
              }
            } catch (e) {
              console.error('Erreur récupération nom site Firestore:', e);
            }
            return scan;
          })
        );
        
        // Mettre à jour l'état avec l'historique enrichi
        setHistoricalScans(enrichedScans);
        setSessionHistoryLoaded(true);
        
        // Sauvegarder également dans AsyncStorage pour la persistance locale temporaire
        await AsyncStorage.setItem('scanHistory', JSON.stringify(enrichedScans));
      }
      
      setLoading(false); // Masquer l'indicateur de chargement
    } catch (error) {
      console.error('Erreur lors du chargement des scans depuis Firestore:', error);
      setLoading(false); // Masquer l'indicateur de chargement en cas d'erreur
    }
  };

  // --- AJOUTER CETTE FONCTION D'AIDE --- 
  // Fonction pour consolider et trier les scans
  const consolidateAndSortScans = (existingScans, newScans) => {
    const map = new Map();

    // Ajouter les scans existants à la map
    existingScans.forEach(scan => {
      if (scan.code) map.set(scan.code, scan);
    });

    // Mettre à jour ou ajouter les nouveaux scans
    newScans.forEach(scan => {
      if (scan.code) map.set(scan.code, scan);
    });

    // Convertir la map en tableau
    const consolidated = Array.from(map.values());

    // Trier
    consolidated.sort((a, b) => {
      const dateA = a.scanDate ? new Date(a.scanDate).getTime() : 0;
      const dateB = b.scanDate ? new Date(b.scanDate).getTime() : 0;
      if (isNaN(dateA) && isNaN(dateB)) return 0;
      if (isNaN(dateA)) return 1;
      if (isNaN(dateB)) return -1;
      return dateB - dateA;
    });

    return consolidated;
  };
  // --- FIN DE L'AJOUT ---

  const loadTakingCarePackages = async () => {
    try {
      const scansEnCours = await firebaseService.getScansEnCours();
      // Filtrer pour exclure les scans "pas_de_colis"
      const filteredScans = scansEnCours.filter(scan => 
        scan.status !== 'pas_de_colis' &&
        !(scan.code && scan.code.startsWith('SITE_'))
      );
      console.log(`✅ ${filteredScans.length} paquet(s) pris en charge récupéré(s) (sans les "pas_de_colis")`);
      setTakingCarePackages(filteredScans);
    } catch (error) {
      console.error('❌ Erreur lors du chargement des paquets pris en charge:', error);
    }
  };

  // 🔹 Simulation d'un scan avec des sites valides
  const simulateScan = () => {
    if (scanMode === 'site') {
      // Sites de test qui seront reconnus comme valides
      const sitesDemoValides = [
        'SITE123',
        'SITE456',
        'SITE789',
        'LAB001',
        '12345'
      ];
      
      // Sélectionner un site aléatoire parmi les sites valides pour la démo
      return sitesDemoValides[Math.floor(Math.random() * sitesDemoValides.length)];
    } else {
      // Si on est en mode sortie (dépôt), on doit scanner un colis déjà pris en charge
      if (operationType === 'sortie') {
        // Vérifier si des colis sont disponibles
        if (takingCarePackages.length > 0) {
          // Sélectionner un colis aléatoire parmi les colis pris en charge
          const randomPackage = takingCarePackages[Math.floor(Math.random() * takingCarePackages.length)];
          return randomPackage.code;
        } else {
          // Aucun colis disponible pour le dépôt - cette condition est gérée dans handleSimulatedScan
          return '';
        }
      } else {
        // Simuler un scan de contenant pour prise en charge
        // Utiliser un préfixe spécifique pour les tests afin de pouvoir les identifier facilement
        const testId = Date.now(); // Utiliser le timestamp actuel pour créer un ID unique
        return `TEST_CONTENANT_${testId}`;
      }
    }
  };

  // Modification pour les tests : fonction mock qui simule verifySiteCode
  const mockVerifySiteCode = async (siteCode) => {
    // Sites de test qui seront automatiquement validés
    const sitesDemoValides = {
      'SITE123': { nom: 'Site Test 1', adresse: '123 Rue Principale', ville: 'Paris', codePostal: '75001' },
      'SITE456': { nom: 'Site Test 2', adresse: '456 Avenue République', ville: 'Lyon', codePostal: '69001' },
      'SITE789': { nom: 'Site Test 3', adresse: '789 Boulevard des Tests', ville: 'Toulouse', codePostal: '31000' },
      '12345': { nom: 'Laboratoire Central', adresse: '12 Rue des Sciences', ville: 'Montpellier', codePostal: '34000' },
      'LAB001': { nom: 'Laboratoire Mobile', adresse: 'Zone Industrielle', ville: 'Bordeaux', codePostal: '33000' }
    };

    // Vérifier si le code scanné est dans notre liste de sites de test
    if (sitesDemoValides[siteCode]) {
      // Retourner une structure simulant la réponse de Firebase
      return {
        valid: true,
        site: {
          id: `mock_${siteCode}`,
          code: siteCode,
          nom: sitesDemoValides[siteCode].nom,
          adresse: sitesDemoValides[siteCode].adresse,
          ville: sitesDemoValides[siteCode].ville,
          codePostal: sitesDemoValides[siteCode].codePostal
        }
      };
    }

    // Si ce n'est pas un site de test, passer à la vérification normale dans Firebase
    return await firebaseService.verifySiteCode(siteCode);
  };

  const processScannedData = async (data) => {
    console.log('Code scanné:', data);
    try {
      // Cas 1: Nous n'avons pas encore scanné de site
      if (!siteScanned && scanMode === 'site') {
        console.log('[processScannedData] Mode: Scan de site. Données:', data);
        const siteVerification = await firebaseService.verifySiteCode(data);
        console.log('[processScannedData] Résultat de verifySiteCode:', JSON.stringify(siteVerification));

        if (siteVerification.site) {
          // Enregistrer les infos du site
          setSiteCode(data);
          setSiteDetails(siteVerification.site);
          // setSiteScanned(true); // Mis plus bas pour ne l'activer qu'après succès
          // setScanMode(''); // Mis plus bas
          // setShowOperationTypeSelection(true); // Mis plus bas

          // --- MODIFIÉ: Ne trouver que le premier site non visité avec ce nom ---
          let occurrenceIndex = null;
          if (tourneeProgressRef.current?.getSitesWithStatus) {
            const sitesList = tourneeProgressRef.current.getSitesWithStatus();
            console.log('[processScannedData] sitesList depuis tourneeProgressRef:', JSON.stringify(sitesList.map(s => ({ id: s.id, name: s.name, visited: s.visited, uniqueDisplayId: s.uniqueDisplayId }))));
            const siteNameToFind = siteVerification.site.nom || siteVerification.site.name;
            console.log('[processScannedData] Nom du site à trouver:', siteNameToFind);

            // Trouver le premier site non visité avec ce nom
            occurrenceIndex = sitesList.findIndex(s => !s.visited && (s.name === siteNameToFind || s.nom === siteNameToFind)); // Ajout de s.nom
            console.log(`[processScannedData] Occurrence index trouvée pour ${siteNameToFind}:`, occurrenceIndex);
            
            // Si aucun site non visité n'est trouvé, ne rien faire
            if (occurrenceIndex === -1) {
              Alert.alert(
                'Site déjà visité ou non trouvé', // Message mis à jour
                'Ce site a déjà été visité, ne fait pas partie de cette tournée, ou son nom ne correspond pas exactement.', // Message mis à jour
                [{ text: 'OK', onPress: () => {
                  // Réinitialiser l'état pour permettre un nouveau scan
                  setSiteScanned(false);
                  setSiteDetails(null);
                  setSiteCode('');
                  setShowOperationTypeSelection(false);
                }}]
              );
              return;
            }
          } else {
            console.warn('[processScannedData] tourneeProgressRef.current.getSitesWithStatus non disponible.');
            Alert.alert('Erreur', 'Impossible de récupérer la liste des sites de la tournée.');
            return;
          }

          // Marquage en session via l'index si trouvé, sinon par site.id
          const identifier = siteVerification.site.id || (siteVerification.site.code || data);
          console.log('[processScannedData] Identifier pour markSiteVisitedInSession:', identifier);
          console.log('[processScannedData] currentSessionId avant appel:', currentSessionId);
          console.log('[processScannedData] occurrenceIndex avant appel:', occurrenceIndex);

          if (!currentSessionId) {
            console.error('[processScannedData] ID de session manquant avant markSiteVisitedInSession');
            Alert.alert('Erreur Critique', 'ID de session manquant. Impossible de continuer.');
            return;
          }
          
          // Ne marquer qu'un seul site à la fois, en utilisant l'index spécifique
          if (occurrenceIndex !== -1 && occurrenceIndex !== null) { // Condition déjà présente, mais on log avant
            const markSuccess = await firebaseService.markSiteVisitedInSession(currentSessionId, identifier, occurrenceIndex);
            console.log('[processScannedData] Résultat de markSiteVisitedInSession:', markSuccess);
            
            if (markSuccess) {
              setSiteScanned(true); // Activer seulement si le marquage Firestore a réussi
              setScanMode(''); 
              setShowOperationTypeSelection(true);

              // Mise à jour du UI local - mettre à jour uniquement le site spécifique
              if (tourneeProgressRef.current?.markSiteAsVisitedLocally) {
                console.log('[processScannedData] Appel de markSiteAsVisitedLocally avec:', identifier, occurrenceIndex);
                await tourneeProgressRef.current.markSiteAsVisitedLocally(identifier, occurrenceIndex); // AJOUT DE AWAIT
                // Temporairement commenté pour tester si la coche se met à jour correctement sans rechargement immédiat
                // await updateTourneeProgress(); 
              } else if (tourneeProgressRef.current?.loadTourneeDetails) {
                console.log('[processScannedData] Appel de loadTourneeDetails(true) car markSiteAsVisitedLocally non dispo.');
                await tourneeProgressRef.current.loadTourneeDetails(true);
              }
            } else {
              Alert.alert('Erreur', 'Échec du marquage du site comme visité dans la session Firestore.');
              // Garder siteScanned à false, etc.
            }
            
            // Si updateTourneeProgress a été commenté, on peut appeler loadHistoricalData ici
            // si c'est nécessaire pour d'autres parties de l'UI non liées à TourneeProgress.
            // Pour l'instant, on isole le problème de la coche.
            // await loadHistoricalData(); 

          } else {
             console.warn('[processScannedData] occurrenceIndex invalide, markSiteVisitedInSession non appelé.');
             // Potentiellement une alerte ici si ce cas ne devrait pas arriver
          }
          return;
        } else { // siteVerification.site est null/undefined
          console.log('[processScannedData] Aucun site valide retourné par verifySiteCode pour le code:', data);
          Alert.alert('Site Inconnu', 'Le code scanné ne correspond à aucun site connu.');
           // Réinitialiser pour permettre un nouveau scan
          setSiteScanned(false);
          setSiteDetails(null);
          setSiteCode('');
          setShowOperationTypeSelection(false);
        }
      }
      
      // Cas 2: Site déjà scanné, nous scannons maintenant un contenant
      if (siteScanned && scanMode === 'contenant') {
        console.log('[processScannedData] Mode: Scan de contenant. Données:', data);
        handleContenantScan(data);
        // Rester en mode scan contenant pour permettre les scans multiples
        setScanMode('contenant');
      }
    } catch (error) {
      console.error('Erreur lors de la gestion du scan:', error);
      setErrorMessage('Erreur: ' + error.message); // Afficher l'erreur à l'utilisateur
      setScanMode(''); // Réinitialiser le mode scan
      // Optionnel: réinitialiser d'autres états si nécessaire
      setSiteScanned(false);
      setSiteDetails(null);
      setSiteCode('');
      setShowOperationTypeSelection(false);
    }
  };

  // Gérer la simulation d'un scan (pour le développement et les tests)
  const handleSimulatedScan = () => {
    // Vérifier si on est en mode sortie sans colis pris en charge
    if (scanMode === 'contenant' && operationType === 'sortie' && takingCarePackages.length === 0) {
      Alert.alert(
        "Aucun colis disponible",
        "Vous n'avez aucun colis en prise en charge à déposer.",
        [{ text: "OK" }]
      );
      return;
    }
    
    const fakeData = simulateScan();
    if (fakeData) {
      console.log(`Simulation de scan avec données: ${fakeData}`);
    processScannedData(fakeData);
    } else {
      console.error("Erreur lors de la simulation du scan: aucune donnée générée");
      Alert.alert(
        "Erreur",
        "Impossible de simuler un scan. Veuillez réessayer.",
        [{ text: "OK" }]
      );
    }
  };

  const handleManualScan = () => {
    if (manualCodeInput.trim() === '') {
      Alert.alert('Erreur', 'Veuillez entrer un code valide');
      return;
    }
    
    processScannedData(manualCodeInput.trim());
    setManualCodeInput('');
  };

  const activateSiteScan = () => {
    setScanMode('site');
    setErrorMessage('');
    setIsReadyForScan(true);
    
    // Montrer une alerte avec plusieurs options pour scanner
    Alert.alert(
      "Scanner un site",
      "Comment souhaitez-vous scanner le site ?",
      [
        {
          text: "Scanner manuellement",
          onPress: () => showManualSiteInput()
        },
        {
          text: "Simuler scan",
          onPress: handleSimulatedScan
        },
        {
          text: "Annuler",
          style: "cancel",
          onPress: () => setScanMode('')
        }
      ]
    );
  };

  // Fonction pour afficher une boîte de dialogue pour saisir manuellement le code du site
  const showManualSiteInput = () => {
    // Utiliser Alert.prompt sur iOS, mais sur Android, cette fonction n'existe pas
    // donc nous utilisons une méthode alternative
    if (Platform.OS === 'ios') {
      Alert.prompt(
        "Scanner site manuellement",
        "Entrez le code ou le nom du site",
        [
          { text: "Annuler", onPress: () => setScanMode(''), style: "cancel" },
          { 
            text: "Scanner", 
            onPress: (code) => {
              if (code && code.trim()) {
                processScannedData(code.trim());
              } else {
                setScanMode('');
                Alert.alert("Erreur", "Veuillez entrer un code de site valide");
              }
            }
          }
        ],
        "plain-text"
      );
    } else {
      // Sur Android, utiliser une solution simple avec TextInput
      Alert.alert(
        "Scanner site manuellement",
        "Entrez le code du site dans le champ de texte en haut de l'écran, puis appuyez sur Scanner",
        [
          { text: "OK" }
        ]
      );
      // Focus sur le champ de saisie manuelle
      // Note: ceci est une approche simplifiée, une solution plus robuste
      // utiliserait un modal personnalisé avec TextInput
      setManualCodeInput('');
      // On garde le mode scan actif pour que le bouton scanner manuel fonctionne
    }
  };

  // Afficher la page de sélection du type d'opération
  const showOperationSelection = () => {
    setShowOperationTypeSelection(true);
  };

  // Commencer le scan de contenant avec un type d'opération spécifique
  const startContenantScan = (type) => {
    setOperationType(type);
    setShowOperationTypeSelection(false);
    setScanMode('contenant');
    setErrorMessage('');
    setIsReadyForScan(true);
    
    // Message différent selon le type d'opération
    const message = type === 'entree' 
      ? "Veuillez scanner le code du contenant à prendre en charge" 
      : "Veuillez scanner le code du contenant à déposer";
    
    Alert.alert(
      type === 'entree' ? "Prise en charge" : "Dépôt",
      message,
      [{ text: "Annuler", onPress: () => setScanMode('') }]
    );
  };

  const handleContenantScan = async (code) => {
    if (!siteScanned) {
      Alert.alert('Erreur', 'Veuillez d\'abord scanner un site');
      return;
    }

    try {
      // Mode dépôt (sortie) - vérifier que le colis est dans la liste des colis pris en charge
      if (operationType === 'sortie') {
        const isInTakingCare = takingCarePackages.some(pkg => pkg.code === code);
        if (!isInTakingCare) {
          Alert.alert(
            "Colis non reconnu",
            "Ce colis ne fait pas partie des colis que vous avez en prise en charge.",
            [{ text: "OK" }]
          );
          return;
        }
        
        // Retirer le colis de la liste des colis pris en charge
        setTakingCarePackages(takingCarePackages.filter(pkg => pkg.code !== code));
      }

      // Obtenir la date actuelle au format approprié
      const currentDate = new Date();
      const currentDateISO = currentDate.toISOString();

      // Ajouter le contenant à la liste
      const newContenant = {
        id: Date.now().toString(),
        code: code,
        idColis: code,
        timeStamp: currentDate.toLocaleTimeString(),
        date: currentDate.toLocaleDateString(),
        scanDate: currentDateISO,
        site: siteCode,
        type: operationType, // Ajout du type d'opération (entrée/sortie)
      };
      
      setScannedContenants([newContenant, ...scannedContenants]);
    } catch (error) {
      console.error('Erreur lors de la gestion du scan:', error);
      setScanMode('');
    }
  };

  const renderScannedItem = ({ item }) => (
    <View style={[styles.contenantItem, item.type === 'sortie' ? styles.contenantItemSortie : styles.contenantItemEntree]}>
      <View style={styles.contenantInfo}>
        <Text style={styles.contenantCode}>{item.code}</Text>
        <View style={styles.contenantTypeRow}>
          <View style={item.type === 'sortie' ? styles.typeTagSortie : styles.typeTagEntree}>
            <Text style={styles.typeTagText}>{item.type === 'sortie' ? 'Dépôt' : 'Prise en charge'}</Text>
          </View>
          <Text style={styles.contenantTime}>{item.timeStamp}</Text>
        </View>
      </View>
      <TouchableOpacity
        style={styles.deleteContenantButton}
        onPress={() => removeScannedContenant(item.id)}
      >
        <Ionicons name="trash-outline" size={20} color="#e74c3c" />
      </TouchableOpacity>
    </View>
  );

  const removeScannedContenant = (id) => {
    setScannedContenants(scannedContenants.filter(contenant => contenant.id !== id));
  };

  const handleTransmit = async () => {
    if (scannedContenants.length === 0) {
      Alert.alert('Attention', 'Aucun contenant scanné à transmettre.');
      return;
    }

    setLoading(true);

    try {
      // Vérifier et afficher les données de la session pour le débogage
      console.log('Données de session:', JSON.stringify(sessionData, null, 2));
      console.log('Données de route:', JSON.stringify(route.params, null, 2));
      
      // Récupérer les données de la tournée et du véhicule avec plus de vérifications
      const tourneeName = sessionData.tournee?.nom || route.params?.tournee?.nom || '';
      const tourneeId = sessionData.tournee?.id || route.params?.tournee?.id || '';
      const vehiculeName = sessionData.vehicule?.immatriculation || route.params?.vehicule?.immatriculation || '';
      const vehiculeId = sessionData.vehicule?.id || route.params?.vehicule?.id || '';
      
      // Utiliser les détails du site validé s'ils sont disponibles
      let siteName, siteId, siteAdresse, siteCodePostal, siteVille;
      
      if (siteDetails) {
        // Utiliser les bonnes clés du siteDetails (nommage uniforme)
        siteName = siteDetails.name || siteCode;
        siteId = siteDetails.id || '';
        siteAdresse = siteDetails.address || '';
        siteCodePostal = siteDetails.codePostal || '';
        siteVille = siteDetails.city || '';
      } else {
        // Sinon on utilise ce qu'on a par défaut
        siteName = sessionData.tournee?.siteDepart || route.params?.tournee?.siteDepart || siteCode || 'Non spécifié';
        siteId = '';
      }
      
      console.log('Données récupérées pour les scans:', {
        tourneeName,
        tourneeId,
        vehiculeName,
        vehiculeId,
        siteName,
        siteId,
        siteCode
      });

      // Récupérer l'ID de session actuel
      const currentSessionId = await AsyncStorage.getItem('currentSessionId') || `session_${Date.now()}`;
      
      // Préparer les scans avec tous les champs nécessaires
      const scansToSubmit = scannedContenants.map(scan => {
        const scanDate = scan.scanDate || new Date().toISOString();
        
        // Le code du contenant devient l'ID du colis
        const scanItem = {
          code: scan.code,
          idColis: scan.code || scan.idColis,
          scanDate: scanDate,
          tournee: tourneeName,
          tourneeId: tourneeId,
          vehicule: vehiculeName,
          vehiculeId: vehiculeId,
          immatriculation: vehiculeName,
          site: siteName,
          siteId: siteId,
          siteCode: siteCode,
          siteDepart: siteName,
          siteDépart: siteName,
          sessionId: currentSessionId, // Ajouter l'ID de session pour le filtrage ultérieur
          operationType: scan.type || 'entree', // Ajout du type d'opération
          status: scan.type === 'sortie' ? 'livré' : 'en-cours', // Status basé sur le type d'opération
          type: scan.type || 'entree' // Assurer que le type est inclus explicitement
        };
        
        // Ajouter siteFin uniquement pour les colis livrés
        if (scan.type === 'sortie') {
          // Pour les opérations de sortie (dépôt), ajouter des informations spécifiques
          const currentDate = new Date();
          
          // Utiliser le nom du site actuel comme site d'arrivée
          scanItem.siteFin = siteName;
          // Ajouter date et heure d'arrivée au format correct
          scanItem.dateArrivee = currentDate.toLocaleDateString();
          scanItem.heureArrivee = currentDate.toLocaleTimeString();
          // Ajouter ces champs supplémentaires pour assurer la compatibilité
          scanItem.dateHeureFin = currentDate.toISOString();
          scanItem.statut = 'Livré';
          scanItem.status = 'livré'; // Assurez-vous que les deux formats sont présents
          scanItem.coursierLivraison = sessionData.coursierCharg || route.params?.coursierCharg || '';
        }
        
        // Ajouter les détails du site s'ils sont disponibles
        if (siteDetails) {
          scanItem.siteDetails = {
            adresse: siteAdresse,
            codePostal: siteCodePostal,
            ville: siteVille
          };
        }

        // Ajouter la localisation si disponible
        if (sessionData.location) {
          scanItem.location = {
            latitude: sessionData.location.coords.latitude,
            longitude: sessionData.location.coords.longitude,
            accuracy: sessionData.location.coords.accuracy
          };
        }

        return scanItem;
      });
      
      // Afficher les données qui seront transmises
      console.log('Transmission des scans:', JSON.stringify(scansToSubmit, null, 2)); // Décommenté pour débogage
      
      // Envoyer les scans à Firebase
      const result = await firebaseService.addScans(scansToSubmit);
      console.log('Résultat de la transmission:', result);
      
      // Si la transmission réussit, mettre à jour l'historique local
      if (result.success) {
        // --- Logique de consolidation --- 
        const updatedScansMap = new Map();
        historicalScans.forEach(scan => {
          // Assurer qu'on a un code pour la clé de la map
          if (scan.code) {
            updatedScansMap.set(scan.code, scan);
          }
        });
        scansToSubmit.forEach(scan => {
          if (scan.code) {
            const originalScan = scannedContenants.find(s => s.code === scan.code);
            const scanForHistory = {
              ...scan,
              timeStamp: originalScan?.timeStamp || dateUtils.formatTime(scan.scanDate),
            };
            updatedScansMap.set(scan.code, scanForHistory);
          }
        });
        const newHistory = Array.from(updatedScansMap.values());
        newHistory.sort((a, b) => {
          const dateA = a.scanDate ? new Date(a.scanDate).getTime() : 0;
          const dateB = b.scanDate ? new Date(b.scanDate).getTime() : 0;
          if (isNaN(dateA) && isNaN(dateB)) return 0;
          if (isNaN(dateA)) return 1;
          if (isNaN(dateB)) return -1;
          return dateB - dateA;
        });
        // --- Fin de la logique de consolidation ---

        // Sauvegarder l'historique consolidé dans AsyncStorage
        await AsyncStorage.setItem('scanHistory', JSON.stringify(newHistory));
        
        // Mise à jour de l'état React DIFFÉRÉE après les interactions
        InteractionManager.runAfterInteractions(() => {
          setHistoricalScans(newHistory);
        });
        
        // Mettre à jour la liste des paquets pris en charge
        if (operationType === 'entree') {
          setTakingCarePackages([...scansToSubmit, ...takingCarePackages]);
        } else if (operationType === 'sortie') {
          const codesDeposited = scansToSubmit.map(scan => scan.code);
          setTakingCarePackages(takingCarePackages.filter(pkg => pkg.code && !codesDeposited.includes(pkg.code)));
        }
        
        // Réinitialiser complètement l'état pour revenir à l'écran de scan de site
        resetScan(); // Cette fonction réinitialise les états de base

        // S'assurer que tous les états sont correctement réinitialisés pour revenir à l'écran initial
        setShowOperationTypeSelection(false);
        setOperationType('entree'); // Réinitialiser à l'entrée de colis par défaut
        
        // Important: Désactiver le chargement AVANT l'alerte
        setLoading(false);
        
        // Afficher l'alerte de succès
        Alert.alert(
          'Succès',
          `${scansToSubmit.length} scan(s) transmis avec succès`,
          [{ text: 'OK' }]
        );
      } else {
        setLoading(false);
        throw new Error(result.error || 'Échec de la transmission');
      }
    } catch (error) {
      console.error('Erreur lors de la transmission:', error);
      setLoading(false);
      Alert.alert('Erreur', `Échec de la transmission: ${error.message}`);
    }
  };

  const resetScan = () => {
    setScanMode('');
    setSiteScanned(false);
    setSiteCode('');
    setScannedContenants([]);
    setManualCodeInput('');
    setSiteDetails(null);
  };

  const navigateToHistory = () => {
    setShowHistoryModal(true);
  };

  // Fonction pour obtenir les détails de la session actuelle
  const getSessionDetails = async () => {
    try {
      const currentSession = await firebaseService.getCurrentSession();
      if (currentSession) {
        setSessionId(currentSession.id);
        setTournee(currentSession.tournee);
        setVehicule(currentSession.vehicule);
        setPole(currentSession.pole);
      }
    } catch (error) {
      console.error("Erreur lors de la récupération de la session:", error);
    }
  };

  // Fonction pour effacer l'historique des scans
  const clearHistoricalScans = async () => {
    try {
      Alert.alert(
        'Effacer l\'historique',
        'Voulez-vous vraiment effacer tout l\'historique des scans?',
        [
          {
            text: 'Annuler',
            style: 'cancel'
          },
          {
            text: 'Effacer',
            onPress: async () => {
              await AsyncStorage.removeItem('scanHistory');
              setHistoricalScans([]);
              Alert.alert('Succès', 'Historique effacé avec succès');
            },
            style: 'destructive'
          }
        ]
      );
    } catch (error) {
      console.error('Erreur lors de l\'effacement de l\'historique:', error);
      Alert.alert('Erreur', 'Impossible d\'effacer l\'historique');
    }
  };

  // Ajout d'une fonction pour effacer explicitement tous les scans de la session actuelle
  const clearCurrentSessionScans = async () => {
    try {
      const currentSessionId = await AsyncStorage.getItem('currentSessionId');
      if (!currentSessionId) {
        Alert.alert('Erreur', 'Impossible de déterminer la session actuelle');
        return;
      }
      
      Alert.alert(
        'Réinitialiser l\'historique',
        'Cette action va supprimer tous les scans associés à votre session actuelle. Continuer?',
        [
          {
            text: 'Annuler',
            style: 'cancel'
          },
          {
            text: 'Supprimer',
            onPress: async () => {
              try {
                // Supprimer les scans associés à la session actuelle
                setLoading(true);
                console.log(`Suppression des scans de la session ${currentSessionId}...`);
                
                // Fonction côté service qui devrait être implémentée
                // pour supprimer tous les scans de la session
                const result = await firebaseService.clearSessionScans(currentSessionId);
                
                // Supprimer l'historique local également
                await AsyncStorage.removeItem('scanHistory');
                setHistoricalScans([]);
                
                setLoading(false);
                Alert.alert('Succès', 'Historique réinitialisé avec succès');
              } catch (error) {
                setLoading(false);
                console.error('Erreur lors de la suppression des scans:', error);
                Alert.alert('Erreur', `Échec de la suppression: ${error.message}`);
              }
            },
            style: 'destructive'
          }
        ]
      );
    } catch (error) {
      console.error('Erreur:', error);
      Alert.alert('Erreur', 'Une erreur est survenue');
    }
  };

  // Handler de déconnexion avec effacement complet de l'historique
  const handleLogout = async () => {
    try {
      Alert.alert(
        'Déconnexion',
        'Voulez-vous vous déconnecter? L\'historique des scans sera effacé.',
        [
          {
            text: 'Annuler',
            style: 'cancel'
          },
          {
            text: 'Déconnecter',
            onPress: async () => {
              try {
                setLoading(true);
                console.log('Déconnexion en cours...');

                // Appeler la méthode de déconnexion de Firebase
                await firebaseService.logout();
                console.log('Déconnexion Firebase réussie');
                
                // Effacer toutes les données de session
                await AsyncStorage.removeItem('userSessionActive');
                // On conserve current_session_id pour que la tournée visitée reste en mémoire
                await AsyncStorage.removeItem('scanHistory');
                await AsyncStorage.removeItem('user_selas_id');
                
                // Réinitialiser les états
                setHistoricalScans([]);
                setScannedContenants([]);
                setSiteScanned(false);
                setSiteCode('');
                
                setLoading(false);
                
                // Rediriger vers l'écran de connexion
                navigation.reset({
                  index: 0,
                  routes: [{ name: 'Login' }]
                });
              } catch (error) {
                setLoading(false);
                console.error('Erreur lors du processus de déconnexion:', error);
                Alert.alert('Erreur', 'Impossible de se déconnecter. Veuillez réessayer.');
              }
            }
          }
        ]
      );
    } catch (error) {
      console.error('Erreur lors de la déconnexion:', error);
    }
  };

  // Utiliser directement les fonctions de formatage de dateUtils
  // au lieu de redéfinir des fonctions similaires

  // Effet pour écouter les événements de scan Zebra
  useEffect(() => {
    if (isReadyForScan) {
      // Afficher un message pour indiquer que l'application est prête pour le scan
      console.log('Prêt à recevoir des scans du scanner Zebra');
      
      // Configuration pour recevoir les scans du matériel Zebra
      const handleZebraScan = (event) => {
        // Le scanner Zebra envoie généralement les données comme des entrées clavier
        // Nous devons vérifier que nous sommes en mode scan et traiter les données
        if (event && event.nativeEvent && event.nativeEvent.key === 'Enter' && scanMode) {
          // Récupérer le texte scanné (par exemple depuis un champ de texte caché ou via une API Zebra)
          // Pour les besoins de cet exemple, nous utiliserons la valeur de manualCodeInput
          if (manualCodeInput.trim()) {
            processScannedData(manualCodeInput.trim());
            setManualCodeInput(''); // Réinitialiser après le traitement
          }
        }
      };
      
      // Ajoutez ici l'initialisation spécifique au scanner Zebra si nécessaire
      // Exemple : ZebraScanner.initialize() si une API Zebra est disponible
      
      // Pour cet exemple, on simule en utilisant l'écouteur de clavier (pour Enter)
      Keyboard.addListener('keyDown', handleZebraScan);
      
      return () => {
        // Nettoyage lors du démontage
        Keyboard.removeListener('keyDown', handleZebraScan);
        // Désinitialiser le scanner Zebra si nécessaire
        // Exemple : ZebraScanner.deinitialize()
      };
    }
  }, [isReadyForScan, scanMode, manualCodeInput]);


  const loadHistoricalScans = async () => {
    try {
      const jsonValue = await AsyncStorage.getItem('scanHistory');
      if (jsonValue !== null) {
        const history = JSON.parse(jsonValue);
        
        // Récupérer l'ID de la tournée actuelle
        const currentSession = await firebaseService.getCurrentSession();
        const currentTourneeId = currentSession?.tournee?.id || sessionData?.tournee?.id || '';
        
        // Filtrer l'historique local
        const today = new Date();
        today.setHours(0, 0, 0, 0); // Début de la journée
        
        const filteredHistory = history.filter(item => {
          // Convertir la date de l'item en objet Date
          let itemDate;
          try {
            itemDate = new Date(item.date);
            if (isNaN(itemDate.getTime())) {
              // Si la date n'est pas valide, essayer un autre format
              const parts = item.date.split('/');
              if (parts.length === 3) {
                itemDate = new Date(parts[2], parts[1] - 1, parts[0]);
              }
            }
          } catch (e) {
            // En cas d'erreur, considérer cet item comme non valide pour le filtre
            return false;
          }

          // S'assurer que nous avons une date valide
          if (!itemDate || isNaN(itemDate.getTime())) return false;
          
          itemDate.setHours(0, 0, 0, 0); // Normaliser à minuit
          
          // Vérifier la tournée
          const isSameTournee = !currentTourneeId || item.tourneeId === currentTourneeId;
          
          // Vérifier le statut (inclut les visites sans colis)
          const hasValidStatus = item.status === 'en-cours' || item.status === 'livré';
          
          // L'item doit être du jour courant ET de la même tournée ET avoir un statut valide
          return itemDate.getTime() === today.getTime() && isSameTournee && hasValidStatus;
        });
        
        console.log(`Historique local filtré: ${filteredHistory.length} scans (jour + tournée + statut)`);
        
        // Consolider l'historique filtré avant de mettre à jour l'état
        const consolidatedHistory = consolidateAndSortScans([], filteredHistory);

        // Enrichir avec le nom complet du site depuis Firestore
        const enrichedHistory = await Promise.all(
          consolidatedHistory.map(async (scan) => {
            // Tenter de récupérer les détails du site en utilisant siteId ou code
            try {
              const siteIdentifier = scan.siteId || scan.code; // Utiliser ID ou code
              // Vérifier si l'identifiant est probablement un site avant d'appeler getSiteById
              if (siteIdentifier && 
                  !siteIdentifier.startsWith('TEST_CONTENANT_') && 
                  !siteIdentifier.match(/^[0-9]{13,}$/)) { 
                const siteInfo = await firebaseService.getSiteById(siteIdentifier);
                if (siteInfo) {
                  // Enrichir le scan avec les détails complets
                  return { 
                    ...scan, 
                    siteName: siteInfo.nom || siteInfo.name, // Ajouter le nom pour affichage facile
                    siteDetails: { ...siteInfo } 
                  };
                }
              }
            } catch (e) {
              console.warn(`[loadHistoricalScans] Erreur récupération détails site pour ${scan.code || scan.id}:`, e);
            }
            // Si non trouvé ou erreur, retourner le scan original
            return scan;
          })
        );
        
        // Mettre à jour l'état avec l'historique enrichi
        setHistoricalScans(enrichedHistory);
        setSessionHistoryLoaded(true);
      }
    } catch (error) {
      console.error('Erreur lors du chargement de l\'historique:', error);
    }
  };

  const loadFirestoreScans = async () => {
    try {
      // On ne charge les scans Firestore que si la session est active
      const userSessionActive = await AsyncStorage.getItem('userSessionActive');
      if (userSessionActive !== 'true') {
        // Si aucune session active, on ne charge pas l'historique Firestore
        return;
      }

      // Récupérer l'ID de session actuel
      const currentSessionId = await AsyncStorage.getItem('currentSessionId');
      console.log('Chargement des scans pour la session:', currentSessionId);

      // Récupérer l'ID de la tournée actuelle
      const currentSession = await firebaseService.getCurrentSession();
      const currentTourneeId = currentSession?.tournee?.id || sessionData?.tournee?.id || '';
      console.log('Tournée actuelle:', currentTourneeId);

      setLoading(true); // Afficher l'indicateur de chargement

      // Récupérer tous les scans de l'utilisateur (sans limite)
      const scans = await firebaseService.getScans();
      
      if (scans && scans.length > 0) {
        // Ne garder que les scans du jour (J0)
        const today = new Date();
        today.setHours(0, 0, 0, 0); // Début de la journée
        
        const filteredScans = scans.filter(scan => {
          // Convertir la date du scan en objet Date
          const scanDate = dateUtils.convertTimestampToDate(scan.scanDate || scan.createdAt);
          if (!scanDate) return false;
          
          // Récupérer juste la date (sans l'heure)
          const scanDateOnly = new Date(scanDate);
          scanDateOnly.setHours(0, 0, 0, 0);
          
          // Vérifier la tournée (si une tournée actuelle est définie)
          const isSameTournee = !currentTourneeId || scan.tourneeId === currentTourneeId;
          
          // Vérifier le statut (inclut "pas_de_colis")
          const hasValidStatus = scan.status === 'en-cours' || scan.status === 'livré';
          
          // Le scan doit être du jour courant ET de la même tournée ET avoir un statut valide
          return scanDateOnly.getTime() === today.getTime() && isSameTournee && hasValidStatus;
        });
        
        // Convertir les scans Firestore filtrés en format compatible avec l'historique local
        const formattedScans = filteredScans.map(scan => {
          // Déduire le statut si manquant, basé sur le type d'opération
          let status = scan.status;
          if (!status) {
            status = scan.operationType === 'sortie' ? 'livré' : 'en-cours';
          }
          
          return {
            id: scan.id || Date.now().toString(),
            code: scan.code,
            timeStamp: dateUtils.formatTime(scan.scanDate || scan.createdAt),
            date: dateUtils.formatDate(scan.scanDate || scan.createdAt),
            site: scan.site,
            fromFirestore: true,
            sessionId: scan.sessionId,
            // Utiliser le statut (corrigé si nécessaire)
            status: status, 
            // S'assurer que le type est aussi présent
            type: scan.operationType || (status === 'livré' ? 'sortie' : 'entree'), 
            tournee: scan.tournee || '',
            tourneeId: scan.tourneeId || '',
            scanDate: scan.scanDate ? dateUtils.convertTimestampToDate(scan.scanDate).toISOString() : (scan.createdAt ? dateUtils.convertTimestampToDate(scan.createdAt).toISOString() : new Date().toISOString()) // Garder une date ISO pour le tri
          };
        });
        
        // Consolider et trier
        const consolidatedScans = consolidateAndSortScans(historicalScans, formattedScans);
        // Enrichir avec le nom complet du site depuis Firestore
        const enrichedScans = await Promise.all(
          consolidatedScans.map(async (scan) => {
            try {
              // Tenter de récupérer les détails du site
              try {
                // Utiliser l'ID du site si disponible, sinon le code barre
                const siteIdentifier = scan.siteId || scan.code; // Assumer que siteId existe
                if (siteIdentifier && 
                    !siteIdentifier.startsWith('TEST_CONTENANT_') && 
                    !siteIdentifier.match(/^[0-9]{13,}$/)) {
                  // Utiliser une variable locale au lieu de réassigner l'état siteDetails
                  const siteInfo = await firebaseService.getSiteById(siteIdentifier); 
                  if (siteInfo) {
                    // Modifier l'objet scan directement
                    scan.siteName = siteInfo.nom || siteInfo.name; // Utiliser le nom du site s'il est trouvé
                    scan.siteDetails = siteInfo; // Ajouter les détails au scan
                  } else {
                     // Si siteInfo est null, indiquer le nom comme code
                     scan.siteName = scan.code; 
                  }
                } else {
                   scan.siteName = scan.code; // Fallback si aucun identifiant
                }
              } catch (siteError) {
                console.warn(`[loadFirestoreScans] Impossible de récupérer les détails du site pour l'identifiant ${scan.siteId || scan.code}:`, siteError);
                scan.siteName = scan.code; // Afficher le code si erreur
              }
              
              // Ne récupérer les informations sur le site que s'il ne s'agit pas d'un conteneur
              if (scan.site && 
                  !scan.site.startsWith('TEST_CONTENANT_') && 
                  !scan.site.match(/^[0-9]{13,}$/)) {
                const siteInfo = await firebaseService.getSiteById(scan.site);
                if (siteInfo) return { ...scan, siteDetails: { ...siteInfo } };
              }
            } catch (e) {
              console.error('Erreur récupération nom site Firestore:', e);
            }
            return scan;
          })
        );
        
        // Mettre à jour l'état avec l'historique enrichi
        setHistoricalScans(enrichedScans);
        setSessionHistoryLoaded(true);
        
        // Sauvegarder également dans AsyncStorage pour la persistance locale temporaire
        await AsyncStorage.setItem('scanHistory', JSON.stringify(enrichedScans));
      }
      
      setLoading(false); // Masquer l'indicateur de chargement
    } catch (error) {
      console.error('Erreur lors du chargement des scans depuis Firestore:', error);
      setLoading(false); // Masquer l'indicateur de chargement en cas d'erreur
    }
  };

  // --- AJOUTER CETTE FONCTION D'AIDE --- 
  // Fonction pour consolider et trier les scans
  const consolidateAndSortScans = (existingScans, newScans) => {
    const map = new Map();

    // Ajouter les scans existants à la map
    existingScans.forEach(scan => {
      if (scan.code) map.set(scan.code, scan);
    });

    // Mettre à jour ou ajouter les nouveaux scans
    newScans.forEach(scan => {
      if (scan.code) map.set(scan.code, scan);
    });

    // Convertir la map en tableau
    const consolidated = Array.from(map.values());

    // Trier
    consolidated.sort((a, b) => {
      const dateA = a.scanDate ? new Date(a.scanDate).getTime() : 0;
      const dateB = b.scanDate ? new Date(b.scanDate).getTime() : 0;
      if (isNaN(dateA) && isNaN(dateB)) return 0;
      if (isNaN(dateA)) return 1;
      if (isNaN(dateB)) return -1;
      return dateB - dateA;
    });

    return consolidated;
  };
  // --- FIN DE L'AJOUT ---

  const loadTakingCarePackages = async () => {
    try {
      const scansEnCours = await firebaseService.getScansEnCours();
      // Filtrer pour exclure les scans "pas_de_colis"
      const filteredScans = scansEnCours.filter(scan => 
        scan.status !== 'pas_de_colis' &&
        !(scan.code && scan.code.startsWith('SITE_'))
      );
      console.log(`✅ ${filteredScans.length} paquet(s) pris en charge récupéré(s) (sans les "pas_de_colis")`);
      setTakingCarePackages(filteredScans);
    } catch (error) {
      console.error('❌ Erreur lors du chargement des paquets pris en charge:', error);
    }
  };

  // 🔹 Simulation d'un scan avec des sites valides
  const simulateScan = () => {
    if (scanMode === 'site') {
      // Sites de test qui seront reconnus comme valides
      const sitesDemoValides = [
        'SITE123',
        'SITE456',
        'SITE789',
        'LAB001',
        '12345'
      ];
      
      // Sélectionner un site aléatoire parmi les sites valides pour la démo
      return sitesDemoValides[Math.floor(Math.random() * sitesDemoValides.length)];
    } else {
      // Si on est en mode sortie (dépôt), on doit scanner un colis déjà pris en charge
      if (operationType === 'sortie') {
        // Vérifier si des colis sont disponibles
        if (takingCarePackages.length > 0) {
          // Sélectionner un colis aléatoire parmi les colis pris en charge
          const randomPackage = takingCarePackages[Math.floor(Math.random() * takingCarePackages.length)];
          return randomPackage.code;
        } else {
          // Aucun colis disponible pour le dépôt - cette condition est gérée dans handleSimulatedScan
          return '';
        }
      } else {
        // Simuler un scan de contenant pour prise en charge
        // Utiliser un préfixe spécifique pour les tests afin de pouvoir les identifier facilement
        const testId = Date.now(); // Utiliser le timestamp actuel pour créer un ID unique
        return `TEST_CONTENANT_${testId}`;
      }
    }
  };

  // Modification pour les tests : fonction mock qui simule verifySiteCode
  const mockVerifySiteCode = async (siteCode) => {
    // Sites de test qui seront automatiquement validés
    const sitesDemoValides = {
      'SITE123': { nom: 'Site Test 1', adresse: '123 Rue Principale', ville: 'Paris', codePostal: '75001' },
      'SITE456': { nom: 'Site Test 2', adresse: '456 Avenue République', ville: 'Lyon', codePostal: '69001' },
      'SITE789': { nom: 'Site Test 3', adresse: '789 Boulevard des Tests', ville: 'Toulouse', codePostal: '31000' },
      '12345': { nom: 'Laboratoire Central', adresse: '12 Rue des Sciences', ville: 'Montpellier', codePostal: '34000' },
      'LAB001': { nom: 'Laboratoire Mobile', adresse: 'Zone Industrielle', ville: 'Bordeaux', codePostal: '33000' }
    };

    // Vérifier si le code scanné est dans notre liste de sites de test
    if (sitesDemoValides[siteCode]) {
      // Retourner une structure simulant la réponse de Firebase
      return {
        valid: true,
        site: {
          id: `mock_${siteCode}`,
          code: siteCode,
          nom: sitesDemoValides[siteCode].nom,
          adresse: sitesDemoValides[siteCode].adresse,
          ville: sitesDemoValides[siteCode].ville,
          codePostal: sitesDemoValides[siteCode].codePostal
        }
      };
    }

    // Si ce n'est pas un site de test, passer à la vérification normale dans Firebase
    return await firebaseService.verifySiteCode(siteCode);
  };

  const processScannedData = async (data) => {
    console.log('Code scanné:', data);
    try {
      // Cas 1: Nous n'avons pas encore scanné de site
      if (!siteScanned && scanMode === 'site') {
        console.log('[processScannedData] Mode: Scan de site. Données:', data);
        const siteVerification = await firebaseService.verifySiteCode(data);
        console.log('[processScannedData] Résultat de verifySiteCode:', JSON.stringify(siteVerification));

        if (siteVerification.site) {
          // Enregistrer les infos du site
          setSiteCode(data);
          setSiteDetails(siteVerification.site);
          // setSiteScanned(true); // Mis plus bas pour ne l'activer qu'après succès
          // setScanMode(''); // Mis plus bas
          // setShowOperationTypeSelection(true); // Mis plus bas

          // --- MODIFIÉ: Ne trouver que le premier site non visité avec ce nom ---
          let occurrenceIndex = null;
          if (tourneeProgressRef.current?.getSitesWithStatus) {
            const sitesList = tourneeProgressRef.current.getSitesWithStatus();
            console.log('[processScannedData] sitesList depuis tourneeProgressRef:', JSON.stringify(sitesList.map(s => ({ id: s.id, name: s.name, visited: s.visited, uniqueDisplayId: s.uniqueDisplayId }))));
            const siteNameToFind = siteVerification.site.nom || siteVerification.site.name;
            console.log('[processScannedData] Nom du site à trouver:', siteNameToFind);

            // Trouver le premier site non visité avec ce nom
            occurrenceIndex = sitesList.findIndex(s => !s.visited && (s.name === siteNameToFind || s.nom === siteNameToFind)); // Ajout de s.nom
            console.log(`[processScannedData] Occurrence index trouvée pour ${siteNameToFind}:`, occurrenceIndex);
            
            // Si aucun site non visité n'est trouvé, ne rien faire
            if (occurrenceIndex === -1) {
              Alert.alert(
                'Site déjà visité ou non trouvé', // Message mis à jour
                'Ce site a déjà été visité, ne fait pas partie de cette tournée, ou son nom ne correspond pas exactement.', // Message mis à jour
                [{ text: 'OK', onPress: () => {
                  // Réinitialiser l'état pour permettre un nouveau scan
                  setSiteScanned(false);
                  setSiteDetails(null);
                  setSiteCode('');
                  setShowOperationTypeSelection(false);
                }}]
              );
              return;
            }
          } else {
            console.warn('[processScannedData] tourneeProgressRef.current.getSitesWithStatus non disponible.');
            Alert.alert('Erreur', 'Impossible de récupérer la liste des sites de la tournée.');
            return;
          }

          // Marquage en session via l'index si trouvé, sinon par site.id
          const identifier = siteVerification.site.id || (siteVerification.site.code || data);
          console.log('[processScannedData] Identifier pour markSiteVisitedInSession:', identifier);
          console.log('[processScannedData] currentSessionId avant appel:', currentSessionId);
          console.log('[processScannedData] occurrenceIndex avant appel:', occurrenceIndex);

          if (!currentSessionId) {
            console.error('[processScannedData] ID de session manquant avant markSiteVisitedInSession');
            Alert.alert('Erreur Critique', 'ID de session manquant. Impossible de continuer.');
            return;
          }
          
          // Ne marquer qu'un seul site à la fois, en utilisant l'index spécifique
          if (occurrenceIndex !== -1 && occurrenceIndex !== null) { // Condition déjà présente, mais on log avant
            const markSuccess = await firebaseService.markSiteVisitedInSession(currentSessionId, identifier, occurrenceIndex);
            console.log('[processScannedData] Résultat de markSiteVisitedInSession:', markSuccess);
            
            if (markSuccess) {
              setSiteScanned(true); // Activer seulement si le marquage Firestore a réussi
              setScanMode(''); 
              setShowOperationTypeSelection(true);

              // Mise à jour du UI local - mettre à jour uniquement le site spécifique
              if (tourneeProgressRef.current?.markSiteAsVisitedLocally) {
                console.log('[processScannedData] Appel de markSiteAsVisitedLocally avec:', identifier, occurrenceIndex);
                await tourneeProgressRef.current.markSiteAsVisitedLocally(identifier, occurrenceIndex); // AJOUT DE AWAIT
                // Temporairement commenté pour tester si la coche se met à jour correctement sans rechargement immédiat
                // await updateTourneeProgress(); 
              } else if (tourneeProgressRef.current?.loadTourneeDetails) {
                console.log('[processScannedData] Appel de loadTourneeDetails(true) car markSiteAsVisitedLocally non dispo.');
                await tourneeProgressRef.current.loadTourneeDetails(true);
              }
            } else {
              Alert.alert('Erreur', 'Échec du marquage du site comme visité dans la session Firestore.');
              // Garder siteScanned à false, etc.
            }
            
            // Si updateTourneeProgress a été commenté, on peut appeler loadHistoricalData ici
            // si c'est nécessaire pour d'autres parties de l'UI non liées à TourneeProgress.
            // Pour l'instant, on isole le problème de la coche.
            // await loadHistoricalData(); 

          } else {
             console.warn('[processScannedData] occurrenceIndex invalide, markSiteVisitedInSession non appelé.');
             // Potentiellement une alerte ici si ce cas ne devrait pas arriver
          }
          return;
        } else { // siteVerification.site est null/undefined
          console.log('[processScannedData] Aucun site valide retourné par verifySiteCode pour le code:', data);
          Alert.alert('Site Inconnu', 'Le code scanné ne correspond à aucun site connu.');
           // Réinitialiser pour permettre un nouveau scan
          setSiteScanned(false);
          setSiteDetails(null);
          setSiteCode('');
          setShowOperationTypeSelection(false);
        }
      }
      
      // Cas 2: Site déjà scanné, nous scannons maintenant un contenant
      if (siteScanned && scanMode === 'contenant') {
        console.log('[processScannedData] Mode: Scan de contenant. Données:', data);
        handleContenantScan(data);
        // Rester en mode scan contenant pour permettre les scans multiples
        setScanMode('contenant');
      }
    } catch (error) {
      console.error('Erreur lors de la gestion du scan:', error);
      setErrorMessage('Erreur: ' + error.message); // Afficher l'erreur à l'utilisateur
      setScanMode(''); // Réinitialiser le mode scan
      // Optionnel: réinitialiser d'autres états si nécessaire
      setSiteScanned(false);
      setSiteDetails(null);
      setSiteCode('');
      setShowOperationTypeSelection(false);
    }
  };

  // Gérer la simulation d'un scan (pour le développement et les tests)
  const handleSimulatedScan = () => {
    // Vérifier si on est en mode sortie sans colis pris en charge
    if (scanMode === 'contenant' && operationType === 'sortie' && takingCarePackages.length === 0) {
      Alert.alert(
        "Aucun colis disponible",
        "Vous n'avez aucun colis en prise en charge à déposer.",
        [{ text: "OK" }]
      );
      return;
    }
    
    const fakeData = simulateScan();
    if (fakeData) {
      console.log(`Simulation de scan avec données: ${fakeData}`);
    processScannedData(fakeData);
    } else {
      console.error("Erreur lors de la simulation du scan: aucune donnée générée");
      Alert.alert(
        "Erreur",
        "Impossible de simuler un scan. Veuillez réessayer.",
        [{ text: "OK" }]
      );
    }
  };

  const handleManualScan = () => {
    if (manualCodeInput.trim() === '') {
      Alert.alert('Erreur', 'Veuillez entrer un code valide');
      return;
    }
    
    processScannedData(manualCodeInput.trim());
    setManualCodeInput('');
  };

  const activateSiteScan = () => {
    setScanMode('site');
    setErrorMessage('');
    setIsReadyForScan(true);
    
    // Montrer une alerte avec plusieurs options pour scanner
    Alert.alert(
      "Scanner un site",
      "Comment souhaitez-vous scanner le site ?",
      [
        {
          text: "Scanner manuellement",
          onPress: () => showManualSiteInput()
        },
        {
          text: "Simuler scan",
          onPress: handleSimulatedScan
        },
        {
          text: "Annuler",
          style: "cancel",
          onPress: () => setScanMode('')
        }
      ]
    );
  };

  // Fonction pour afficher une boîte de dialogue pour saisir manuellement le code du site
  const showManualSiteInput = () => {
    // Utiliser Alert.prompt sur iOS, mais sur Android, cette fonction n'existe pas
    // donc nous utilisons une méthode alternative
    if (Platform.OS === 'ios') {
      Alert.prompt(
        "Scanner site manuellement",
        "Entrez le code ou le nom du site",
        [
          { text: "Annuler", onPress: () => setScanMode(''), style: "cancel" },
          { 
            text: "Scanner", 
            onPress: (code) => {
              if (code && code.trim()) {
                processScannedData(code.trim());
              } else {
                setScanMode('');
                Alert.alert("Erreur", "Veuillez entrer un code de site valide");
              }
            }
          }
        ],
        "plain-text"
      );
    } else {
      // Sur Android, utiliser une solution simple avec TextInput
      Alert.alert(
        "Scanner site manuellement",
        "Entrez le code du site dans le champ de texte en haut de l'écran, puis appuyez sur Scanner",
        [
          { text: "OK" }
        ]
      );
      // Focus sur le champ de saisie manuelle
      // Note: ceci est une approche simplifiée, une solution plus robuste
      // utiliserait un modal personnalisé avec TextInput
      setManualCodeInput('');
      // On garde le mode scan actif pour que le bouton scanner manuel fonctionne
    }
  };

  // Afficher la page de sélection du type d'opération
  const showOperationSelection = () => {
    setShowOperationTypeSelection(true);
  };

  // Commencer le scan de contenant avec un type d'opération spécifique
  const startContenantScan = (type) => {
    setOperationType(type);
    setShowOperationTypeSelection(false);
    setScanMode('contenant');
    setErrorMessage('');
    setIsReadyForScan(true);
    
    // Message différent selon le type d'opération
    const message = type === 'entree' 
      ? "Veuillez scanner le code du contenant à prendre en charge" 
      : "Veuillez scanner le code du contenant à déposer";
    
    Alert.alert(
      type === 'entree' ? "Prise en charge" : "Dépôt",
      message,
      [{ text: "Annuler", onPress: () => setScanMode('') }]
    );
  };

  const handleContenantScan = async (code) => {
    if (!siteScanned) {
      Alert.alert('Erreur', 'Veuillez d\'abord scanner un site');
      return;
    }

    try {
      // Mode dépôt (sortie) - vérifier que le colis est dans la liste des colis pris en charge
      if (operationType === 'sortie') {
        const isInTakingCare = takingCarePackages.some(pkg => pkg.code === code);
        if (!isInTakingCare) {
          Alert.alert(
            "Colis non reconnu",
            "Ce colis ne fait pas partie des colis que vous avez en prise en charge.",
            [{ text: "OK" }]
          );
          return;
        }
        
        // Retirer le colis de la liste des colis pris en charge
        setTakingCarePackages(takingCarePackages.filter(pkg => pkg.code !== code));
      }

      // Obtenir la date actuelle au format approprié
      const currentDate = new Date();
      const currentDateISO = currentDate.toISOString();

      // Ajouter le contenant à la liste
      const newContenant = {
        id: Date.now().toString(),
        code: code,
        idColis: code,
        timeStamp: currentDate.toLocaleTimeString(),
        date: currentDate.toLocaleDateString(),
        scanDate: currentDateISO,
        site: siteCode,
        type: operationType, // Ajout du type d'opération (entrée/sortie)
      };
      
      setScannedContenants([newContenant, ...scannedContenants]);
    } catch (error) {
      console.error('Erreur lors de la gestion du scan:', error);
      setScanMode('');
    }
  };

  const renderScannedItem = ({ item }) => (
    <View style={[styles.contenantItem, item.type === 'sortie' ? styles.contenantItemSortie : styles.contenantItemEntree]}>
      <View style={styles.contenantInfo}>
        <Text style={styles.contenantCode}>{item.code}</Text>
        <View style={styles.contenantTypeRow}>
          <View style={item.type === 'sortie' ? styles.typeTagSortie : styles.typeTagEntree}>
            <Text style={styles.typeTagText}>{item.type === 'sortie' ? 'Dépôt' : 'Prise en charge'}</Text>
          </View>
          <Text style={styles.contenantTime}>{item.timeStamp}</Text>
        </View>
      </View>
      <TouchableOpacity
        style={styles.deleteContenantButton}
        onPress={() => removeScannedContenant(item.id)}
      >
        <Ionicons name="trash-outline" size={20} color="#e74c3c" />
      </TouchableOpacity>
    </View>
  );

  const removeScannedContenant = (id) => {
    setScannedContenants(scannedContenants.filter(contenant => contenant.id !== id));
  };

  const handleTransmit = async () => {
    if (scannedContenants.length === 0) {
      Alert.alert('Attention', 'Aucun contenant scanné à transmettre.');
      return;
    }

    setLoading(true);

    try {
      // Vérifier et afficher les données de la session pour le débogage
      console.log('Données de session:', JSON.stringify(sessionData, null, 2));
      console.log('Données de route:', JSON.stringify(route.params, null, 2));
      
      // Récupérer les données de la tournée et du véhicule avec plus de vérifications
      const tourneeName = sessionData.tournee?.nom || route.params?.tournee?.nom || '';
      const tourneeId = sessionData.tournee?.id || route.params?.tournee?.id || '';
      const vehiculeName = sessionData.vehicule?.immatriculation || route.params?.vehicule?.immatriculation || '';
      const vehiculeId = sessionData.vehicule?.id || route.params?.vehicule?.id || '';
      
      // Utiliser les détails du site validé s'ils sont disponibles
      let siteName, siteId, siteAdresse, siteCodePostal, siteVille;
      
      if (siteDetails) {
        // Utiliser les bonnes clés du siteDetails (nommage uniforme)
        siteName = siteDetails.name || siteCode;
        siteId = siteDetails.id || '';
        siteAdresse = siteDetails.address || '';
        siteCodePostal = siteDetails.codePostal || '';
        siteVille = siteDetails.city || '';
      } else {
        // Sinon on utilise ce qu'on a par défaut
        siteName = sessionData.tournee?.siteDepart || route.params?.tournee?.siteDepart || siteCode || 'Non spécifié';
        siteId = '';
      }
      
      console.log('Données récupérées pour les scans:', {
        tourneeName,
        tourneeId,
        vehiculeName,
        vehiculeId,
        siteName,
        siteId,
        siteCode
      });

      // Récupérer l'ID de session actuel
      const currentSessionId = await AsyncStorage.getItem('currentSessionId') || `session_${Date.now()}`;
      
      // Préparer les scans avec tous les champs nécessaires
      const scansToSubmit = scannedContenants.map(scan => {
        const scanDate = scan.scanDate || new Date().toISOString();
        
        // Le code du contenant devient l'ID du colis
        const scanItem = {
          code: scan.code,
          idColis: scan.code || scan.idColis,
          scanDate: scanDate,
          tournee: tourneeName,
          tourneeId: tourneeId,
          vehicule: vehiculeName,
          vehiculeId: vehiculeId,
          immatriculation: vehiculeName,
          site: siteName,
          siteId: siteId,
          siteCode: siteCode,
          siteDepart: siteName,
          siteDépart: siteName,
          sessionId: currentSessionId, // Ajouter l'ID de session pour le filtrage ultérieur
          operationType: scan.type || 'entree', // Ajout du type d'opération
          status: scan.type === 'sortie' ? 'livré' : 'en-cours', // Status basé sur le type d'opération
          type: scan.type || 'entree' // Assurer que le type est inclus explicitement
        };
        
        // Ajouter siteFin uniquement pour les colis livrés
        if (scan.type === 'sortie') {
          // Pour les opérations de sortie (dépôt), ajouter des informations spécifiques
          const currentDate = new Date();
          
          // Utiliser le nom du site actuel comme site d'arrivée
          scanItem.siteFin = siteName;
          // Ajouter date et heure d'arrivée au format correct
          scanItem.dateArrivee = currentDate.toLocaleDateString();
          scanItem.heureArrivee = currentDate.toLocaleTimeString();
          // Ajouter ces champs supplémentaires pour assurer la compatibilité
          scanItem.dateHeureFin = currentDate.toISOString();
          scanItem.statut = 'Livré';
          scanItem.status = 'livré'; // Assurez-vous que les deux formats sont présents
          scanItem.coursierLivraison = sessionData.coursierCharg || route.params?.coursierCharg || '';
        }
        
        // Ajouter les détails du site s'ils sont disponibles
        if (siteDetails) {
          scanItem.siteDetails = {
            adresse: siteAdresse,
            codePostal: siteCodePostal,
            ville: siteVille
          };
        }

        // Ajouter la localisation si disponible
        if (sessionData.location) {
          scanItem.location = {
            latitude: sessionData.location.coords.latitude,
            longitude: sessionData.location.coords.longitude,
            accuracy: sessionData.location.coords.accuracy
          };
        }

        return scanItem;
      });
      
      // Afficher les données qui seront transmises
      console.log('Transmission des scans:', JSON.stringify(scansToSubmit, null, 2)); // Décommenté pour débogage
      
      // Envoyer les scans à Firebase
      const result = await firebaseService.addScans(scansToSubmit);
      console.log('Résultat de la transmission:', result);
      
      // Si la transmission réussit, mettre à jour l'historique local
      if (result.success) {
        // --- Logique de consolidation --- 
        const updatedScansMap = new Map();
        historicalScans.forEach(scan => {
          // Assurer qu'on a un code pour la clé de la map
          if (scan.code) {
            updatedScansMap.set(scan.code, scan);
          }
        });
        scansToSubmit.forEach(scan => {
          if (scan.code) {
            const originalScan = scannedContenants.find(s => s.code === scan.code);
            const scanForHistory = {
              ...scan,
              timeStamp: originalScan?.timeStamp || dateUtils.formatTime(scan.scanDate),
            };
            updatedScansMap.set(scan.code, scanForHistory);
          }
        });
        const newHistory = Array.from(updatedScansMap.values());
        newHistory.sort((a, b) => {
          const dateA = a.scanDate ? new Date(a.scanDate).getTime() : 0;
          const dateB = b.scanDate ? new Date(b.scanDate).getTime() : 0;
          if (isNaN(dateA) && isNaN(dateB)) return 0;
          if (isNaN(dateA)) return 1;
          if (isNaN(dateB)) return -1;
          return dateB - dateA;
        });
        // --- Fin de la logique de consolidation ---

        // Sauvegarder l'historique consolidé dans AsyncStorage
        await AsyncStorage.setItem('scanHistory', JSON.stringify(newHistory));
        
        // Mise à jour de l'état React DIFFÉRÉE après les interactions
        InteractionManager.runAfterInteractions(() => {
          setHistoricalScans(newHistory);
        });
        
        // Mettre à jour la liste des paquets pris en charge
        if (operationType === 'entree') {
          setTakingCarePackages([...scansToSubmit, ...takingCarePackages]);
        } else if (operationType === 'sortie') {
          const codesDeposited = scansToSubmit.map(scan => scan.code);
          setTakingCarePackages(takingCarePackages.filter(pkg => pkg.code && !codesDeposited.includes(pkg.code)));
        }
        
        // Réinitialiser complètement l'état pour revenir à l'écran de scan de site
        resetScan(); // Cette fonction réinitialise les états de base

        // S'assurer que tous les états sont correctement réinitialisés pour revenir à l'écran initial
        setShowOperationTypeSelection(false);
        setOperationType('entree'); // Réinitialiser à l'entrée de colis par défaut
        
        // Important: Désactiver le chargement AVANT l'alerte
        setLoading(false);
        
        // Afficher l'alerte de succès
        Alert.alert(
          'Succès',
          `${scansToSubmit.length} scan(s) transmis avec succès`,
          [{ text: 'OK' }]
        );
      } else {
        setLoading(false);
        throw new Error(result.error || 'Échec de la transmission');
      }
    } catch (error) {
      console.error('Erreur lors de la transmission:', error);
      setLoading(false);
      Alert.alert('Erreur', `Échec de la transmission: ${error.message}`);
    }
  };

  const resetScan = () => {
    setScanMode('');
    setSiteScanned(false);
    setSiteCode('');
    setScannedContenants([]);
    setManualCodeInput('');
    setSiteDetails(null);
  };

  const navigateToHistory = () => {
    setShowHistoryModal(true);
  };

  // Fonction pour obtenir les détails de la session actuelle
  const getSessionDetails = async () => {
    try {
      const currentSession = await firebaseService.getCurrentSession();
      if (currentSession) {
        setSessionId(currentSession.id);
        setTournee(currentSession.tournee);
        setVehicule(currentSession.vehicule);
        setPole(currentSession.pole);
      }
    } catch (error) {
      console.error("Erreur lors de la récupération de la session:", error);
    }
  };

  // Fonction pour effacer l'historique des scans
  const clearHistoricalScans = async () => {
    try {
      Alert.alert(
        'Effacer l\'historique',
        'Voulez-vous vraiment effacer tout l\'historique des scans?',
        [
          {
            text: 'Annuler',
            style: 'cancel'
          },
          {
            text: 'Effacer',
            onPress: async () => {
              await AsyncStorage.removeItem('scanHistory');
              setHistoricalScans([]);
              Alert.alert('Succès', 'Historique effacé avec succès');
            },
            style: 'destructive'
          }
        ]
      );
    } catch (error) {
      console.error('Erreur lors de l\'effacement de l\'historique:', error);
      Alert.alert('Erreur', 'Impossible d\'effacer l\'historique');
    }
  };

  // Ajout d'une fonction pour effacer explicitement tous les scans de la session actuelle
  const clearCurrentSessionScans = async () => {
    try {
      const currentSessionId = await AsyncStorage.getItem('currentSessionId');
      if (!currentSessionId) {
        Alert.alert('Erreur', 'Impossible de déterminer la session actuelle');
        return;
      }
      
      Alert.alert(
        'Réinitialiser l\'historique',
        'Cette action va supprimer tous les scans associés à votre session actuelle. Continuer?',
        [
          {
            text: 'Annuler',
            style: 'cancel'
          },
          {
            text: 'Supprimer',
            onPress: async () => {
              try {
                // Supprimer les scans associés à la session actuelle
                setLoading(true);
                console.log(`Suppression des scans de la session ${currentSessionId}...`);
                
                // Fonction côté service qui devrait être implémentée
                // pour supprimer tous les scans de la session
                const result = await firebaseService.clearSessionScans(currentSessionId);
                
                // Supprimer l'historique local également
                await AsyncStorage.removeItem('scanHistory');
                setHistoricalScans([]);
                
                setLoading(false);
                Alert.alert('Succès', 'Historique réinitialisé avec succès');
              } catch (error) {
                setLoading(false);
                console.error('Erreur lors de la suppression des scans:', error);
                Alert.alert('Erreur', `Échec de la suppression: ${error.message}`);
              }
            },
            style: 'destructive'
          }
        ]
      );
    } catch (error) {
      console.error('Erreur:', error);
      Alert.alert('Erreur', 'Une erreur est survenue');
    }
  };

  // Handler de déconnexion avec effacement complet de l'historique
  const handleLogout = async () => {
    try {
      Alert.alert(
        'Déconnexion',
        'Voulez-vous vous déconnecter? L\'historique des scans sera effacé.',
        [
          {
            text: 'Annuler',
            style: 'cancel'
          },
          {
            text: 'Déconnecter',
            onPress: async () => {
              try {
                setLoading(true);
                console.log('Déconnexion en cours...');

                // Appeler la méthode de déconnexion de Firebase
                await firebaseService.logout();
                console.log('Déconnexion Firebase réussie');
                
                // Effacer toutes les données de session
                await AsyncStorage.removeItem('userSessionActive');
                // On conserve current_session_id pour que la tournée visitée reste en mémoire
                await AsyncStorage.removeItem('scanHistory');
                await AsyncStorage.removeItem('user_selas_id');
                
                // Réinitialiser les états
                setHistoricalScans([]);
                setScannedContenants([]);
                setSiteScanned(false);
                setSiteCode('');
                
                setLoading(false);
                
                // Rediriger vers l'écran de connexion
                navigation.reset({
                  index: 0,
                  routes: [{ name: 'Login' }]
                });
              } catch (error) {
                setLoading(false);
                console.error('Erreur lors du processus de déconnexion:', error);
                Alert.alert('Erreur', 'Impossible de se déconnecter. Veuillez réessayer.');
              }
            }
          }
        ]
      );
    } catch (error) {
      console.error('Erreur lors de la déconnexion:', error);
    }
  };

  // Utiliser directement les fonctions de formatage de dateUtils
  // au lieu de redéfinir des fonctions similaires

  // Effet pour écouter les événements de scan Zebra
  useEffect(() => {
    if (isReadyForScan) {
      // Afficher un message pour indiquer que l'application est prête pour le scan
      console.log('Prêt à recevoir des scans du scanner Zebra');
      
      // Configuration pour recevoir les scans du matériel Zebra
      const handleZebraScan = (event) => {
        // Le scanner Zebra envoie généralement les données comme des entrées clavier
        // Nous devons vérifier que nous sommes en mode scan et traiter les données
        if (event && event.nativeEvent && event.nativeEvent.key === 'Enter' && scanMode) {
          // Récupérer le texte scanné (par exemple depuis un champ de texte caché ou via une API Zebra)
          // Pour les besoins de cet exemple, nous utiliserons la valeur de manualCodeInput
          if (manualCodeInput.trim()) {
            processScannedData(manualCodeInput.trim());
            setManualCodeInput(''); // Réinitialiser après le traitement
          }
        }
      };
      
      // Ajoutez ici l'initialisation spécifique au scanner Zebra si nécessaire
      // Exemple : ZebraScanner.initialize() si une API Zebra est disponible
      
      // Pour cet exemple, on simule en utilisant l'écouteur de clavier (pour Enter)
      Keyboard.addListener('keyDown', handleZebraScan);
      
      return () => {
        // Nettoyage lors du démontage
        Keyboard.removeListener('keyDown', handleZebraScan);
        // Désinitialiser le scanner Zebra si nécessaire
        // Exemple : ZebraScanner.deinitialize()
      };
    }
  }, [isReadyForScan, scanMode, manualCodeInput]);


  const loadHistoricalScans = async () => {
    try {
      const jsonValue = await AsyncStorage.getItem('scanHistory');
      if (jsonValue !== null) {
        const history = JSON.parse(jsonValue);
        
        // Récupérer l'ID de la tournée actuelle
        const currentSession = await firebaseService.getCurrentSession();
        const currentTourneeId = currentSession?.tournee?.id || sessionData?.tournee?.id || '';
        
        // Filtrer l'historique local
        const today = new Date();
        today.setHours(0, 0, 0, 0); // Début de la journée
        
        const filteredHistory = history.filter(item => {
          // Convertir la date de l'item en objet Date
          let itemDate;
          try {
            itemDate = new Date(item.date);
            if (isNaN(itemDate.getTime())) {
              // Si la date n'est pas valide, essayer un autre format
              const parts = item.date.split('/');
              if (parts.length === 3) {
                itemDate = new Date(parts[2], parts[1] - 1, parts[0]);
              }
            }
          } catch (e) {
            // En cas d'erreur, considérer cet item comme non valide pour le filtre
            return false;
          }

          // S'assurer que nous avons une date valide
          if (!itemDate || isNaN(itemDate.getTime())) return false;
          
          itemDate.setHours(0, 0, 0, 0); // Normaliser à minuit
          
          // Vérifier la tournée
          const isSameTournee = !currentTourneeId || item.tourneeId === currentTourneeId;
          
          // Vérifier le statut (inclut les visites sans colis)
          const hasValidStatus = item.status === 'en-cours' || item.status === 'livré';
          
          // L'item doit être du jour courant ET de la même tournée ET avoir un statut valide
          return itemDate.getTime() === today.getTime() && isSameTournee && hasValidStatus;
        });
        
        console.log(`Historique local filtré: ${filteredHistory.length} scans (jour + tournée + statut)`);
        
        // Consolider l'historique filtré avant de mettre à jour l'état
        const consolidatedHistory = consolidateAndSortScans([], filteredHistory);

        // Enrichir avec le nom complet du site depuis Firestore
        const enrichedHistory = await Promise.all(
          consolidatedHistory.map(async (scan) => {
            // Tenter de récupérer les détails du site en utilisant siteId ou code
            try {
              const siteIdentifier = scan.siteId || scan.code; // Utiliser ID ou code
              // Vérifier si l'identifiant est probablement un site avant d'appeler getSiteById
              if (siteIdentifier && 
                  !siteIdentifier.startsWith('TEST_CONTENANT_') && 
                  !siteIdentifier.match(/^[0-9]{13,}$/)) { 
                const siteInfo = await firebaseService.getSiteById(siteIdentifier);
                if (siteInfo) {
                  // Enrichir le scan avec les détails complets
                  return { 
                    ...scan, 
                    siteName: siteInfo.nom || siteInfo.name, // Ajouter le nom pour affichage facile
                    siteDetails: { ...siteInfo } 
                  };
                }
              }
            } catch (e) {
              console.warn(`[loadHistoricalScans] Erreur récupération détails site pour ${scan.code || scan.id}:`, e);
            }
            // Si non trouvé ou erreur, retourner le scan original
            return scan;
          })
        );
        
        // Mettre à jour l'état avec l'historique enrichi
        setHistoricalScans(enrichedHistory);
        setSessionHistoryLoaded(true);
      }
    } catch (error) {
      console.error('Erreur lors du chargement de l\'historique:', error);
    }
  };

  const loadFirestoreScans = async () => {
    try {
      // On ne charge les scans Firestore que si la session est active
      const userSessionActive = await AsyncStorage.getItem('userSessionActive');
      if (userSessionActive !== 'true') {
        // Si aucune session active, on ne charge pas l'historique Firestore
        return;
      }

      // Récupérer l'ID de session actuel
      const currentSessionId = await AsyncStorage.getItem('currentSessionId');
      console.log('Chargement des scans pour la session:', currentSessionId);

      // Récupérer l'ID de la tournée actuelle
      const currentSession = await firebaseService.getCurrentSession();
      const currentTourneeId = currentSession?.tournee?.id || sessionData?.tournee?.id || '';
      console.log('Tournée actuelle:', currentTourneeId);

      setLoading(true); // Afficher l'indicateur de chargement

      // Récupérer tous les scans de l'utilisateur (sans limite)
      const scans = await firebaseService.getScans();
      
      if (scans && scans.length > 0) {
        // Ne garder que les scans du jour (J0)
        const today = new Date();
        today.setHours(0, 0, 0, 0); // Début de la journée
        
        const filteredScans = scans.filter(scan => {
          // Convertir la date du scan en objet Date
          const scanDate = dateUtils.convertTimestampToDate(scan.scanDate || scan.createdAt);
          if (!scanDate) return false;
          
          // Récupérer juste la date (sans l'heure)
          const scanDateOnly = new Date(scanDate);
          scanDateOnly.setHours(0, 0, 0, 0);
          
          // Vérifier la tournée (si une tournée actuelle est définie)
          const isSameTournee = !currentTourneeId || scan.tourneeId === currentTourneeId;
          
          // Vérifier le statut (inclut "pas_de_colis")
          const hasValidStatus = scan.status === 'en-cours' || scan.status === 'livré';
          
          // Le scan doit être du jour courant ET de la même tournée ET avoir un statut valide
          return scanDateOnly.getTime() === today.getTime() && isSameTournee && hasValidStatus;
        });
        
        // Convertir les scans Firestore filtrés en format compatible avec l'historique local
        const formattedScans = filteredScans.map(scan => {
          // Déduire le statut si manquant, basé sur le type d'opération
          let status = scan.status;
          if (!status) {
            status = scan.operationType === 'sortie' ? 'livré' : 'en-cours';
          }
          
          return {
            id: scan.id || Date.now().toString(),
            code: scan.code,
            timeStamp: dateUtils.formatTime(scan.scanDate || scan.createdAt),
            date: dateUtils.formatDate(scan.scanDate || scan.createdAt),
            site: scan.site,
            fromFirestore: true,
            sessionId: scan.sessionId,
            // Utiliser le statut (corrigé si nécessaire)
            status: status, 
            // S'assurer que le type est aussi présent
            type: scan.operationType || (status === 'livré' ? 'sortie' : 'entree'), 
            tournee: scan.tournee || '',
            tourneeId: scan.tourneeId || '',
            scanDate: scan.scanDate ? dateUtils.convertTimestampToDate(scan.scanDate).toISOString() : (scan.createdAt ? dateUtils.convertTimestampToDate(scan.createdAt).toISOString() : new Date().toISOString()) // Garder une date ISO pour le tri
          };
        });
        
        // Consolider et trier
        const consolidatedScans = consolidateAndSortScans(historicalScans, formattedScans);
        // Enrichir avec le nom complet du site depuis Firestore
        const enrichedScans = await Promise.all(
          consolidatedScans.map(async (scan) => {
            try {
              // Tenter de récupérer les détails du site
              try {
                // Utiliser l'ID du site si disponible, sinon le code barre
                const siteIdentifier = scan.siteId || scan.code; // Assumer que siteId existe
                if (siteIdentifier && 
                    !siteIdentifier.startsWith('TEST_CONTENANT_') && 
                    !siteIdentifier.match(/^[0-9]{13,}$/)) {
                  // Utiliser une variable locale au lieu de réassigner l'état siteDetails
                  const siteInfo = await firebaseService.getSiteById(siteIdentifier); 
                  if (siteInfo) {
                    // Modifier l'objet scan directement
                    scan.siteName = siteInfo.nom || siteInfo.name; // Utiliser le nom du site s'il est trouvé
                    scan.siteDetails = siteInfo; // Ajouter les détails au scan
                  } else {
                     // Si siteInfo est null, indiquer le nom comme code
                     scan.siteName = scan.code; 
                  }
                } else {
                   scan.siteName = scan.code; // Fallback si aucun identifiant
                }
              } catch (siteError) {
                console.warn(`[loadFirestoreScans] Impossible de récupérer les détails du site pour l'identifiant ${scan.siteId || scan.code}:`, siteError);
                scan.siteName = scan.code; // Afficher le code si erreur
              }
              
              // Ne récupérer les informations sur le site que s'il ne s'agit pas d'un conteneur
              if (scan.site && 
                  !scan.site.startsWith('TEST_CONTENANT_') && 
                  !scan.site.match(/^[0-9]{13,}$/)) {
                const siteInfo = await firebaseService.getSiteById(scan.site);
                if (siteInfo) return { ...scan, siteDetails: { ...siteInfo } };
              }
            } catch (e) {
              console.error('Erreur récupération nom site Firestore:', e);
            }
            return scan;
          })
        );
        
        // Mettre à jour l'état avec l'historique enrichi
        setHistoricalScans(enrichedScans);
        setSessionHistoryLoaded(true);
        
        // Sauvegarder également dans AsyncStorage pour la persistance locale temporaire
        await AsyncStorage.setItem('scanHistory', JSON.stringify(enrichedScans));
      }
      
      setLoading(false); // Masquer l'indicateur de chargement
    } catch (error) {
      console.error('Erreur lors du chargement des scans depuis Firestore:', error);
      setLoading(false); // Masquer l'indicateur de chargement en cas d'erreur
    }
  };

  // --- AJOUTER CETTE FONCTION D'AIDE --- 
  // Fonction pour consolider et trier les scans
  const consolidateAndSortScans = (existingScans, newScans) => {
    const map = new Map();

    // Ajouter les scans existants à la map
    existingScans.forEach(scan => {
      if (scan.code) map.set(scan.code, scan);
    });

    // Mettre à jour ou ajouter les nouveaux scans
    newScans.forEach(scan => {
      if (scan.code) map.set(scan.code, scan);
    });

    // Convertir la map en tableau
    const consolidated = Array.from(map.values());

    // Trier
    consolidated.sort((a, b) => {
      const dateA = a.scanDate ? new Date(a.scanDate).getTime() : 0;
      const dateB = b.scanDate ? new Date(b.scanDate).getTime() : 0;
      if (isNaN(dateA) && isNaN(dateB)) return 0;
      if (isNaN(dateA)) return 1;
      if (isNaN(dateB)) return -1;
      return dateB - dateA;
    });

    return consolidated;
  };
  // --- FIN DE L'AJOUT ---

  const loadTakingCarePackages = async () => {
    try {
      const scansEnCours = await firebaseService.getScansEnCours();
      // Filtrer pour exclure les scans "pas_de_colis"
      const filteredScans = scansEnCours.filter(scan => 
        scan.status !== 'pas_de_colis' &&
        !(scan.code && scan.code.startsWith('SITE_'))
      );
      console.log(`✅ ${filteredScans.length} paquet(s) pris en charge récupéré(s) (sans les "pas_de_colis")`);
      setTakingCarePackages(filteredScans);
    } catch (error) {
      console.error('❌ Erreur lors du chargement des paquets pris en charge:', error);
    }
  };

  // 🔹 Simulation d'un scan avec des sites valides
  const simulateScan = () => {
    if (scanMode === 'site') {
      // Sites de test qui seront reconnus comme valides
      const sitesDemoValides = [
        'SITE123',
        'SITE456',
        'SITE789',
        'LAB001',
        '12345'
      ];
      
      // Sélectionner un site aléatoire parmi les sites valides pour la démo
      return sitesDemoValides[Math.floor(Math.random() * sitesDemoValides.length)];
    } else {
      // Si on est en mode sortie (dépôt), on doit scanner un colis déjà pris en charge
      if (operationType === 'sortie') {
        // Vérifier si des colis sont disponibles
        if (takingCarePackages.length > 0) {
          // Sélectionner un colis aléatoire parmi les colis pris en charge
          const randomPackage = takingCarePackages[Math.floor(Math.random() * takingCarePackages.length)];
          return randomPackage.code;
        } else {
          // Aucun colis disponible pour le dépôt - cette condition est gérée dans handleSimulatedScan
          return '';
        }
      } else {
        // Simuler un scan de contenant pour prise en charge
        // Utiliser un préfixe spécifique pour les tests afin de pouvoir les identifier facilement
        const testId = Date.now(); // Utiliser le timestamp actuel pour créer un ID unique
        return `TEST_CONTENANT_${testId}`;
      }
    }
  };

  // Modification pour les tests : fonction mock qui simule verifySiteCode
  const mockVerifySiteCode = async (siteCode) => {
    // Sites de test qui seront automatiquement validés
    const sitesDemoValides = {
      'SITE123': { nom: 'Site Test 1', adresse: '123 Rue Principale', ville: 'Paris', codePostal: '75001' },
      'SITE456': { nom: 'Site Test 2', adresse: '456 Avenue République', ville: 'Lyon', codePostal: '69001' },
      'SITE789': { nom: 'Site Test 3', adresse: '789 Boulevard des Tests', ville: 'Toulouse', codePostal: '31000' },
      '12345': { nom: 'Laboratoire Central', adresse: '12 Rue des Sciences', ville: 'Montpellier', codePostal: '34000' },
      'LAB001': { nom: 'Laboratoire Mobile', adresse: 'Zone Industrielle', ville: 'Bordeaux', codePostal: '33000' }
    };

    // Vérifier si le code scanné est dans notre liste de sites de test
    if (sitesDemoValides[siteCode]) {
      // Retourner une structure simulant la réponse de Firebase
      return {
        valid: true,
        site: {
          id: `mock_${siteCode}`,
          code: siteCode,
          nom: sitesDemoValides[siteCode].nom,
          adresse: sitesDemoValides[siteCode].adresse,
          ville: sitesDemoValides[siteCode].ville,
          codePostal: sitesDemoValides[siteCode].codePostal
        }
      };
    }

    // Si ce n'est pas un site de test, passer à la vérification normale dans Firebase
    return await firebaseService.verifySiteCode(siteCode);
  };

  const processScannedData = async (data) => {
    console.log('Code scanné:', data);
    try {
      // Cas 1: Nous n'avons pas encore scanné de site
      if (!siteScanned && scanMode === 'site') {
        console.log('[processScannedData] Mode: Scan de site. Données:', data);
        const siteVerification = await firebaseService.verifySiteCode(data);
        console.log('[processScannedData] Résultat de verifySiteCode:', JSON.stringify(siteVerification));

        if (siteVerification.site) {
          // Enregistrer les infos du site
          setSiteCode(data);
          setSiteDetails(siteVerification.site);
          // setSiteScanned(true); // Mis plus bas pour ne l'activer qu'après succès
          // setScanMode(''); // Mis plus bas
          // setShowOperationTypeSelection(true); // Mis plus bas

          // --- MODIFIÉ: Ne trouver que le premier site non visité avec ce nom ---
          let occurrenceIndex = null;
          if (tourneeProgressRef.current?.getSitesWithStatus) {
            const sitesList = tourneeProgressRef.current.getSitesWithStatus();
            console.log('[processScannedData] sitesList depuis tourneeProgressRef:', JSON.stringify(sitesList.map(s => ({ id: s.id, name: s.name, visited: s.visited, uniqueDisplayId: s.uniqueDisplayId }))));
            const siteNameToFind = siteVerification.site.nom || siteVerification.site.name;
            console.log('[processScannedData] Nom du site à trouver:', siteNameToFind);

            // Trouver le premier site non visité avec ce nom
            occurrenceIndex = sitesList.findIndex(s => !s.visited && (s.name === siteNameToFind || s.nom === siteNameToFind)); // Ajout de s.nom
            console.log(`[processScannedData] Occurrence index trouvée pour ${siteNameToFind}:`, occurrenceIndex);
            
            // Si aucun site non visité n'est trouvé, ne rien faire
            if (occurrenceIndex === -1) {
              Alert.alert(
                'Site déjà visité ou non trouvé', // Message mis à jour
                'Ce site a déjà été visité, ne fait pas partie de cette tournée, ou son nom ne correspond pas exactement.', // Message mis à jour
                [{ text: 'OK', onPress: () => {
                  // Réinitialiser l'état pour permettre un nouveau scan
                  setSiteScanned(false);
                  setSiteDetails(null);
                  setSiteCode('');
                  setShowOperationTypeSelection(false);
                }}]
              );
              return;
            }
          } else {
            console.warn('[processScannedData] tourneeProgressRef.current.getSitesWithStatus non disponible.');
            Alert.alert('Erreur', 'Impossible de récupérer la liste des sites de la tournée.');
            return;
          }

          // Marquage en session via l'index si trouvé, sinon par site.id
          const identifier = siteVerification.site.id || (siteVerification.site.code || data);
          console.log('[processScannedData] Identifier pour markSiteVisitedInSession:', identifier);
          console.log('[processScannedData] currentSessionId avant appel:', currentSessionId);
          console.log('[processScannedData] occurrenceIndex avant appel:', occurrenceIndex);

          if (!currentSessionId) {
            console.error('[processScannedData] ID de session manquant avant markSiteVisitedInSession');
            Alert.alert('Erreur Critique', 'ID de session manquant. Impossible de continuer.');
            return;
          }
          
          // Ne marquer qu'un seul site à la fois, en utilisant l'index spécifique
          if (occurrenceIndex !== -1 && occurrenceIndex !== null) { // Condition déjà présente, mais on log avant
            const markSuccess = await firebaseService.markSiteVisitedInSession(currentSessionId, identifier, occurrenceIndex);
            console.log('[processScannedData] Résultat de markSiteVisitedInSession:', markSuccess);
            
            if (markSuccess) {
              setSiteScanned(true); // Activer seulement si le marquage Firestore a réussi
              setScanMode(''); 
              setShowOperationTypeSelection(true);

              // Mise à jour du UI local - mettre à jour uniquement le site spécifique
              if (tourneeProgressRef.current?.markSiteAsVisitedLocally) {
                console.log('[processScannedData] Appel de markSiteAsVisitedLocally avec:', identifier, occurrenceIndex);
                await tourneeProgressRef.current.markSiteAsVisitedLocally(identifier, occurrenceIndex); // AJOUT DE AWAIT
                // Temporairement commenté pour tester si la coche se met à jour correctement sans rechargement immédiat
                // await updateTourneeProgress(); 
              } else if (tourneeProgressRef.current?.loadTourneeDetails) {
                console.log('[processScannedData] Appel de loadTourneeDetails(true) car markSiteAsVisitedLocally non dispo.');
                await tourneeProgressRef.current.loadTourneeDetails(true);
              }
            } else {
              Alert.alert('Erreur', 'Échec du marquage du site comme visité dans la session Firestore.');
              // Garder siteScanned à false, etc.
            }
            
            // Si updateTourneeProgress a été commenté, on peut appeler loadHistoricalData ici
            // si c'est nécessaire pour d'autres parties de l'UI non liées à TourneeProgress.
            // Pour l'instant, on isole le problème de la coche.
            // await loadHistoricalData(); 

          } else {
             console.warn('[processScannedData] occurrenceIndex invalide, markSiteVisitedInSession non appelé.');
             // Potentiellement une alerte ici si ce cas ne devrait pas arriver
          }
          return;
        } else { // siteVerification.site est null/undefined
          console.log('[processScannedData] Aucun site valide retourné par verifySiteCode pour le code:', data);
          Alert.alert('Site Inconnu', 'Le code scanné ne correspond à aucun site connu.');
           // Réinitialiser pour permettre un nouveau scan
          setSiteScanned(false);
          setSiteDetails(null);
          setSiteCode('');
          setShowOperationTypeSelection(false);
        }
      }
      
      // Cas 2: Site déjà scanné, nous scannons maintenant un contenant
      if (siteScanned && scanMode === 'contenant') {
        console.log('[processScannedData] Mode: Scan de contenant. Données:', data);
        handleContenantScan(data);
        // Rester en mode scan contenant pour permettre les scans multiples
        setScanMode('contenant');
      }
    } catch (error) {
      console.error('Erreur lors de la gestion du scan:', error);
      setErrorMessage('Erreur: ' + error.message); // Afficher l'erreur à l'utilisateur
      setScanMode(''); // Réinitialiser le mode scan
      // Optionnel: réinitialiser d'autres états si nécessaire
      setSiteScanned(false);
      setSiteDetails(null);
      setSiteCode('');
      setShowOperationTypeSelection(false);
    }
  };

  // Gérer la simulation d'un scan (pour le développement et les tests)
  const handleSimulatedScan = () => {
    // Vérifier si on est en mode sortie sans colis pris en charge
    if (scanMode === 'contenant' && operationType === 'sortie' && takingCarePackages.length === 0) {
      Alert.alert(
        "Aucun colis disponible",
        "Vous n'avez aucun colis en prise en charge à déposer.",
        [{ text: "OK" }]
      );
      return;
    }
    
    const fakeData = simulateScan();
    if (fakeData) {
      console.log(`Simulation de scan avec données: ${fakeData}`);
    processScannedData(fakeData);
    } else {
      console.error("Erreur lors de la simulation du scan: aucune donnée générée");
      Alert.alert(
        "Erreur",
        "Impossible de simuler un scan. Veuillez réessayer.",
        [{ text: "OK" }]
      );
    }
  };

  const handleManualScan = () => {
    if (manualCodeInput.trim() === '') {
      Alert.alert('Erreur', 'Veuillez entrer un code valide');
      return;
    }
    
    processScannedData(manualCodeInput.trim());
    setManualCodeInput('');
  };

  const activateSiteScan = () => {
    setScanMode('site');
    setErrorMessage('');
    setIsReadyForScan(true);
    
    // Montrer une alerte avec plusieurs options pour scanner
    Alert.alert(
      "Scanner un site",
      "Comment souhaitez-vous scanner le site ?",
      [
        {
          text: "Scanner manuellement",
          onPress: () => showManualSiteInput()
        },
        {
          text: "Simuler scan",
          onPress: handleSimulatedScan
        },
        {
          text: "Annuler",
          style: "cancel",
          onPress: () => setScanMode('')
        }
      ]
    );
  };

  // Fonction pour afficher une boîte de dialogue pour saisir manuellement le code du site
  const showManualSiteInput = () => {
    // Utiliser Alert.prompt sur iOS, mais sur Android, cette fonction n'existe pas
    // donc nous utilisons une méthode alternative
    if (Platform.OS === 'ios') {
      Alert.prompt(
        "Scanner site manuellement",
        "Entrez le code ou le nom du site",
        [
          { text: "Annuler", onPress: () => setScanMode(''), style: "cancel" },
          { 
            text: "Scanner", 
            onPress: (code) => {
              if (code && code.trim()) {
                processScannedData(code.trim());
              } else {
                setScanMode('');
                Alert.alert("Erreur", "Veuillez entrer un code de site valide");
              }
            }
          }
        ],
        "plain-text"
      );
    } else {
      // Sur Android, utiliser une solution simple avec TextInput
      Alert.alert(
        "Scanner site manuellement",
        "Entrez le code du site dans le champ de texte en haut de l'écran, puis appuyez sur Scanner",
        [
          { text: "OK" }
        ]
      );
      // Focus sur le champ de saisie manuelle
      // Note: ceci est une approche simplifiée, une solution plus robuste
      // utiliserait un modal personnalisé avec TextInput
      setManualCodeInput('');
      // On garde le mode scan actif pour que le bouton scanner manuel fonctionne
    }
  };

  // Afficher la page de sélection du type d'opération
  const showOperationSelection = () => {
    setShowOperationTypeSelection(true);
  };

  // Commencer le scan de contenant avec un type d'opération spécifique
  const startContenantScan = (type) => {
    setOperationType(type);
    setShowOperationTypeSelection(false);
    setScanMode('contenant');
    setErrorMessage('');
    setIsReadyForScan(true);
    
    // Message différent selon le type d'opération
    const message = type === 'entree' 
      ? "Veuillez scanner le code du contenant à prendre en charge" 
      : "Veuillez scanner le code du contenant à déposer";
    
    Alert.alert(
      type === 'entree' ? "Prise en charge" : "Dépôt",
      message,
      [{ text: "Annuler", onPress: () => setScanMode('') }]
    );
  };

  const handleContenantScan = async (code) => {
    if (!siteScanned) {
      Alert.alert('Erreur', 'Veuillez d\'abord scanner un site');
      return;
    }

    try {
      // Mode dépôt (sortie) - vérifier que le colis est dans la liste des colis pris en charge
      if (operationType === 'sortie') {
        const isInTakingCare = takingCarePackages.some(pkg => pkg.code === code);
        if (!isInTakingCare) {
          Alert.alert(
            "Colis non reconnu",
            "Ce colis ne fait pas partie des colis que vous avez en prise en charge.",
            [{ text: "OK" }]
          );
          return;
        }
        
        // Retirer le colis de la liste des colis pris en charge
        setTakingCarePackages(takingCarePackages.filter(pkg => pkg.code !== code));
      }

      // Obtenir la date actuelle au format approprié
      const currentDate = new Date();
      const currentDateISO = currentDate.toISOString();

      // Ajouter le contenant à la liste
      const newContenant = {
        id: Date.now().toString(),
        code: code,
        idColis: code,
        timeStamp: currentDate.toLocaleTimeString(),
        date: currentDate.toLocaleDateString(),
        scanDate: currentDateISO,
        site: siteCode,
        type: operationType, // Ajout du type d'opération (entrée/sortie)
      };
      
      setScannedContenants([newContenant, ...scannedContenants]);
    } catch (error) {
      console.error('Erreur lors de la gestion du scan:', error);
      setScanMode('');
    }
  };

  const renderScannedItem = ({ item }) => (
    <View style={[styles.contenantItem, item.type === 'sortie' ? styles.contenantItemSortie : styles.contenantItemEntree]}>
      <View style={styles.contenantInfo}>
        <Text style={styles.contenantCode}>{item.code}</Text>
        <View style={styles.contenantTypeRow}>
          <View style={item.type === 'sortie' ? styles.typeTagSortie : styles.typeTagEntree}>
            <Text style={styles.typeTagText}>{item.type === 'sortie' ? 'Dépôt' : 'Prise en charge'}</Text>
          </View>
          <Text style={styles.contenantTime}>{item.timeStamp}</Text>
        </View>
      </View>
      <TouchableOpacity
        style={styles.deleteContenantButton}
        onPress={() => removeScannedContenant(item.id)}
      >
        <Ionicons name="trash-outline" size={20} color="#e74c3c" />
      </TouchableOpacity>
    </View>
  );

  const removeScannedContenant = (id) => {
    setScannedContenants(scannedContenants.filter(contenant => contenant.id !== id));
  };

  const handleTransmit = async () => {
    if (scannedContenants.length === 0) {
      Alert.alert('Attention', 'Aucun contenant scanné à transmettre.');
      return;
    }

    setLoading(true);

    try {
      // Vérifier et afficher les données de la session pour le débogage
      console.log('Données de session:', JSON.stringify(sessionData, null, 2));
      console.log('Données de route:', JSON.stringify(route.params, null, 2));
      
      // Récupérer les données de la tournée et du véhicule avec plus de vérifications
      const tourneeName = sessionData.tournee?.nom || route.params?.tournee?.nom || '';
      const tourneeId = sessionData.tournee?.id || route.params?.tournee?.id || '';
      const vehiculeName = sessionData.vehicule?.immatriculation || route.params?.vehicule?.immatriculation || '';
      const vehiculeId = sessionData.vehicule?.id || route.params?.vehicule?.id || '';
      
      // Utiliser les détails du site validé s'ils sont disponibles
      let siteName, siteId, siteAdresse, siteCodePostal, siteVille;
      
      if (siteDetails) {
        // Utiliser les bonnes clés du siteDetails (nommage uniforme)
        siteName = siteDetails.name || siteCode;
        siteId = siteDetails.id || '';
        siteAdresse = siteDetails.address || '';
        siteCodePostal = siteDetails.codePostal || '';
        siteVille = siteDetails.city || '';
      } else {
        // Sinon on utilise ce qu'on a par défaut
        siteName = sessionData.tournee?.siteDepart || route.params?.tournee?.siteDepart || siteCode || 'Non spécifié';
        siteId = '';
      }
      
      console.log('Données récupérées pour les scans:', {
        tourneeName,
        tourneeId,
        vehiculeName,
        vehiculeId,
        siteName,
        siteId,
        siteCode
      });

      // Récupérer l'ID de session actuel
      const currentSessionId = await AsyncStorage.getItem('currentSessionId') || `session_${Date.now()}`;
      
      // Préparer les scans avec tous les champs nécessaires
      const scansToSubmit = scannedContenants.map(scan => {
        const scanDate = scan.scanDate || new Date().toISOString();
        
        // Le code du contenant devient l'ID du colis
        const scanItem = {
          code: scan.code,
          idColis: scan.code || scan.idColis,
          scanDate: scanDate,
          tournee: tourneeName,
          tourneeId: tourneeId,
          vehicule: vehiculeName,
          vehiculeId: vehiculeId,
          immatriculation: vehiculeName,
          site: siteName,
          siteId: siteId,
          siteCode: siteCode,
          siteDepart: siteName,
          siteDépart: siteName,
          sessionId: currentSessionId, // Ajouter l'ID de session pour le filtrage ultérieur
          operationType: scan.type || 'entree', // Ajout du type d'opération
          status: scan.type === 'sortie' ? 'livré' : 'en-cours', // Status basé sur le type d'opération
          type: scan.type || 'entree' // Assurer que le type est inclus explicitement
        };
        
        // Ajouter siteFin uniquement pour les colis livrés
        if (scan.type === 'sortie') {
          // Pour les opérations de sortie (dépôt), ajouter des informations spécifiques
          const currentDate = new Date();
          
          // Utiliser le nom du site actuel comme site d'arrivée
          scanItem.siteFin = siteName;
          // Ajouter date et heure d'arrivée au format correct
          scanItem.dateArrivee = currentDate.toLocaleDateString();
          scanItem.heureArrivee = currentDate.toLocaleTimeString();
          // Ajouter ces champs supplémentaires pour assurer la compatibilité
          scanItem.dateHeureFin = currentDate.toISOString();
          scanItem.statut = 'Livré';
          scanItem.status = 'livré'; // Assurez-vous que les deux formats sont présents
          scanItem.coursierLivraison = sessionData.coursierCharg || route.params?.coursierCharg || '';
        }
        
        // Ajouter les détails du site s'ils sont disponibles
        if (siteDetails) {
          scanItem.siteDetails = {
            adresse: siteAdresse,
            codePostal: siteCodePostal,
            ville: siteVille
          };
        }

        // Ajouter la localisation si disponible
        if (sessionData.location) {
          scanItem.location = {
            latitude: sessionData.location.coords.latitude,
            longitude: sessionData.location.coords.longitude,
            accuracy: sessionData.location.coords.accuracy
          };
        }

        return scanItem;
      });
      
      // Afficher les données qui seront transmises
      console.log('Transmission des scans:', JSON.stringify(scansToSubmit, null, 2)); // Décommenté pour débogage
      
      // Envoyer les scans à Firebase
      const result = await firebaseService.addScans(scansToSubmit);
      console.log('Résultat de la transmission:', result);
      
      // Si la transmission réussit, mettre à jour l'historique local
      if (result.success) {
        // --- Logique de consolidation --- 
        const updatedScansMap = new Map();
        historicalScans.forEach(scan => {
          // Assurer qu'on a un code pour la clé de la map
          if (scan.code) {
            updatedScansMap.set(scan.code, scan);
          }
        });
        scansToSubmit.forEach(scan => {
          if (scan.code) {
            const originalScan = scannedContenants.find(s => s.code === scan.code);
            const scanForHistory = {
              ...scan,
              timeStamp: originalScan?.timeStamp || dateUtils.formatTime(scan.scanDate),
            };
            updatedScansMap.set(scan.code, scanForHistory);
          }
        });
        const newHistory = Array.from(updatedScansMap.values());
        newHistory.sort((a, b) => {
          const dateA = a.scanDate ? new Date(a.scanDate).getTime() : 0;
          const dateB = b.scanDate ? new Date(b.scanDate).getTime() : 0;
          if (isNaN(dateA) && isNaN(dateB)) return 0;
          if (isNaN(dateA)) return 1;
          if (isNaN(dateB)) return -1;
          return dateB - dateA;
        });
        // --- Fin de la logique de consolidation ---

        // Sauvegarder l'historique consolidé dans AsyncStorage
        await AsyncStorage.setItem('scanHistory', JSON.stringify(newHistory));
        
        // Mise à jour de l'état React DIFFÉRÉE après les interactions
        InteractionManager.runAfterInteractions(() => {
          setHistoricalScans(newHistory);
        });
        
        // Mettre à jour la liste des paquets pris en charge
        if (operationType === 'entree') {
          setTakingCarePackages([...scansToSubmit, ...takingCarePackages]);
        } else if (operationType === 'sortie') {
          const codesDeposited = scansToSubmit.map(scan => scan.code);
          setTakingCarePackages(takingCarePackages.filter(pkg => pkg.code && !codesDeposited.includes(pkg.code)));
        }
        
        // Réinitialiser complètement l'état pour revenir à l'écran de scan de site
        resetScan(); // Cette fonction réinitialise les états de base

        // S'assurer que tous les états sont correctement réinitialisés pour revenir à l'écran initial
        setShowOperationTypeSelection(false);
        setOperationType('entree'); // Réinitialiser à l'entrée de colis par défaut
        
        // Important: Désactiver le chargement AVANT l'alerte
        setLoading(false);
        
        // Afficher l'alerte de succès
        Alert.alert(
          'Succès',
          `${scansToSubmit.length} scan(s) transmis avec succès`,
          [{ text: 'OK' }]
        );
      } else {
        setLoading(false);
        throw new Error(result.error || 'Échec de la transmission');
      }
    } catch (error) {
      console.error('Erreur lors de la transmission:', error);
      setLoading(false);
      Alert.alert('Erreur', `Échec de la transmission: ${error.message}`);
    }
  };

  const resetScan = () => {
    setScanMode('');
    setSiteScanned(false);
    setSiteCode('');
    setScannedContenants([]);
    setManualCodeInput('');
    setSiteDetails(null);
  };

  const navigateToHistory = () => {
    setShowHistoryModal(true);
  };

  // Fonction pour obtenir les détails de la session actuelle
  const getSessionDetails = async () => {
    try {
      const currentSession = await firebaseService.getCurrentSession();
      if (currentSession) {
        setSessionId(currentSession.id);
        setTournee(currentSession.tournee);
        setVehicule(currentSession.vehicule);
        setPole(currentSession.pole);
      }
    } catch (error) {
      console.error("Erreur lors de la récupération de la session:", error);
    }
  };

  // Fonction pour effacer l'historique des scans
  const clearHistoricalScans = async () => {
    try {
      Alert.alert(
        'Effacer l\'historique',
        'Voulez-vous vraiment effacer tout l\'historique des scans?',
        [
          {
            text: 'Annuler',
            style: 'cancel'
          },
          {
            text: 'Effacer',
            onPress: async () => {
              await AsyncStorage.removeItem('scanHistory');
              setHistoricalScans([]);
              Alert.alert('Succès', 'Historique effacé avec succès');
            },
            style: 'destructive'
          }
        ]
      );
    } catch (error) {
      console.error('Erreur lors de l\'effacement de l\'historique:', error);
      Alert.alert('Erreur', 'Impossible d\'effacer l\'historique');
    }
  };

  // Ajout d'une fonction pour effacer explicitement tous les scans de la session actuelle
  const clearCurrentSessionScans = async () => {
    try {
      const currentSessionId = await AsyncStorage.getItem('currentSessionId');
      if (!currentSessionId) {
        Alert.alert('Erreur', 'Impossible de déterminer la session actuelle');
        return;
      }
      
      Alert.alert(
        'Réinitialiser l\'historique',
        'Cette action va supprimer tous les scans associés à votre session actuelle. Continuer?',
        [
          {
            text: 'Annuler',
            style: 'cancel'
          },
          {
            text: 'Supprimer',
            onPress: async () => {
              try {
                // Supprimer les scans associés à la session actuelle
                setLoading(true);
                console.log(`Suppression des scans de la session ${currentSessionId}...`);
                
                // Fonction côté service qui devrait être implémentée
                // pour supprimer tous les scans de la session
                const result = await firebaseService.clearSessionScans(currentSessionId);
                
                // Supprimer l'historique local également
                await AsyncStorage.removeItem('scanHistory');
                setHistoricalScans([]);
                
                setLoading(false);
                Alert.alert('Succès', 'Historique réinitialisé avec succès');
              } catch (error) {
                setLoading(false);
                console.error('Erreur lors de la suppression des scans:', error);
                Alert.alert('Erreur', `Échec de la suppression: ${error.message}`);
              }
            },
            style: 'destructive'
          }
        ]
      );
    } catch (error) {
      console.error('Erreur:', error);
      Alert.alert('Erreur', 'Une erreur est survenue');
    }
  };

  // Handler de déconnexion avec effacement complet de l'historique
  const handleLogout = async () => {
    try {
      Alert.alert(
        'Déconnexion',
        'Voulez-vous vous déconnecter? L\'historique des scans sera effacé.',
        [
          {
            text: 'Annuler',
            style: 'cancel'
          },
          {
            text: 'Déconnecter',
            onPress: async () => {
              try {
                setLoading(true);
                console.log('Déconnexion en cours...');

                // Appeler la méthode de déconnexion de Firebase
                await firebaseService.logout();
                console.log('Déconnexion Firebase réussie');
                
                // Effacer toutes les données de session
                await AsyncStorage.removeItem('userSessionActive');
                // On conserve current_session_id pour que la tournée visitée reste en mémoire
                await AsyncStorage.removeItem('scanHistory');
                await AsyncStorage.removeItem('user_selas_id');
                
                // Réinitialiser les états
                setHistoricalScans([]);
                setScannedContenants([]);
                setSiteScanned(false);
                setSiteCode('');
                
                setLoading(false);
                
                // Rediriger vers l'écran de connexion
                navigation.reset({
                  index: 0,
                  routes: [{ name: 'Login' }]
                });
              } catch (error) {
                setLoading(false);
                console.error('Erreur lors du processus de déconnexion:', error);
                Alert.alert('Erreur', 'Impossible de se déconnecter. Veuillez réessayer.');
              }
            }
          }
        ]
      );
    } catch (error) {
      console.error('Erreur lors de la déconnexion:', error);
    }
  };

  // Utiliser directement les fonctions de formatage de dateUtils
  // au lieu de redéfinir des fonctions similaires

  // Effet pour écouter les événements de scan Zebra
  useEffect(() => {
    if (isReadyForScan) {
      // Afficher un message pour indiquer que l'application est prête pour le scan
      console.log('Prêt à recevoir des scans du scanner Zebra');
      
      // Configuration pour recevoir les scans du matériel Zebra
      const handleZebraScan = (event) => {
        // Le scanner Zebra envoie généralement les données comme des entrées clavier
        // Nous devons vérifier que nous sommes en mode scan et traiter les données
        if (event && event.nativeEvent && event.nativeEvent.key === 'Enter' && scanMode) {
          // Récupérer le texte scanné (par exemple depuis un champ de texte caché ou via une API Zebra)
          // Pour les besoins de cet exemple, nous utiliserons la valeur de manualCodeInput
          if (manualCodeInput.trim()) {
            processScannedData(manualCodeInput.trim());
            setManualCodeInput(''); // Réinitialiser après le traitement
          }
        }
      };
      
      // Ajoutez ici l'initialisation spécifique au scanner Zebra si nécessaire
      // Exemple : ZebraScanner.initialize() si une API Zebra est disponible
      
      // Pour cet exemple, on simule en utilisant l'écouteur de clavier (pour Enter)
      Keyboard.addListener('keyDown', handleZebraScan);
      
      return () => {
        // Nettoyage lors du démontage
        Keyboard.removeListener('keyDown', handleZebraScan);
        // Désinitialiser le scanner Zebra si nécessaire
        // Exemple : ZebraScanner.deinitialize()
      };
    }
  }, [isReadyForScan, scanMode, manualCodeInput]);


  const loadHistoricalScans = async () => {
    try {
      const jsonValue = await AsyncStorage.getItem('scanHistory');
      if (jsonValue !== null) {
        const history = JSON.parse(jsonValue);
        
        // Récupérer l'ID de la tournée actuelle
        const currentSession = await firebaseService.getCurrentSession();
        const currentTourneeId = currentSession?.tournee?.id || sessionData?.tournee?.id || '';
        
        // Filtrer l'historique local
        const today = new Date();
        today.setHours(0, 0, 0, 0); // Début de la journée
        
        const filteredHistory = history.filter(item => {
          // Convertir la date de l'item en objet Date
          let itemDate;
          try {
            itemDate = new Date(item.date);
            if (isNaN(itemDate.getTime())) {
              // Si la date n'est pas valide, essayer un autre format
              const parts = item.date.split('/');
              if (parts.length === 3) {
                itemDate = new Date(parts[2], parts[1] - 1, parts[0]);
              }
            }
          } catch (e) {
            // En cas d'erreur, considérer cet item comme non valide pour le filtre
            return false;
          }

          // S'assurer que nous avons une date valide
          if (!itemDate || isNaN(itemDate.getTime())) return false;
          
          itemDate.setHours(0, 0, 0, 0); // Normaliser à minuit
          
          // Vérifier la tournée
          const isSameTournee = !currentTourneeId || item.tourneeId === currentTourneeId;
          
          // Vérifier le statut (inclut les visites sans colis)
          const hasValidStatus = item.status === 'en-cours' || item.status === 'livré';
          
          // L'item doit être du jour courant ET de la même tournée ET avoir un statut valide
          return itemDate.getTime() === today.getTime() && isSameTournee && hasValidStatus;
        });
        
        console.log(`Historique local filtré: ${filteredHistory.length} scans (jour + tournée + statut)`);
        
        // Consolider l'historique filtré avant de mettre à jour l'état
        const consolidatedHistory = consolidateAndSortScans([], filteredHistory);

        // Enrichir avec le nom complet du site depuis Firestore
        const enrichedHistory = await Promise.all(
          consolidatedHistory.map(async (scan) => {
            // Tenter de récupérer les détails du site en utilisant siteId ou code
            try {
              const siteIdentifier = scan.siteId || scan.code; // Utiliser ID ou code
              // Vérifier si l'identifiant est probablement un site avant d'appeler getSiteById
              if (siteIdentifier && 
                  !siteIdentifier.startsWith('TEST_CONTENANT_') && 
                  !siteIdentifier.match(/^[0-9]{13,}$/)) { 
                const siteInfo = await firebaseService.getSiteById(siteIdentifier);
                if (siteInfo) {
                  // Enrichir le scan avec les détails complets
                  return { 
                    ...scan, 
                    siteName: siteInfo.nom || siteInfo.name, // Ajouter le nom pour affichage facile
                    siteDetails: { ...siteInfo } 
                  };
                }
              }
            } catch (e) {
              console.warn(`[loadHistoricalScans] Erreur récupération détails site pour ${scan.code || scan.id}:`, e);
            }
            // Si non trouvé ou erreur, retourner le scan original
            return scan;
          })
        );
        
        // Mettre à jour l'état avec l'historique enrichi
        setHistoricalScans(enrichedHistory);
        setSessionHistoryLoaded(true);
      }
    } catch (error) {
      console.error('Erreur lors du chargement de l\'historique:', error);
    }
  };

  const loadFirestoreScans = async () => {
    try {
      // On ne charge les scans Firestore que si la session est active
      const userSessionActive = await AsyncStorage.getItem('userSessionActive');
      if (userSessionActive !== 'true') {
        // Si aucune session active, on ne charge pas l'historique Firestore
        return;
      }

      // Récupérer l'ID de session actuel
      const currentSessionId = await AsyncStorage.getItem('currentSessionId');
      console.log('Chargement des scans pour la session:', currentSessionId);

      // Récupérer l'ID de la tournée actuelle
      const currentSession = await firebaseService.getCurrentSession();
      const currentTourneeId = currentSession?.tournee?.id || sessionData?.tournee?.id || '';
      console.log('Tournée actuelle:', currentTourneeId);

      setLoading(true); // Afficher l'indicateur de chargement

      // Récupérer tous les scans de l'utilisateur (sans limite)
      const scans = await firebaseService.getScans();
      
      if (scans && scans.length > 0) {
        // Ne garder que les scans du jour (J0)
        const today = new Date();
        today.setHours(0, 0, 0, 0); // Début de la journée
        
        const filteredScans = scans.filter(scan => {
          // Convertir la date du scan en objet
