import React, { useState, useEffect, useImperativeHandle, forwardRef, useRef } from 'react';
import { useIsFocused } from '@react-navigation/native';
import {
  StyleSheet,
  Text,
  TouchableOpacity,
  Alert,
  Modal,
  FlatList,
  SafeAreaView,
  TextInput,
  ActivityIndicator,
  StatusBar,
  Image,
  Keyboard,
  ScrollView,
  Platform,
  InteractionManager,
} from 'react-native';
import { Ionicons, MaterialCommunityIcons, MaterialIcons } from '@expo/vector-icons';
import AsyncStorage from '@react-native-async-storage/async-storage';
import firebaseService from '../services/firebaseService';
import dateUtils from '../utils/dateUtils';
import CustomView from '../components/CustomView';
import TourneeProgress from '../components/TourneeProgress';
import ScanHistoryItem from '../components/ScanHistoryItem';

// Renommer CustomView en View pour maintenir la compatibilit√© avec le code existant
const View = CustomView;

export default function ScanScreen({ navigation, route }) {
  const sessionData = route.params?.sessionData || {}; // ‚úÖ S√©curise `sessionData`

  // ‚úÖ V√©rifie si `sessionData.tournee` et `sessionData.vehicule` existent
  const tournee = sessionData.tournee ? sessionData.tournee.nom || "Tourn√©e inconnue" : "Tourn√©e inconnue";
  const vehicule = sessionData.vehicule ? sessionData.vehicule.immatriculation || "V√©hicule inconnu" : "V√©hicule inconnu";
  // ID de la tourn√©e pour le suivi
  const tourneeId = sessionData.tournee ? sessionData.tournee.id : null;

  const [siteScanned, setSiteScanned] = useState(false);
  const [siteCode, setSiteCode] = useState('');
  const [scannedContenants, setScannedContenants] = useState([]);
  const [errorMessage, setErrorMessage] = useState('');
  const [manualCodeInput, setManualCodeInput] = useState('');
  const [showHistoryModal, setShowHistoryModal] = useState(false);
  const [historicalScans, setHistoricalScans] = useState([]);
  const [loading, setLoading] = useState(false);
  const [siteDetails, setSiteDetails] = useState(null);
  const [isReadyForScan, setIsReadyForScan] = useState(false);
  const [scanMode, setScanMode] = useState(''); // 'site' ou 'contenant'
  const [scanning, setScanning] = useState(false);
  const [sessionId, setSessionId] = useState("");
  const [pole, setPole] = useState(null);
  const [sessionHistoryLoaded, setSessionHistoryLoaded] = useState(false);
  const [operationType, setOperationType] = useState('entree'); // 'entree' ou 'sortie'
  const [showOperationTypeSelection, setShowOperationTypeSelection] = useState(false); // Nouvel √©tat pour la page de s√©lection
  const [takingCarePackages, setTakingCarePackages] = useState([]); // Paquets pris en charge
  // Ajouter l'√©tat pour l'ID de session courant
  const [currentSessionId, setCurrentSessionId] = useState(null);

  // √âtats pour les informations de session qui seront charg√©es
  const [currentTourneeName, setCurrentTourneeName] = useState(route.params?.tournee?.nom || route.params?.tourneeName || sessionData?.tournee?.nom || "Tourn√©e inconnue");
  const [currentVehiculeImmat, setCurrentVehiculeImmat] = useState(route.params?.vehicule?.immatriculation || route.params?.vehiculeImmat || sessionData?.vehicule?.immatriculation || "V√©hicule inconnu");
  // NOUVEL ETAT pour l'ID de la tourn√©e - Initialis√© directement
  const [currentTourneeId, setCurrentTourneeId] = useState(route.params?.tourneeId || sessionData?.tournee?.id || null);

  // R√©duire les logs inutiles
  console.log = (message) => {
    if (message.includes('[SessionInit]') || message.includes('[loadHistoricalData]')) {
      // Filtrer les logs pour √©viter les r√©p√©titions inutiles
      return;
    }
    console.info(message);
  };

  // Limiter les appels de log pour √©viter les r√©p√©titions
  const logTourneeProgress = (message) => {
    if (!message.includes('restaur√©s depuis la tourn√©e') && !message.includes('sauvegard√©s pour la tourn√©e')) {
      console.log(message);
    }
  };

  // Remplacer les appels de console.log par logTourneeProgress
  logTourneeProgress(`[TourneeProgress] 1 sites visit√©s restaur√©s depuis la tourn√©e ${currentTourneeId}`);
  logTourneeProgress(`[TourneeProgress] 1 sites visit√©s sauvegard√©s pour la tourn√©e ${currentTourneeId}`);

  // R√©f√©rence au composant TourneeProgress
  const tourneeProgressRef = useRef(null);

  // Effet pour initialiser la session au d√©marrage OU r√©cup√©rer la session pass√©e
  useEffect(() => {
    const initializeOrUseExistingSession = async () => {
      setIsLoading(true);
      try {
        let session = await firebaseService.getCurrentSession();
        console.log('[ScanScreen] Current session from FirebaseService:', session);

        if (session && session.id) {
          setCurrentSession(session);
          if (session.tourneeId) {
            const tourneeDetails = await firebaseService.getTourneeById(session.tourneeId);
            console.log('[ScanScreen] Tournee details:', tourneeDetails);
            setCurrentTourneeName(tourneeDetails?.name || 'Tourn√©e inconnue');
            setCurrentTourneeId(session.tourneeId);
          } else {
            setCurrentTourneeName('Tourn√©e inconnue');
            console.log('[ScanScreen] tourneeId non trouv√© dans la session');
          }

          if (session.vehiculeId) {
            const vehiculeDetails = await firebaseService.getVehiculeById(session.vehiculeId);
            console.log('[ScanScreen] Vehicule details:', vehiculeDetails);
            setCurrentVehiculeImmat(vehiculeDetails?.immatriculation || 'V√©hicule inconnu');
          } else {
            setCurrentVehiculeImmat('V√©hicule inconnu');
            console.log('[ScanScreen] vehiculeId non trouv√© dans la session');
          }

          if (session.visitedSiteIdentifiers) {
            setVisitedSites(new Set(session.visitedSiteIdentifiers));
          }

          // R√©cup√©rer les informations sur le p√¥le si disponible
          if (session.poleId) {
            const poleDetails = await firebaseService.getPoleById(session.poleId);
            setCurrentPoleName(poleDetails?.name || 'P√¥le inconnu');
          } else {
            setCurrentPoleName('P√¥le inconnu');
          }


        } else {
          console.log('[ScanScreen] Aucune session active trouv√©e ou sessionData non fourni. Redirection ou gestion.');
          // Si route.params.sessionData existe, cela signifie une nouvelle session est en cours de cr√©ation
          if (route.params?.sessionData) {
            const { tournee, vehicule, pole, vehiculeCheck } = route.params.sessionData;
            console.log('[ScanScreen] Initialisation avec sessionData des route.params:', route.params.sessionData);
            
            const newSessionData = {
              tourneeId: tournee?.id,
              vehiculeId: vehicule?.id,
              poleId: pole?.id,
              vehiculeCheck: vehiculeCheck,
              visitedSiteIdentifiers: [], // Initialiser comme tableau vide
            };

            const sessionId = await firebaseService.saveSessionData(newSessionData);
            await AsyncStorage.setItem('current_session_id', sessionId);
            const newSession = await firebaseService.getSessionById(sessionId);
            setCurrentSession(newSession); // Mettre √† jour la session actuelle avec celle qui vient d'√™tre sauvegard√©e
            
            setCurrentTourneeName(tournee?.name || 'Tourn√©e inconnue');
            setCurrentVehiculeImmat(vehicule?.immatriculation || 'V√©hicule inconnu');
            setCurrentPoleName(pole?.name || 'P√¥le inconnu');
            setCurrentTourneeId(tournee?.id);
            setVisitedSites(new Set()); // Initialiser pour une nouvelle session
          } else {
            // G√©rer le cas o√π il n'y a ni session existante ni nouvelles donn√©es de session
            // Peut-√™tre rediriger vers l'√©cran de s√©lection de tourn√©e
            console.log('[ScanScreen] Pas de session active ni de donn√©es pour en cr√©er une. Affichage des valeurs par d√©faut.');
            setCurrentTourneeName('Tourn√©e inconnue');
            setCurrentVehiculeImmat('V√©hicule inconnu');
            setCurrentPoleName('P√¥le inconnu');
          }
        }
      } catch (error) {
        console.error("[ScanScreen] Erreur lors de l'initialisation de la session:", error);
        Alert.alert("Erreur", "Impossible d'initialiser la session.");
        setCurrentTourneeName('Tourn√©e inconnue');
        setCurrentVehiculeImmat('V√©hicule inconnu');
        setCurrentPoleName('P√¥le inconnu');
      } finally {
        setIsLoading(false);
      }
    };

    if (isFocused) {
      initializeOrUseExistingSession();
    }

    // Gestion du rafra√Æchissement lorsque l'√©cran revient au premier plan
    const unsubscribeFocus = navigation.addListener('focus', () => {
      // Pas besoin de rappeler initializeOrUseExistingSession si isFocused le fait d√©j√† bien.
      // Cependant, si des donn√©es sp√©cifiques doivent √™tre recharg√©es √† chaque focus (ex: statut de sites)
      // cela pourrait √™tre fait ici. Pour l'instant, on s'appuie sur la logique existante.
      console.log("[ScanScreen] Screen focused");
    });

    return () => {
      unsubscribeFocus();
    };
  }, [isFocused, route.params?.sessionData]); // Retrait de navigation et autres d√©pendances non n√©cessaires si g√©r√©es par isFocused et sessionData

  // Fonction correcte pour mettre √† jour uniquement le suivi de tourn√©e sans r√©initialiser le site scann√©
  const updateTourneeProgress = async () => {
    try {
      console.log("Mise √† jour du suivi de tourn√©e en cours...");

      // Utiliser l'ID de session de l'√©tat
      if (!currentSessionId) {
        console.warn("[updateTourneeProgress] currentSessionId est null, impossible de rafra√Æchir TourneeProgress avec la session.");
        return;
      }
      
      // Appeler loadTourneeDetails sur la r√©f√©rence du composant TourneeProgress
      if (tourneeProgressRef.current) {
        await tourneeProgressRef.current.loadTourneeDetails(true);
        console.log("[updateTourneeProgress] Rechargement du composant TourneeProgress effectu√©.");
      } else {
        console.warn("[updateTourneeProgress] tourneeProgressRef.current est null, impossible de recharger TourneeProgress.");
      }
    } catch (error) {
      console.error("Erreur lors de la mise √† jour de la progression de la tourn√©e:", error);
    }
  };

  // Ajout des points-virgules manquants
  const refreshTourneeData = () => {
    console.log("Rafra√Æchissement des donn√©es de la tourn√©e...");
    updateTourneeProgress();
  };

  // Ajout des accolades manquantes dans les blocs de code
  const handleZebraScan = (event) => {
    if (event && event.nativeEvent && event.nativeEvent.key === 'Enter' && scanMode) {
      if (manualCodeInput.trim()) {
        processScannedData(manualCodeInput.trim());
        setManualCodeInput('');
      }
    }
  };

  // Effet pour g√©rer les √©v√©nements du clavier Zebra
  useEffect(() => {
    Keyboard.addListener('keyDown', handleZebraScan);

    return () => {
      Keyboard.removeListener('keyDown', handleZebraScan);
    };
  }, [scanMode, manualCodeInput]); // D√©pendances n√©cessaires pour que handleZebraScan fonctionne correctement

  // Effet pour d√©tecter le param√®tre refresh et rafra√Æchir les donn√©es
  useEffect(() => {
    if (route.params?.refresh) {
      console.log("Rafra√Æchissement d√©clench√© par le bouton d'en-t√™te:", route.params.refresh);
      refreshTourneeData();
    }
  }, [route.params?.refresh]);

  // Surveiller les changements de route.params pour d√©tecter quand le bouton d'historique est press√©
  useEffect(() => {
    if (route.params?.showHistory) {
      setShowHistoryModal(true);
      // R√©initialiser le param√®tre pour √©viter de rouvrir la modale si on navigue ailleurs puis revient
      navigation.setParams({ showHistory: false });
    }
  }, [route.params?.showHistory]);

  // Chargement des scans historiques au d√©marrage et r√©cup√©ration des paquets en cours
  useEffect(() => {
    loadHistoricalData();
  }, []);

  // Fonction pour charger tous les donn√©es d'historique et de paquets en cours
  const loadHistoricalData = async () => {
    // V√©rifier et synchroniser l'ID de la tourn√©e si n√©cessaire
    if (!currentTourneeId && currentSessionId) {
      try {
        console.log('[loadHistoricalData] Tentative de r√©cup√©ration de l\'ID de tourn√©e depuis la session', currentSessionId);
        const sessionDoc = await firebaseService.getSessionById(currentSessionId);
        if (sessionDoc && sessionDoc.tourneeId) {
          console.log(`[loadHistoricalData] ID de tourn√©e trouv√© dans la session: ${sessionDoc.tourneeId}`);
          setCurrentTourneeId(sessionDoc.tourneeId);
        }
      } catch (err) {
        console.error('[loadHistoricalData] Erreur lors de la r√©cup√©ration de la session:', err);
      }
    }
    
    // Charger l'historique des scans
    await loadHistoricalScans();
    await loadFirestoreScans();
    // Charger les paquets pris en charge
    await loadTakingCarePackages();
  };

  const loadHistoricalScans = async () => {
    try {
      const jsonValue = await AsyncStorage.getItem('scanHistory');
      if (jsonValue !== null) {
        const history = JSON.parse(jsonValue);
        
        // R√©cup√©rer l'ID de la tourn√©e actuelle
        const currentSession = await firebaseService.getCurrentSession();
        const currentTourneeId = currentSession?.tournee?.id || sessionData?.tournee?.id || '';
        
        // Filtrer l'historique local
        const today = new Date();
        today.setHours(0, 0, 0, 0); // D√©but de la journ√©e
        
        const filteredHistory = history.filter(item => {
          // Convertir la date de l'item en objet Date
          let itemDate;
          try {
            itemDate = new Date(item.date);
            if (isNaN(itemDate.getTime())) {
              // Si la date n'est pas valide, essayer un autre format
              const parts = item.date.split('/');
              if (parts.length === 3) {
                itemDate = new Date(parts[2], parts[1] - 1, parts[0]);
              }
            }
          } catch (e) {
            // En cas d'erreur, consid√©rer cet item comme non valide pour le filtre
            return false;
          }

          // S'assurer que nous avons une date valide
          if (!itemDate || isNaN(itemDate.getTime())) return false;
          
          itemDate.setHours(0, 0, 0, 0); // Normaliser √† minuit
          
          // V√©rifier la tourn√©e
          const isSameTournee = !currentTourneeId || item.tourneeId === currentTourneeId;
          
          // V√©rifier le statut (inclut les visites sans colis)
          const hasValidStatus = item.status === 'en-cours' || item.status === 'livr√©';
          
          // L'item doit √™tre du jour courant ET de la m√™me tourn√©e ET avoir un statut valide
          return itemDate.getTime() === today.getTime() && isSameTournee && hasValidStatus;
        });
        
        console.log(`Historique local filtr√©: ${filteredHistory.length} scans (jour + tourn√©e + statut)`);
        
        // Consolider l'historique filtr√© avant de mettre √† jour l'√©tat
        const consolidatedHistory = consolidateAndSortScans([], filteredHistory);

        // Enrichir avec le nom complet du site depuis Firestore
        const enrichedHistory = await Promise.all(
          consolidatedHistory.map(async (scan) => {
            // Tenter de r√©cup√©rer les d√©tails du site en utilisant siteId ou code
            try {
              const siteIdentifier = scan.siteId || scan.code; // Utiliser ID ou code
              // V√©rifier si l'identifiant est probablement un site avant d'appeler getSiteById
              if (siteIdentifier && 
                  !siteIdentifier.startsWith('TEST_CONTENANT_') && 
                  !siteIdentifier.match(/^[0-9]{13,}$/)) { 
                const siteInfo = await firebaseService.getSiteById(siteIdentifier);
                if (siteInfo) {
                  // Enrichir le scan avec les d√©tails complets
                  return { 
                    ...scan, 
                    siteName: siteInfo.nom || siteInfo.name, // Ajouter le nom pour affichage facile
                    siteDetails: { ...siteInfo } 
                  };
                }
              }
            } catch (e) {
              console.warn(`[loadHistoricalScans] Erreur r√©cup√©ration d√©tails site pour ${scan.code || scan.id}:`, e);
            }
            // Si non trouv√© ou erreur, retourner le scan original
            return scan;
          })
        );
        
        // Mettre √† jour l'√©tat avec l'historique enrichi
        setHistoricalScans(enrichedHistory);
        setSessionHistoryLoaded(true);
      }
    } catch (error) {
      console.error('Erreur lors du chargement de l\'historique:', error);
    }
  };

  const loadFirestoreScans = async () => {
    try {
      // On ne charge les scans Firestore que si la session est active
      const userSessionActive = await AsyncStorage.getItem('userSessionActive');
      if (userSessionActive !== 'true') {
        // Si aucune session active, on ne charge pas l'historique Firestore
        return;
      }

      // R√©cup√©rer l'ID de session actuel
      const currentSessionId = await AsyncStorage.getItem('currentSessionId');
      console.log('Chargement des scans pour la session:', currentSessionId);

      // R√©cup√©rer l'ID de la tourn√©e actuelle
      const currentSession = await firebaseService.getCurrentSession();
      const currentTourneeId = currentSession?.tournee?.id || sessionData?.tournee?.id || '';
      console.log('Tourn√©e actuelle:', currentTourneeId);

      setLoading(true); // Afficher l'indicateur de chargement

      // R√©cup√©rer tous les scans de l'utilisateur (sans limite)
      const scans = await firebaseService.getScans();
      
      if (scans && scans.length > 0) {
        // Ne garder que les scans du jour (J0)
        const today = new Date();
        today.setHours(0, 0, 0, 0); // D√©but de la journ√©e
        
        const filteredScans = scans.filter(scan => {
          // Convertir la date du scan en objet Date
          const scanDate = dateUtils.convertTimestampToDate(scan.scanDate || scan.createdAt);
          if (!scanDate) return false;
          
          // R√©cup√©rer juste la date (sans l'heure)
          const scanDateOnly = new Date(scanDate);
          scanDateOnly.setHours(0, 0, 0, 0);
          
          // V√©rifier la tourn√©e (si une tourn√©e actuelle est d√©finie)
          const isSameTournee = !currentTourneeId || scan.tourneeId === currentTourneeId;
          
          // V√©rifier le statut (inclut "pas_de_colis")
          const hasValidStatus = scan.status === 'en-cours' || scan.status === 'livr√©';
          
          // Le scan doit √™tre du jour courant ET de la m√™me tourn√©e ET avoir un statut valide
          return scanDateOnly.getTime() === today.getTime() && isSameTournee && hasValidStatus;
        });
        
        // Convertir les scans Firestore filtr√©s en format compatible avec l'historique local
        const formattedScans = filteredScans.map(scan => {
          // D√©duire le statut si manquant, bas√© sur le type d'op√©ration
          let status = scan.status;
          if (!status) {
            status = scan.operationType === 'sortie' ? 'livr√©' : 'en-cours';
          }
          
          return {
            id: scan.id || Date.now().toString(),
            code: scan.code,
            timeStamp: dateUtils.formatTime(scan.scanDate || scan.createdAt),
            date: dateUtils.formatDate(scan.scanDate || scan.createdAt),
            site: scan.site,
            fromFirestore: true,
            sessionId: scan.sessionId,
            // Utiliser le statut (corrig√© si n√©cessaire)
            status: status, 
            // S'assurer que le type est aussi pr√©sent
            type: scan.operationType || (status === 'livr√©' ? 'sortie' : 'entree'), 
            tournee: scan.tournee || '',
            tourneeId: scan.tourneeId || '',
            scanDate: scan.scanDate ? dateUtils.convertTimestampToDate(scan.scanDate).toISOString() : (scan.createdAt ? dateUtils.convertTimestampToDate(scan.createdAt).toISOString() : new Date().toISOString()) // Garder une date ISO pour le tri
          };
        });
        
        // Consolider et trier
        const consolidatedScans = consolidateAndSortScans(historicalScans, formattedScans);
        // Enrichir avec le nom complet du site depuis Firestore
        const enrichedScans = await Promise.all(
          consolidatedScans.map(async (scan) => {
            try {
              // Tenter de r√©cup√©rer les d√©tails du site
              try {
                // Utiliser l'ID du site si disponible, sinon le code barre
                const siteIdentifier = scan.siteId || scan.code; // Assumer que siteId existe
                if (siteIdentifier && 
                    !siteIdentifier.startsWith('TEST_CONTENANT_') && 
                    !siteIdentifier.match(/^[0-9]{13,}$/)) {
                  // Utiliser une variable locale au lieu de r√©assigner l'√©tat siteDetails
                  const siteInfo = await firebaseService.getSiteById(siteIdentifier); 
                  if (siteInfo) {
                    // Modifier l'objet scan directement
                    scan.siteName = siteInfo.nom || siteInfo.name; // Utiliser le nom du site s'il est trouv√©
                    scan.siteDetails = siteInfo; // Ajouter les d√©tails au scan
                  } else {
                     // Si siteInfo est null, indiquer le nom comme code
                     scan.siteName = scan.code; 
                  }
                } else {
                   scan.siteName = scan.code; // Fallback si aucun identifiant
                }
              } catch (siteError) {
                console.warn(`[loadFirestoreScans] Impossible de r√©cup√©rer les d√©tails du site pour l'identifiant ${scan.siteId || scan.code}:`, siteError);
                scan.siteName = scan.code; // Afficher le code si erreur
              }
              
              // Ne r√©cup√©rer les informations sur le site que s'il ne s'agit pas d'un conteneur
              if (scan.site && 
                  !scan.site.startsWith('TEST_CONTENANT_') && 
                  !scan.site.match(/^[0-9]{13,}$/)) {
                const siteInfo = await firebaseService.getSiteById(scan.site);
                if (siteInfo) return { ...scan, siteDetails: { ...siteInfo } };
              }
            } catch (e) {
              console.error('Erreur r√©cup√©ration nom site Firestore:', e);
            }
            return scan;
          })
        );
        
        // Mettre √† jour l'√©tat avec l'historique enrichi
        setHistoricalScans(enrichedScans);
        setSessionHistoryLoaded(true);
        
        // Sauvegarder √©galement dans AsyncStorage pour la persistance locale temporaire
        await AsyncStorage.setItem('scanHistory', JSON.stringify(enrichedScans));
      }
      
      setLoading(false); // Masquer l'indicateur de chargement
    } catch (error) {
      console.error('Erreur lors du chargement des scans depuis Firestore:', error);
      setLoading(false); // Masquer l'indicateur de chargement en cas d'erreur
    }
  };

  // --- AJOUTER CETTE FONCTION D'AIDE --- 
  // Fonction pour consolider et trier les scans
  const consolidateAndSortScans = (existingScans, newScans) => {
    const map = new Map();

    // Ajouter les scans existants √† la map
    existingScans.forEach(scan => {
      if (scan.code) map.set(scan.code, scan);
    });

    // Mettre √† jour ou ajouter les nouveaux scans
    newScans.forEach(scan => {
      if (scan.code) map.set(scan.code, scan);
    });

    // Convertir la map en tableau
    const consolidated = Array.from(map.values());

    // Trier
    consolidated.sort((a, b) => {
      const dateA = a.scanDate ? new Date(a.scanDate).getTime() : 0;
      const dateB = b.scanDate ? new Date(b.scanDate).getTime() : 0;
      if (isNaN(dateA) && isNaN(dateB)) return 0;
      if (isNaN(dateA)) return 1;
      if (isNaN(dateB)) return -1;
      return dateB - dateA;
    });

    return consolidated;
  };
  // --- FIN DE L'AJOUT ---

  const loadTakingCarePackages = async () => {
    try {
      const scansEnCours = await firebaseService.getScansEnCours();
      // Filtrer pour exclure les scans "pas_de_colis"
      const filteredScans = scansEnCours.filter(scan => 
        scan.status !== 'pas_de_colis' &&
        !(scan.code && scan.code.startsWith('SITE_'))
      );
      console.log(`‚úÖ ${filteredScans.length} paquet(s) pris en charge r√©cup√©r√©(s) (sans les "pas_de_colis")`);
      setTakingCarePackages(filteredScans);
    } catch (error) {
      console.error('‚ùå Erreur lors du chargement des paquets pris en charge:', error);
    }
  };

  // üîπ Simulation d'un scan avec des sites valides
  const simulateScan = () => {
    if (scanMode === 'site') {
      // Sites de test qui seront reconnus comme valides
      const sitesDemoValides = [
        'SITE123',
        'SITE456',
        'SITE789',
        'LAB001',
        '12345'
      ];
      
      // S√©lectionner un site al√©atoire parmi les sites valides pour la d√©mo
      return sitesDemoValides[Math.floor(Math.random() * sitesDemoValides.length)];
    } else {
      // Si on est en mode sortie (d√©p√¥t), on doit scanner un colis d√©j√† pris en charge
      if (operationType === 'sortie') {
        // V√©rifier si des colis sont disponibles
        if (takingCarePackages.length > 0) {
          // S√©lectionner un colis al√©atoire parmi les colis pris en charge
          const randomPackage = takingCarePackages[Math.floor(Math.random() * takingCarePackages.length)];
          return randomPackage.code;
        } else {
          // Aucun colis disponible pour le d√©p√¥t - cette condition est g√©r√©e dans handleSimulatedScan
          return '';
        }
      } else {
        // Simuler un scan de contenant pour prise en charge
        // Utiliser un pr√©fixe sp√©cifique pour les tests afin de pouvoir les identifier facilement
        const testId = Date.now(); // Utiliser le timestamp actuel pour cr√©er un ID unique
        return `TEST_CONTENANT_${testId}`;
      }
    }
  };

  // Modification pour les tests : fonction mock qui simule verifySiteCode
  const mockVerifySiteCode = async (siteCode) => {
    // Sites de test qui seront automatiquement valid√©s
    const sitesDemoValides = {
      'SITE123': { nom: 'Site Test 1', adresse: '123 Rue Principale', ville: 'Paris', codePostal: '75001' },
      'SITE456': { nom: 'Site Test 2', adresse: '456 Avenue R√©publique', ville: 'Lyon', codePostal: '69001' },
      'SITE789': { nom: 'Site Test 3', adresse: '789 Boulevard des Tests', ville: 'Toulouse', codePostal: '31000' },
      '12345': { nom: 'Laboratoire Central', adresse: '12 Rue des Sciences', ville: 'Montpellier', codePostal: '34000' },
      'LAB001': { nom: 'Laboratoire Mobile', adresse: 'Zone Industrielle', ville: 'Bordeaux', codePostal: '33000' }
    };

    // V√©rifier si le code scann√© est dans notre liste de sites de test
    if (sitesDemoValides[siteCode]) {
      // Retourner une structure simulant la r√©ponse de Firebase
      return {
        valid: true,
        site: {
          id: `mock_${siteCode}`,
          code: siteCode,
          nom: sitesDemoValides[siteCode].nom,
          adresse: sitesDemoValides[siteCode].adresse,
          ville: sitesDemoValides[siteCode].ville,
          codePostal: sitesDemoValides[siteCode].codePostal
        }
      };
    }

    // Si ce n'est pas un site de test, passer √† la v√©rification normale dans Firebase
    return await firebaseService.verifySiteCode(siteCode);
  };

  const processScannedData = async (data) => {
    console.log('Code scann√©:', data);
    try {
      // Cas 1: Nous n'avons pas encore scann√© de site
      if (!siteScanned && scanMode === 'site') {
        console.log('[processScannedData] Mode: Scan de site. Donn√©es:', data);
        const siteVerification = await firebaseService.verifySiteCode(data);
        console.log('[processScannedData] R√©sultat de verifySiteCode:', JSON.stringify(siteVerification));

        if (siteVerification.site) {
          // Enregistrer les infos du site
          setSiteCode(data);
          setSiteDetails(siteVerification.site);
          // setSiteScanned(true); // Mis plus bas pour ne l'activer qu'apr√®s succ√®s
          // setScanMode(''); // Mis plus bas
          // setShowOperationTypeSelection(true); // Mis plus bas

          // --- MODIFI√â: Ne trouver que le premier site non visit√© avec ce nom ---
          let occurrenceIndex = null;
          if (tourneeProgressRef.current?.getSitesWithStatus) {
            const sitesList = tourneeProgressRef.current.getSitesWithStatus();
            console.log('[processScannedData] sitesList depuis tourneeProgressRef:', JSON.stringify(sitesList.map(s => ({ id: s.id, name: s.name, visited: s.visited, uniqueDisplayId: s.uniqueDisplayId }))));
            const siteNameToFind = siteVerification.site.nom || siteVerification.site.name;
            console.log('[processScannedData] Nom du site √† trouver:', siteNameToFind);

            // Trouver le premier site non visit√© avec ce nom
            occurrenceIndex = sitesList.findIndex(s => !s.visited && (s.name === siteNameToFind || s.nom === siteNameToFind)); // Ajout de s.nom
            console.log(`[processScannedData] Occurrence index trouv√©e pour ${siteNameToFind}:`, occurrenceIndex);
            
            // Si aucun site non visit√© n'est trouv√©, ne rien faire
            if (occurrenceIndex === -1) {
              Alert.alert(
                'Site d√©j√† visit√© ou non trouv√©', // Message mis √† jour
                'Ce site a d√©j√† √©t√© visit√©, ne fait pas partie de cette tourn√©e, ou son nom ne correspond pas exactement.', // Message mis √† jour
                [{ text: 'OK', onPress: () => {
                  // R√©initialiser l'√©tat pour permettre un nouveau scan
                  setSiteScanned(false);
                  setSiteDetails(null);
                  setSiteCode('');
                  setShowOperationTypeSelection(false);
                }}]
              );
              return;
            }
          } else {
            console.warn('[processScannedData] tourneeProgressRef.current.getSitesWithStatus non disponible.');
            Alert.alert('Erreur', 'Impossible de r√©cup√©rer la liste des sites de la tourn√©e.');
            return;
          }

          // Marquage en session via l'index si trouv√©, sinon par site.id
          const identifier = siteVerification.site.id || (siteVerification.site.code || data);
          console.log('[processScannedData] Identifier pour markSiteVisitedInSession:', identifier);
          console.log('[processScannedData] currentSessionId avant appel:', currentSessionId);
          console.log('[processScannedData] occurrenceIndex avant appel:', occurrenceIndex);

          if (!currentSessionId) {
            console.error('[processScannedData] ID de session manquant avant markSiteVisitedInSession');
            Alert.alert('Erreur Critique', 'ID de session manquant. Impossible de continuer.');
            return;
          }
          
          // Ne marquer qu'un seul site √† la fois, en utilisant l'index sp√©cifique
          if (occurrenceIndex !== -1 && occurrenceIndex !== null) { // Condition d√©j√† pr√©sente, mais on log avant
            const markSuccess = await firebaseService.markSiteVisitedInSession(currentSessionId, identifier, occurrenceIndex);
            console.log('[processScannedData] R√©sultat de markSiteVisitedInSession:', markSuccess);
            
            if (markSuccess) {
              setSiteScanned(true); // Activer seulement si le marquage Firestore a r√©ussi
              setScanMode(''); 
              setShowOperationTypeSelection(true);

              // Mise √† jour du UI local - mettre √† jour uniquement le site sp√©cifique
              if (tourneeProgressRef.current?.markSiteAsVisitedLocally) {
                console.log('[processScannedData] Appel de markSiteAsVisitedLocally avec:', identifier, occurrenceIndex);
                await tourneeProgressRef.current.markSiteAsVisitedLocally(identifier, occurrenceIndex); // AJOUT DE AWAIT
                // Temporairement comment√© pour tester si la coche se met √† jour correctement sans rechargement imm√©diat
                // await updateTourneeProgress(); 
              } else if (tourneeProgressRef.current?.loadTourneeDetails) {
                console.log('[processScannedData] Appel de loadTourneeDetails(true) car markSiteAsVisitedLocally non dispo.');
                await tourneeProgressRef.current.loadTourneeDetails(true);
              }
            } else {
              Alert.alert('Erreur', '√âchec du marquage du site comme visit√© dans la session Firestore.');
              // Garder siteScanned √† false, etc.
            }
            
            // Si updateTourneeProgress a √©t√© comment√©, on peut appeler loadHistoricalData ici
            // si c'est n√©cessaire pour d'autres parties de l'UI non li√©es √† TourneeProgress.
            // Pour l'instant, on isole le probl√®me de la coche.
            // await loadHistoricalData(); 

          } else {
             console.warn('[processScannedData] occurrenceIndex invalide, markSiteVisitedInSession non appel√©.');
             // Potentiellement une alerte ici si ce cas ne devrait pas arriver
          }
          return;
        } else { // siteVerification.site est null/undefined
          console.log('[processScannedData] Aucun site valide retourn√© par verifySiteCode pour le code:', data);
          Alert.alert('Site Inconnu', 'Le code scann√© ne correspond √† aucun site connu.');
           // R√©initialiser pour permettre un nouveau scan
          setSiteScanned(false);
          setSiteDetails(null);
          setSiteCode('');
          setShowOperationTypeSelection(false);
        }
      }
      
      // Cas 2: Site d√©j√† scann√©, nous scannons maintenant un contenant
      if (siteScanned && scanMode === 'contenant') {
        console.log('[processScannedData] Mode: Scan de contenant. Donn√©es:', data);
        handleContenantScan(data);
        // Rester en mode scan contenant pour permettre les scans multiples
        setScanMode('contenant');
      }
    } catch (error) {
      console.error('Erreur lors de la gestion du scan:', error);
      setErrorMessage('Erreur: ' + error.message); // Afficher l'erreur √† l'utilisateur
      setScanMode(''); // R√©initialiser le mode scan
      // Optionnel: r√©initialiser d'autres √©tats si n√©cessaire
      setSiteScanned(false);
      setSiteDetails(null);
      setSiteCode('');
      setShowOperationTypeSelection(false);
    }
  };

  // G√©rer la simulation d'un scan (pour le d√©veloppement et les tests)
  const handleSimulatedScan = () => {
    // V√©rifier si on est en mode sortie sans colis pris en charge
    if (scanMode === 'contenant' && operationType === 'sortie' && takingCarePackages.length === 0) {
      Alert.alert(
        "Aucun colis disponible",
        "Vous n'avez aucun colis en prise en charge √† d√©poser.",
        [{ text: "OK" }]
      );
      return;
    }
    
    const fakeData = simulateScan();
    if (fakeData) {
      console.log(`Simulation de scan avec donn√©es: ${fakeData}`);
    processScannedData(fakeData);
    } else {
      console.error("Erreur lors de la simulation du scan: aucune donn√©e g√©n√©r√©e");
      Alert.alert(
        "Erreur",
        "Impossible de simuler un scan. Veuillez r√©essayer.",
        [{ text: "OK" }]
      );
    }
  };

  const handleManualScan = () => {
    if (manualCodeInput.trim() === '') {
      Alert.alert('Erreur', 'Veuillez entrer un code valide');
      return;
    }
    
    processScannedData(manualCodeInput.trim());
    setManualCodeInput('');
  };

  const activateSiteScan = () => {
    setScanMode('site');
    setErrorMessage('');
    setIsReadyForScan(true);
    
    // Montrer une alerte avec plusieurs options pour scanner
    Alert.alert(
      "Scanner un site",
      "Comment souhaitez-vous scanner le site ?",
      [
        {
          text: "Scanner manuellement",
          onPress: () => showManualSiteInput()
        },
        {
          text: "Simuler scan",
          onPress: handleSimulatedScan
        },
        {
          text: "Annuler",
          style: "cancel",
          onPress: () => setScanMode('')
        }
      ]
    );
  };

  // Fonction pour afficher une bo√Æte de dialogue pour saisir manuellement le code du site
  const showManualSiteInput = () => {
    // Utiliser Alert.prompt sur iOS, mais sur Android, cette fonction n'existe pas
    // donc nous utilisons une m√©thode alternative
    if (Platform.OS === 'ios') {
      Alert.prompt(
        "Scanner site manuellement",
        "Entrez le code ou le nom du site",
        [
          { text: "Annuler", onPress: () => setScanMode(''), style: "cancel" },
          { 
            text: "Scanner", 
            onPress: (code) => {
              if (code && code.trim()) {
                processScannedData(code.trim());
              } else {
                setScanMode('');
                Alert.alert("Erreur", "Veuillez entrer un code de site valide");
              }
            }
          }
        ],
        "plain-text"
      );
    } else {
      // Sur Android, utiliser une solution simple avec TextInput
      Alert.alert(
        "Scanner site manuellement",
        "Entrez le code du site dans le champ de texte en haut de l'√©cran, puis appuyez sur Scanner",
        [
          { text: "OK" }
        ]
      );
      // Focus sur le champ de saisie manuelle
      // Note: ceci est une approche simplifi√©e, une solution plus robuste
      // utiliserait un modal personnalis√© avec TextInput
      setManualCodeInput('');
      // On garde le mode scan actif pour que le bouton scanner manuel fonctionne
    }
  };

  // Afficher la page de s√©lection du type d'op√©ration
  const showOperationSelection = () => {
    setShowOperationTypeSelection(true);
  };

  // Commencer le scan de contenant avec un type d'op√©ration sp√©cifique
  const startContenantScan = (type) => {
    setOperationType(type);
    setShowOperationTypeSelection(false);
    setScanMode('contenant');
    setErrorMessage('');
    setIsReadyForScan(true);
    
    // Message diff√©rent selon le type d'op√©ration
    const message = type === 'entree' 
      ? "Veuillez scanner le code du contenant √† prendre en charge" 
      : "Veuillez scanner le code du contenant √† d√©poser";
    
    Alert.alert(
      type === 'entree' ? "Prise en charge" : "D√©p√¥t",
      message,
      [{ text: "Annuler", onPress: () => setScanMode('') }]
    );
  };

  const handleContenantScan = async (code) => {
    if (!siteScanned) {
      Alert.alert('Erreur', 'Veuillez d\'abord scanner un site');
      return;
    }

    try {
      // Mode d√©p√¥t (sortie) - v√©rifier que le colis est dans la liste des colis pris en charge
      if (operationType === 'sortie') {
        const isInTakingCare = takingCarePackages.some(pkg => pkg.code === code);
        if (!isInTakingCare) {
          Alert.alert(
            "Colis non reconnu",
            "Ce colis ne fait pas partie des colis que vous avez en prise en charge.",
            [{ text: "OK" }]
          );
          return;
        }
        
        // Retirer le colis de la liste des colis pris en charge
        setTakingCarePackages(takingCarePackages.filter(pkg => pkg.code !== code));
      }

      // Obtenir la date actuelle au format appropri√©
      const currentDate = new Date();
      const currentDateISO = currentDate.toISOString();

      // Ajouter le contenant √† la liste
      const newContenant = {
        id: Date.now().toString(),
        code: code,
        idColis: code,
        timeStamp: currentDate.toLocaleTimeString(),
        date: currentDate.toLocaleDateString(),
        scanDate: currentDateISO,
        site: siteCode,
        type: operationType, // Ajout du type d'op√©ration (entr√©e/sortie)
      };
      
      setScannedContenants([newContenant, ...scannedContenants]);
    } catch (error) {
      console.error('Erreur lors de la gestion du scan:', error);
      setScanMode('');
    }
  };

  const renderScannedItem = ({ item }) => (
    <View style={[styles.contenantItem, item.type === 'sortie' ? styles.contenantItemSortie : styles.contenantItemEntree]}>
      <View style={styles.contenantInfo}>
        <Text style={styles.contenantCode}>{item.code}</Text>
        <View style={styles.contenantTypeRow}>
          <View style={item.type === 'sortie' ? styles.typeTagSortie : styles.typeTagEntree}>
            <Text style={styles.typeTagText}>{item.type === 'sortie' ? 'D√©p√¥t' : 'Prise en charge'}</Text>
          </View>
          <Text style={styles.contenantTime}>{item.timeStamp}</Text>
        </View>
      </View>
      <TouchableOpacity
        style={styles.deleteContenantButton}
        onPress={() => removeScannedContenant(item.id)}
      >
        <Ionicons name="trash-outline" size={20} color="#e74c3c" />
      </TouchableOpacity>
    </View>
  );

  const removeScannedContenant = (id) => {
    setScannedContenants(scannedContenants.filter(contenant => contenant.id !== id));
  };

  const handleTransmit = async () => {
    if (scannedContenants.length === 0) {
      Alert.alert('Attention', 'Aucun contenant scann√© √† transmettre.');
      return;
    }

    setLoading(true);

    try {
      // V√©rifier et afficher les donn√©es de la session pour le d√©bogage
      console.log('Donn√©es de session:', JSON.stringify(sessionData, null, 2));
      console.log('Donn√©es de route:', JSON.stringify(route.params, null, 2));
      
      // R√©cup√©rer les donn√©es de la tourn√©e et du v√©hicule avec plus de v√©rifications
      const tourneeName = sessionData.tournee?.nom || route.params?.tournee?.nom || '';
      const tourneeId = sessionData.tournee?.id || route.params?.tournee?.id || '';
      const vehiculeName = sessionData.vehicule?.immatriculation || route.params?.vehicule?.immatriculation || '';
      const vehiculeId = sessionData.vehicule?.id || route.params?.vehicule?.id || '';
      
      // Utiliser les d√©tails du site valid√© s'ils sont disponibles
      let siteName, siteId, siteAdresse, siteCodePostal, siteVille;
      
      if (siteDetails) {
        // Utiliser les bonnes cl√©s du siteDetails (nommage uniforme)
        siteName = siteDetails.name || siteCode;
        siteId = siteDetails.id || '';
        siteAdresse = siteDetails.address || '';
        siteCodePostal = siteDetails.codePostal || '';
        siteVille = siteDetails.city || '';
      } else {
        // Sinon on utilise ce qu'on a par d√©faut
        siteName = sessionData.tournee?.siteDepart || route.params?.tournee?.siteDepart || siteCode || 'Non sp√©cifi√©';
        siteId = '';
      }
      
      console.log('Donn√©es r√©cup√©r√©es pour les scans:', {
        tourneeName,
        tourneeId,
        vehiculeName,
        vehiculeId,
        siteName,
        siteId,
        siteCode
      });

      // R√©cup√©rer l'ID de session actuel
      const currentSessionId = await AsyncStorage.getItem('currentSessionId') || `session_${Date.now()}`;
      
      // Pr√©parer les scans avec tous les champs n√©cessaires
      const scansToSubmit = scannedContenants.map(scan => {
        const scanDate = scan.scanDate || new Date().toISOString();
        
        // Le code du contenant devient l'ID du colis
        const scanItem = {
          code: scan.code,
          idColis: scan.code || scan.idColis,
          scanDate: scanDate,
          tournee: tourneeName,
          tourneeId: tourneeId,
          vehicule: vehiculeName,
          vehiculeId: vehiculeId,
          immatriculation: vehiculeName,
          site: siteName,
          siteId: siteId,
          siteCode: siteCode,
          siteDepart: siteName,
          siteD√©part: siteName,
          sessionId: currentSessionId, // Ajouter l'ID de session pour le filtrage ult√©rieur
          operationType: scan.type || 'entree', // Ajout du type d'op√©ration
          status: scan.type === 'sortie' ? 'livr√©' : 'en-cours', // Status bas√© sur le type d'op√©ration
          type: scan.type || 'entree' // Assurer que le type est inclus explicitement
        };
        
        // Ajouter siteFin uniquement pour les colis livr√©s
        if (scan.type === 'sortie') {
          // Pour les op√©rations de sortie (d√©p√¥t), ajouter des informations sp√©cifiques
          const currentDate = new Date();
          
          // Utiliser le nom du site actuel comme site d'arriv√©e
          scanItem.siteFin = siteName;
          // Ajouter date et heure d'arriv√©e au format correct
          scanItem.dateArrivee = currentDate.toLocaleDateString();
          scanItem.heureArrivee = currentDate.toLocaleTimeString();
          // Ajouter ces champs suppl√©mentaires pour assurer la compatibilit√©
          scanItem.dateHeureFin = currentDate.toISOString();
          scanItem.statut = 'Livr√©';
          scanItem.status = 'livr√©'; // Assurez-vous que les deux formats sont pr√©sents
          scanItem.coursierLivraison = sessionData.coursierCharg || route.params?.coursierCharg || '';
        }
        
        // Ajouter les d√©tails du site s'ils sont disponibles
        if (siteDetails) {
          scanItem.siteDetails = {
            adresse: siteAdresse,
            codePostal: siteCodePostal,
            ville: siteVille
          };
        }

        // Ajouter la localisation si disponible
        if (sessionData.location) {
          scanItem.location = {
            latitude: sessionData.location.coords.latitude,
            longitude: sessionData.location.coords.longitude,
            accuracy: sessionData.location.coords.accuracy
          };
        }

        return scanItem;
      });
      
      // Afficher les donn√©es qui seront transmises
      console.log('Transmission des scans:', JSON.stringify(scansToSubmit, null, 2)); // D√©comment√© pour d√©bogage
      
      // Envoyer les scans √† Firebase
      const result = await firebaseService.addScans(scansToSubmit);
      console.log('R√©sultat de la transmission:', result);
      
      // Si la transmission r√©ussit, mettre √† jour l'historique local
      if (result.success) {
        // --- Logique de consolidation --- 
        const updatedScansMap = new Map();
        historicalScans.forEach(scan => {
          // Assurer qu'on a un code pour la cl√© de la map
          if (scan.code) {
            updatedScansMap.set(scan.code, scan);
          }
        });
        scansToSubmit.forEach(scan => {
          if (scan.code) {
            const originalScan = scannedContenants.find(s => s.code === scan.code);
            const scanForHistory = {
              ...scan,
              timeStamp: originalScan?.timeStamp || dateUtils.formatTime(scan.scanDate),
            };
            updatedScansMap.set(scan.code, scanForHistory);
          }
        });
        const newHistory = Array.from(updatedScansMap.values());
        newHistory.sort((a, b) => {
          const dateA = a.scanDate ? new Date(a.scanDate).getTime() : 0;
          const dateB = b.scanDate ? new Date(b.scanDate).getTime() : 0;
          if (isNaN(dateA) && isNaN(dateB)) return 0;
          if (isNaN(dateA)) return 1;
          if (isNaN(dateB)) return -1;
          return dateB - dateA;
        });
        // --- Fin de la logique de consolidation ---

        // Sauvegarder l'historique consolid√© dans AsyncStorage
        await AsyncStorage.setItem('scanHistory', JSON.stringify(newHistory));
        
        // Mise √† jour de l'√©tat React DIFF√âR√âE apr√®s les interactions
        InteractionManager.runAfterInteractions(() => {
          setHistoricalScans(newHistory);
        });
        
        // Mettre √† jour la liste des paquets pris en charge
        if (operationType === 'entree') {
          setTakingCarePackages([...scansToSubmit, ...takingCarePackages]);
        } else if (operationType === 'sortie') {
          const codesDeposited = scansToSubmit.map(scan => scan.code);
          setTakingCarePackages(takingCarePackages.filter(pkg => pkg.code && !codesDeposited.includes(pkg.code)));
        }
        
        // R√©initialiser compl√®tement l'√©tat pour revenir √† l'√©cran de scan de site
        resetScan(); // Cette fonction r√©initialise les √©tats de base

        // S'assurer que tous les √©tats sont correctement r√©initialis√©s pour revenir √† l'√©cran initial
        setShowOperationTypeSelection(false);
        setOperationType('entree'); // R√©initialiser √† l'entr√©e de colis par d√©faut
        
        // Important: D√©sactiver le chargement AVANT l'alerte
        setLoading(false);
        
        // Afficher l'alerte de succ√®s
        Alert.alert(
          'Succ√®s',
          `${scansToSubmit.length} scan(s) transmis avec succ√®s`,
          [{ text: 'OK' }]
        );
      } else {
        setLoading(false);
        throw new Error(result.error || '√âchec de la transmission');
      }
    } catch (error) {
      console.error('Erreur lors de la transmission:', error);
      setLoading(false);
      Alert.alert('Erreur', `√âchec de la transmission: ${error.message}`);
    }
  };

  const resetScan = () => {
    setScanMode('');
    setSiteScanned(false);
    setSiteCode('');
    setScannedContenants([]);
    setManualCodeInput('');
    setSiteDetails(null);
  };

  const navigateToHistory = () => {
    setShowHistoryModal(true);
  };

  // Fonction pour obtenir les d√©tails de la session actuelle
  const getSessionDetails = async () => {
    try {
      const currentSession = await firebaseService.getCurrentSession();
      if (currentSession) {
        setSessionId(currentSession.id);
        setTournee(currentSession.tournee);
        setVehicule(currentSession.vehicule);
        setPole(currentSession.pole);
      }
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration de la session:", error);
    }
  };

  // Fonction pour effacer l'historique des scans
  const clearHistoricalScans = async () => {
    try {
      Alert.alert(
        'Effacer l\'historique',
        'Voulez-vous vraiment effacer tout l\'historique des scans?',
        [
          {
            text: 'Annuler',
            style: 'cancel'
          },
          {
            text: 'Effacer',
            onPress: async () => {
              await AsyncStorage.removeItem('scanHistory');
              setHistoricalScans([]);
              Alert.alert('Succ√®s', 'Historique effac√© avec succ√®s');
            },
            style: 'destructive'
          }
        ]
      );
    } catch (error) {
      console.error('Erreur lors de l\'effacement de l\'historique:', error);
      Alert.alert('Erreur', 'Impossible d\'effacer l\'historique');
    }
  };

  // Ajout d'une fonction pour effacer explicitement tous les scans de la session actuelle
  const clearCurrentSessionScans = async () => {
    try {
      const currentSessionId = await AsyncStorage.getItem('currentSessionId');
      if (!currentSessionId) {
        Alert.alert('Erreur', 'Impossible de d√©terminer la session actuelle');
        return;
      }
      
      Alert.alert(
        'R√©initialiser l\'historique',
        'Cette action va supprimer tous les scans associ√©s √† votre session actuelle. Continuer?',
        [
          {
            text: 'Annuler',
            style: 'cancel'
          },
          {
            text: 'Supprimer',
            onPress: async () => {
              try {
                // Supprimer les scans associ√©s √† la session actuelle
                setLoading(true);
                console.log(`Suppression des scans de la session ${currentSessionId}...`);
                
                // Fonction c√¥t√© service qui devrait √™tre impl√©ment√©e
                // pour supprimer tous les scans de la session
                const result = await firebaseService.clearSessionScans(currentSessionId);
                
                // Supprimer l'historique local √©galement
                await AsyncStorage.removeItem('scanHistory');
                setHistoricalScans([]);
                
                setLoading(false);
                Alert.alert('Succ√®s', 'Historique r√©initialis√© avec succ√®s');
              } catch (error) {
                setLoading(false);
                console.error('Erreur lors de la suppression des scans:', error);
                Alert.alert('Erreur', `√âchec de la suppression: ${error.message}`);
              }
            },
            style: 'destructive'
          }
        ]
      );
    } catch (error) {
      console.error('Erreur:', error);
      Alert.alert('Erreur', 'Une erreur est survenue');
    }
  };

  // Handler de d√©connexion avec effacement complet de l'historique
  const handleLogout = async () => {
    try {
      Alert.alert(
        'D√©connexion',
        'Voulez-vous vous d√©connecter? L\'historique des scans sera effac√©.',
        [
          {
            text: 'Annuler',
            style: 'cancel'
          },
          {
            text: 'D√©connecter',
            onPress: async () => {
              try {
                setLoading(true);
                console.log('D√©connexion en cours...');

                // Appeler la m√©thode de d√©connexion de Firebase
                await firebaseService.logout();
                console.log('D√©connexion Firebase r√©ussie');
                
                // Effacer toutes les donn√©es de session
                await AsyncStorage.removeItem('userSessionActive');
                // On conserve current_session_id pour que la tourn√©e visit√©e reste en m√©moire
                await AsyncStorage.removeItem('scanHistory');
                await AsyncStorage.removeItem('user_selas_id');
                
                // R√©initialiser les √©tats
                setHistoricalScans([]);
                setScannedContenants([]);
                setSiteScanned(false);
                setSiteCode('');
                
                setLoading(false);
                
                // Rediriger vers l'√©cran de connexion
                navigation.reset({
                  index: 0,
                  routes: [{ name: 'Login' }]
                });
              } catch (error) {
                setLoading(false);
                console.error('Erreur lors du processus de d√©connexion:', error);
                Alert.alert('Erreur', 'Impossible de se d√©connecter. Veuillez r√©essayer.');
              }
            }
          }
        ]
      );
    } catch (error) {
      console.error('Erreur lors de la d√©connexion:', error);
    }
  };

  // Utiliser directement les fonctions de formatage de dateUtils
  // au lieu de red√©finir des fonctions similaires

  // Effet pour √©couter les √©v√©nements de scan Zebra
  useEffect(() => {
    if (isReadyForScan) {
      // Afficher un message pour indiquer que l'application est pr√™te pour le scan
      console.log('Pr√™t √† recevoir des scans du scanner Zebra');
      
      // Configuration pour recevoir les scans du mat√©riel Zebra
      const handleZebraScan = (event) => {
        // Le scanner Zebra envoie g√©n√©ralement les donn√©es comme des entr√©es clavier
        // Nous devons v√©rifier que nous sommes en mode scan et traiter les donn√©es
        if (event && event.nativeEvent && event.nativeEvent.key === 'Enter' && scanMode) {
          // R√©cup√©rer le texte scann√© (par exemple depuis un champ de texte cach√© ou via une API Zebra)
          // Pour les besoins de cet exemple, nous utiliserons la valeur de manualCodeInput
          if (manualCodeInput.trim()) {
            processScannedData(manualCodeInput.trim());
            setManualCodeInput(''); // R√©initialiser apr√®s le traitement
          }
        }
      };
      
      // Ajoutez ici l'initialisation sp√©cifique au scanner Zebra si n√©cessaire
      // Exemple : ZebraScanner.initialize() si une API Zebra est disponible
      
      // Pour cet exemple, on simule en utilisant l'√©couteur de clavier (pour Enter)
      Keyboard.addListener('keyDown', handleZebraScan);
      
      return () => {
        // Nettoyage lors du d√©montage
        Keyboard.removeListener('keyDown', handleZebraScan);
        // D√©sinitialiser le scanner Zebra si n√©cessaire
        // Exemple : ZebraScanner.deinitialize()
      };
    }
  }, [isReadyForScan, scanMode, manualCodeInput]);


  const loadHistoricalScans = async () => {
    try {
      const jsonValue = await AsyncStorage.getItem('scanHistory');
      if (jsonValue !== null) {
        const history = JSON.parse(jsonValue);
        
        // R√©cup√©rer l'ID de la tourn√©e actuelle
        const currentSession = await firebaseService.getCurrentSession();
        const currentTourneeId = currentSession?.tournee?.id || sessionData?.tournee?.id || '';
        
        // Filtrer l'historique local
        const today = new Date();
        today.setHours(0, 0, 0, 0); // D√©but de la journ√©e
        
        const filteredHistory = history.filter(item => {
          // Convertir la date de l'item en objet Date
          let itemDate;
          try {
            itemDate = new Date(item.date);
            if (isNaN(itemDate.getTime())) {
              // Si la date n'est pas valide, essayer un autre format
              const parts = item.date.split('/');
              if (parts.length === 3) {
                itemDate = new Date(parts[2], parts[1] - 1, parts[0]);
              }
            }
          } catch (e) {
            // En cas d'erreur, consid√©rer cet item comme non valide pour le filtre
            return false;
          }

          // S'assurer que nous avons une date valide
          if (!itemDate || isNaN(itemDate.getTime())) return false;
          
          itemDate.setHours(0, 0, 0, 0); // Normaliser √† minuit
          
          // V√©rifier la tourn√©e
          const isSameTournee = !currentTourneeId || item.tourneeId === currentTourneeId;
          
          // V√©rifier le statut (inclut les visites sans colis)
          const hasValidStatus = item.status === 'en-cours' || item.status === 'livr√©';
          
          // L'item doit √™tre du jour courant ET de la m√™me tourn√©e ET avoir un statut valide
          return itemDate.getTime() === today.getTime() && isSameTournee && hasValidStatus;
        });
        
        console.log(`Historique local filtr√©: ${filteredHistory.length} scans (jour + tourn√©e + statut)`);
        
        // Consolider l'historique filtr√© avant de mettre √† jour l'√©tat
        const consolidatedHistory = consolidateAndSortScans([], filteredHistory);

        // Enrichir avec le nom complet du site depuis Firestore
        const enrichedHistory = await Promise.all(
          consolidatedHistory.map(async (scan) => {
            // Tenter de r√©cup√©rer les d√©tails du site en utilisant siteId ou code
            try {
              const siteIdentifier = scan.siteId || scan.code; // Utiliser ID ou code
              // V√©rifier si l'identifiant est probablement un site avant d'appeler getSiteById
              if (siteIdentifier && 
                  !siteIdentifier.startsWith('TEST_CONTENANT_') && 
                  !siteIdentifier.match(/^[0-9]{13,}$/)) { 
                const siteInfo = await firebaseService.getSiteById(siteIdentifier);
                if (siteInfo) {
                  // Enrichir le scan avec les d√©tails complets
                  return { 
                    ...scan, 
                    siteName: siteInfo.nom || siteInfo.name, // Ajouter le nom pour affichage facile
                    siteDetails: { ...siteInfo } 
                  };
                }
              }
            } catch (e) {
              console.warn(`[loadHistoricalScans] Erreur r√©cup√©ration d√©tails site pour ${scan.code || scan.id}:`, e);
            }
            // Si non trouv√© ou erreur, retourner le scan original
            return scan;
          })
        );
        
        // Mettre √† jour l'√©tat avec l'historique enrichi
        setHistoricalScans(enrichedHistory);
        setSessionHistoryLoaded(true);
      }
    } catch (error) {
      console.error('Erreur lors du chargement de l\'historique:', error);
    }
  };

  const loadFirestoreScans = async () => {
    try {
      // On ne charge les scans Firestore que si la session est active
      const userSessionActive = await AsyncStorage.getItem('userSessionActive');
      if (userSessionActive !== 'true') {
        // Si aucune session active, on ne charge pas l'historique Firestore
        return;
      }

      // R√©cup√©rer l'ID de session actuel
      const currentSessionId = await AsyncStorage.getItem('currentSessionId');
      console.log('Chargement des scans pour la session:', currentSessionId);

      // R√©cup√©rer l'ID de la tourn√©e actuelle
      const currentSession = await firebaseService.getCurrentSession();
      const currentTourneeId = currentSession?.tournee?.id || sessionData?.tournee?.id || '';
      console.log('Tourn√©e actuelle:', currentTourneeId);

      setLoading(true); // Afficher l'indicateur de chargement

      // R√©cup√©rer tous les scans de l'utilisateur (sans limite)
      const scans = await firebaseService.getScans();
      
      if (scans && scans.length > 0) {
        // Ne garder que les scans du jour (J0)
        const today = new Date();
        today.setHours(0, 0, 0, 0); // D√©but de la journ√©e
        
        const filteredScans = scans.filter(scan => {
          // Convertir la date du scan en objet Date
          const scanDate = dateUtils.convertTimestampToDate(scan.scanDate || scan.createdAt);
          if (!scanDate) return false;
          
          // R√©cup√©rer juste la date (sans l'heure)
          const scanDateOnly = new Date(scanDate);
          scanDateOnly.setHours(0, 0, 0, 0);
          
          // V√©rifier la tourn√©e (si une tourn√©e actuelle est d√©finie)
          const isSameTournee = !currentTourneeId || scan.tourneeId === currentTourneeId;
          
          // V√©rifier le statut (inclut "pas_de_colis")
          const hasValidStatus = scan.status === 'en-cours' || scan.status === 'livr√©';
          
          // Le scan doit √™tre du jour courant ET de la m√™me tourn√©e ET avoir un statut valide
          return scanDateOnly.getTime() === today.getTime() && isSameTournee && hasValidStatus;
        });
        
        // Convertir les scans Firestore filtr√©s en format compatible avec l'historique local
        const formattedScans = filteredScans.map(scan => {
          // D√©duire le statut si manquant, bas√© sur le type d'op√©ration
          let status = scan.status;
          if (!status) {
            status = scan.operationType === 'sortie' ? 'livr√©' : 'en-cours';
          }
          
          return {
            id: scan.id || Date.now().toString(),
            code: scan.code,
            timeStamp: dateUtils.formatTime(scan.scanDate || scan.createdAt),
            date: dateUtils.formatDate(scan.scanDate || scan.createdAt),
            site: scan.site,
            fromFirestore: true,
            sessionId: scan.sessionId,
            // Utiliser le statut (corrig√© si n√©cessaire)
            status: status, 
            // S'assurer que le type est aussi pr√©sent
            type: scan.operationType || (status === 'livr√©' ? 'sortie' : 'entree'), 
            tournee: scan.tournee || '',
            tourneeId: scan.tourneeId || '',
            scanDate: scan.scanDate ? dateUtils.convertTimestampToDate(scan.scanDate).toISOString() : (scan.createdAt ? dateUtils.convertTimestampToDate(scan.createdAt).toISOString() : new Date().toISOString()) // Garder une date ISO pour le tri
          };
        });
        
        // Consolider et trier
        const consolidatedScans = consolidateAndSortScans(historicalScans, formattedScans);
        // Enrichir avec le nom complet du site depuis Firestore
        const enrichedScans = await Promise.all(
          consolidatedScans.map(async (scan) => {
            try {
              // Tenter de r√©cup√©rer les d√©tails du site
              try {
                // Utiliser l'ID du site si disponible, sinon le code barre
                const siteIdentifier = scan.siteId || scan.code; // Assumer que siteId existe
                if (siteIdentifier && 
                    !siteIdentifier.startsWith('TEST_CONTENANT_') && 
                    !siteIdentifier.match(/^[0-9]{13,}$/)) {
                  // Utiliser une variable locale au lieu de r√©assigner l'√©tat siteDetails
                  const siteInfo = await firebaseService.getSiteById(siteIdentifier); 
                  if (siteInfo) {
                    // Modifier l'objet scan directement
                    scan.siteName = siteInfo.nom || siteInfo.name; // Utiliser le nom du site s'il est trouv√©
                    scan.siteDetails = siteInfo; // Ajouter les d√©tails au scan
                  } else {
                     // Si siteInfo est null, indiquer le nom comme code
                     scan.siteName = scan.code; 
                  }
                } else {
                   scan.siteName = scan.code; // Fallback si aucun identifiant
                }
              } catch (siteError) {
                console.warn(`[loadFirestoreScans] Impossible de r√©cup√©rer les d√©tails du site pour l'identifiant ${scan.siteId || scan.code}:`, siteError);
                scan.siteName = scan.code; // Afficher le code si erreur
              }
              
              // Ne r√©cup√©rer les informations sur le site que s'il ne s'agit pas d'un conteneur
              if (scan.site && 
                  !scan.site.startsWith('TEST_CONTENANT_') && 
                  !scan.site.match(/^[0-9]{13,}$/)) {
                const siteInfo = await firebaseService.getSiteById(scan.site);
                if (siteInfo) return { ...scan, siteDetails: { ...siteInfo } };
              }
            } catch (e) {
              console.error('Erreur r√©cup√©ration nom site Firestore:', e);
            }
            return scan;
          })
        );
        
        // Mettre √† jour l'√©tat avec l'historique enrichi
        setHistoricalScans(enrichedScans);
        setSessionHistoryLoaded(true);
        
        // Sauvegarder √©galement dans AsyncStorage pour la persistance locale temporaire
        await AsyncStorage.setItem('scanHistory', JSON.stringify(enrichedScans));
      }
      
      setLoading(false); // Masquer l'indicateur de chargement
    } catch (error) {
      console.error('Erreur lors du chargement des scans depuis Firestore:', error);
      setLoading(false); // Masquer l'indicateur de chargement en cas d'erreur
    }
  };

  // --- AJOUTER CETTE FONCTION D'AIDE --- 
  // Fonction pour consolider et trier les scans
  const consolidateAndSortScans = (existingScans, newScans) => {
    const map = new Map();

    // Ajouter les scans existants √† la map
    existingScans.forEach(scan => {
      if (scan.code) map.set(scan.code, scan);
    });

    // Mettre √† jour ou ajouter les nouveaux scans
    newScans.forEach(scan => {
      if (scan.code) map.set(scan.code, scan);
    });

    // Convertir la map en tableau
    const consolidated = Array.from(map.values());

    // Trier
    consolidated.sort((a, b) => {
      const dateA = a.scanDate ? new Date(a.scanDate).getTime() : 0;
      const dateB = b.scanDate ? new Date(b.scanDate).getTime() : 0;
      if (isNaN(dateA) && isNaN(dateB)) return 0;
      if (isNaN(dateA)) return 1;
      if (isNaN(dateB)) return -1;
      return dateB - dateA;
    });

    return consolidated;
  };
  // --- FIN DE L'AJOUT ---

  const loadTakingCarePackages = async () => {
    try {
      const scansEnCours = await firebaseService.getScansEnCours();
      // Filtrer pour exclure les scans "pas_de_colis"
      const filteredScans = scansEnCours.filter(scan => 
        scan.status !== 'pas_de_colis' &&
        !(scan.code && scan.code.startsWith('SITE_'))
      );
      console.log(`‚úÖ ${filteredScans.length} paquet(s) pris en charge r√©cup√©r√©(s) (sans les "pas_de_colis")`);
      setTakingCarePackages(filteredScans);
    } catch (error) {
      console.error('‚ùå Erreur lors du chargement des paquets pris en charge:', error);
    }
  };

  // üîπ Simulation d'un scan avec des sites valides
  const simulateScan = () => {
    if (scanMode === 'site') {
      // Sites de test qui seront reconnus comme valides
      const sitesDemoValides = [
        'SITE123',
        'SITE456',
        'SITE789',
        'LAB001',
        '12345'
      ];
      
      // S√©lectionner un site al√©atoire parmi les sites valides pour la d√©mo
      return sitesDemoValides[Math.floor(Math.random() * sitesDemoValides.length)];
    } else {
      // Si on est en mode sortie (d√©p√¥t), on doit scanner un colis d√©j√† pris en charge
      if (operationType === 'sortie') {
        // V√©rifier si des colis sont disponibles
        if (takingCarePackages.length > 0) {
          // S√©lectionner un colis al√©atoire parmi les colis pris en charge
          const randomPackage = takingCarePackages[Math.floor(Math.random() * takingCarePackages.length)];
          return randomPackage.code;
        } else {
          // Aucun colis disponible pour le d√©p√¥t - cette condition est g√©r√©e dans handleSimulatedScan
          return '';
        }
      } else {
        // Simuler un scan de contenant pour prise en charge
        // Utiliser un pr√©fixe sp√©cifique pour les tests afin de pouvoir les identifier facilement
        const testId = Date.now(); // Utiliser le timestamp actuel pour cr√©er un ID unique
        return `TEST_CONTENANT_${testId}`;
      }
    }
  };

  // Modification pour les tests : fonction mock qui simule verifySiteCode
  const mockVerifySiteCode = async (siteCode) => {
    // Sites de test qui seront automatiquement valid√©s
    const sitesDemoValides = {
      'SITE123': { nom: 'Site Test 1', adresse: '123 Rue Principale', ville: 'Paris', codePostal: '75001' },
      'SITE456': { nom: 'Site Test 2', adresse: '456 Avenue R√©publique', ville: 'Lyon', codePostal: '69001' },
      'SITE789': { nom: 'Site Test 3', adresse: '789 Boulevard des Tests', ville: 'Toulouse', codePostal: '31000' },
      '12345': { nom: 'Laboratoire Central', adresse: '12 Rue des Sciences', ville: 'Montpellier', codePostal: '34000' },
      'LAB001': { nom: 'Laboratoire Mobile', adresse: 'Zone Industrielle', ville: 'Bordeaux', codePostal: '33000' }
    };

    // V√©rifier si le code scann√© est dans notre liste de sites de test
    if (sitesDemoValides[siteCode]) {
      // Retourner une structure simulant la r√©ponse de Firebase
      return {
        valid: true,
        site: {
          id: `mock_${siteCode}`,
          code: siteCode,
          nom: sitesDemoValides[siteCode].nom,
          adresse: sitesDemoValides[siteCode].adresse,
          ville: sitesDemoValides[siteCode].ville,
          codePostal: sitesDemoValides[siteCode].codePostal
        }
      };
    }

    // Si ce n'est pas un site de test, passer √† la v√©rification normale dans Firebase
    return await firebaseService.verifySiteCode(siteCode);
  };

  const processScannedData = async (data) => {
    console.log('Code scann√©:', data);
    try {
      // Cas 1: Nous n'avons pas encore scann√© de site
      if (!siteScanned && scanMode === 'site') {
        console.log('[processScannedData] Mode: Scan de site. Donn√©es:', data);
        const siteVerification = await firebaseService.verifySiteCode(data);
        console.log('[processScannedData] R√©sultat de verifySiteCode:', JSON.stringify(siteVerification));

        if (siteVerification.site) {
          // Enregistrer les infos du site
          setSiteCode(data);
          setSiteDetails(siteVerification.site);
          // setSiteScanned(true); // Mis plus bas pour ne l'activer qu'apr√®s succ√®s
          // setScanMode(''); // Mis plus bas
          // setShowOperationTypeSelection(true); // Mis plus bas

          // --- MODIFI√â: Ne trouver que le premier site non visit√© avec ce nom ---
          let occurrenceIndex = null;
          if (tourneeProgressRef.current?.getSitesWithStatus) {
            const sitesList = tourneeProgressRef.current.getSitesWithStatus();
            console.log('[processScannedData] sitesList depuis tourneeProgressRef:', JSON.stringify(sitesList.map(s => ({ id: s.id, name: s.name, visited: s.visited, uniqueDisplayId: s.uniqueDisplayId }))));
            const siteNameToFind = siteVerification.site.nom || siteVerification.site.name;
            console.log('[processScannedData] Nom du site √† trouver:', siteNameToFind);

            // Trouver le premier site non visit√© avec ce nom
            occurrenceIndex = sitesList.findIndex(s => !s.visited && (s.name === siteNameToFind || s.nom === siteNameToFind)); // Ajout de s.nom
            console.log(`[processScannedData] Occurrence index trouv√©e pour ${siteNameToFind}:`, occurrenceIndex);
            
            // Si aucun site non visit√© n'est trouv√©, ne rien faire
            if (occurrenceIndex === -1) {
              Alert.alert(
                'Site d√©j√† visit√© ou non trouv√©', // Message mis √† jour
                'Ce site a d√©j√† √©t√© visit√©, ne fait pas partie de cette tourn√©e, ou son nom ne correspond pas exactement.', // Message mis √† jour
                [{ text: 'OK', onPress: () => {
                  // R√©initialiser l'√©tat pour permettre un nouveau scan
                  setSiteScanned(false);
                  setSiteDetails(null);
                  setSiteCode('');
                  setShowOperationTypeSelection(false);
                }}]
              );
              return;
            }
          } else {
            console.warn('[processScannedData] tourneeProgressRef.current.getSitesWithStatus non disponible.');
            Alert.alert('Erreur', 'Impossible de r√©cup√©rer la liste des sites de la tourn√©e.');
            return;
          }

          // Marquage en session via l'index si trouv√©, sinon par site.id
          const identifier = siteVerification.site.id || (siteVerification.site.code || data);
          console.log('[processScannedData] Identifier pour markSiteVisitedInSession:', identifier);
          console.log('[processScannedData] currentSessionId avant appel:', currentSessionId);
          console.log('[processScannedData] occurrenceIndex avant appel:', occurrenceIndex);

          if (!currentSessionId) {
            console.error('[processScannedData] ID de session manquant avant markSiteVisitedInSession');
            Alert.alert('Erreur Critique', 'ID de session manquant. Impossible de continuer.');
            return;
          }
          
          // Ne marquer qu'un seul site √† la fois, en utilisant l'index sp√©cifique
          if (occurrenceIndex !== -1 && occurrenceIndex !== null) { // Condition d√©j√† pr√©sente, mais on log avant
            const markSuccess = await firebaseService.markSiteVisitedInSession(currentSessionId, identifier, occurrenceIndex);
            console.log('[processScannedData] R√©sultat de markSiteVisitedInSession:', markSuccess);
            
            if (markSuccess) {
              setSiteScanned(true); // Activer seulement si le marquage Firestore a r√©ussi
              setScanMode(''); 
              setShowOperationTypeSelection(true);

              // Mise √† jour du UI local - mettre √† jour uniquement le site sp√©cifique
              if (tourneeProgressRef.current?.markSiteAsVisitedLocally) {
                console.log('[processScannedData] Appel de markSiteAsVisitedLocally avec:', identifier, occurrenceIndex);
                await tourneeProgressRef.current.markSiteAsVisitedLocally(identifier, occurrenceIndex); // AJOUT DE AWAIT
                // Temporairement comment√© pour tester si la coche se met √† jour correctement sans rechargement imm√©diat
                // await updateTourneeProgress(); 
              } else if (tourneeProgressRef.current?.loadTourneeDetails) {
                console.log('[processScannedData] Appel de loadTourneeDetails(true) car markSiteAsVisitedLocally non dispo.');
                await tourneeProgressRef.current.loadTourneeDetails(true);
              }
            } else {
              Alert.alert('Erreur', '√âchec du marquage du site comme visit√© dans la session Firestore.');
              // Garder siteScanned √† false, etc.
            }
            
            // Si updateTourneeProgress a √©t√© comment√©, on peut appeler loadHistoricalData ici
            // si c'est n√©cessaire pour d'autres parties de l'UI non li√©es √† TourneeProgress.
            // Pour l'instant, on isole le probl√®me de la coche.
            // await loadHistoricalData(); 

          } else {
             console.warn('[processScannedData] occurrenceIndex invalide, markSiteVisitedInSession non appel√©.');
             // Potentiellement une alerte ici si ce cas ne devrait pas arriver
          }
          return;
        } else { // siteVerification.site est null/undefined
          console.log('[processScannedData] Aucun site valide retourn√© par verifySiteCode pour le code:', data);
          Alert.alert('Site Inconnu', 'Le code scann√© ne correspond √† aucun site connu.');
           // R√©initialiser pour permettre un nouveau scan
          setSiteScanned(false);
          setSiteDetails(null);
          setSiteCode('');
          setShowOperationTypeSelection(false);
        }
      }
      
      // Cas 2: Site d√©j√† scann√©, nous scannons maintenant un contenant
      if (siteScanned && scanMode === 'contenant') {
        console.log('[processScannedData] Mode: Scan de contenant. Donn√©es:', data);
        handleContenantScan(data);
        // Rester en mode scan contenant pour permettre les scans multiples
        setScanMode('contenant');
      }
    } catch (error) {
      console.error('Erreur lors de la gestion du scan:', error);
      setErrorMessage('Erreur: ' + error.message); // Afficher l'erreur √† l'utilisateur
      setScanMode(''); // R√©initialiser le mode scan
      // Optionnel: r√©initialiser d'autres √©tats si n√©cessaire
      setSiteScanned(false);
      setSiteDetails(null);
      setSiteCode('');
      setShowOperationTypeSelection(false);
    }
  };

  // G√©rer la simulation d'un scan (pour le d√©veloppement et les tests)
  const handleSimulatedScan = () => {
    // V√©rifier si on est en mode sortie sans colis pris en charge
    if (scanMode === 'contenant' && operationType === 'sortie' && takingCarePackages.length === 0) {
      Alert.alert(
        "Aucun colis disponible",
        "Vous n'avez aucun colis en prise en charge √† d√©poser.",
        [{ text: "OK" }]
      );
      return;
    }
    
    const fakeData = simulateScan();
    if (fakeData) {
      console.log(`Simulation de scan avec donn√©es: ${fakeData}`);
    processScannedData(fakeData);
    } else {
      console.error("Erreur lors de la simulation du scan: aucune donn√©e g√©n√©r√©e");
      Alert.alert(
        "Erreur",
        "Impossible de simuler un scan. Veuillez r√©essayer.",
        [{ text: "OK" }]
      );
    }
  };

  const handleManualScan = () => {
    if (manualCodeInput.trim() === '') {
      Alert.alert('Erreur', 'Veuillez entrer un code valide');
      return;
    }
    
    processScannedData(manualCodeInput.trim());
    setManualCodeInput('');
  };

  const activateSiteScan = () => {
    setScanMode('site');
    setErrorMessage('');
    setIsReadyForScan(true);
    
    // Montrer une alerte avec plusieurs options pour scanner
    Alert.alert(
      "Scanner un site",
      "Comment souhaitez-vous scanner le site ?",
      [
        {
          text: "Scanner manuellement",
          onPress: () => showManualSiteInput()
        },
        {
          text: "Simuler scan",
          onPress: handleSimulatedScan
        },
        {
          text: "Annuler",
          style: "cancel",
          onPress: () => setScanMode('')
        }
      ]
    );
  };

  // Fonction pour afficher une bo√Æte de dialogue pour saisir manuellement le code du site
  const showManualSiteInput = () => {
    // Utiliser Alert.prompt sur iOS, mais sur Android, cette fonction n'existe pas
    // donc nous utilisons une m√©thode alternative
    if (Platform.OS === 'ios') {
      Alert.prompt(
        "Scanner site manuellement",
        "Entrez le code ou le nom du site",
        [
          { text: "Annuler", onPress: () => setScanMode(''), style: "cancel" },
          { 
            text: "Scanner", 
            onPress: (code) => {
              if (code && code.trim()) {
                processScannedData(code.trim());
              } else {
                setScanMode('');
                Alert.alert("Erreur", "Veuillez entrer un code de site valide");
              }
            }
          }
        ],
        "plain-text"
      );
    } else {
      // Sur Android, utiliser une solution simple avec TextInput
      Alert.alert(
        "Scanner site manuellement",
        "Entrez le code du site dans le champ de texte en haut de l'√©cran, puis appuyez sur Scanner",
        [
          { text: "OK" }
        ]
      );
      // Focus sur le champ de saisie manuelle
      // Note: ceci est une approche simplifi√©e, une solution plus robuste
      // utiliserait un modal personnalis√© avec TextInput
      setManualCodeInput('');
      // On garde le mode scan actif pour que le bouton scanner manuel fonctionne
    }
  };

  // Afficher la page de s√©lection du type d'op√©ration
  const showOperationSelection = () => {
    setShowOperationTypeSelection(true);
  };

  // Commencer le scan de contenant avec un type d'op√©ration sp√©cifique
  const startContenantScan = (type) => {
    setOperationType(type);
    setShowOperationTypeSelection(false);
    setScanMode('contenant');
    setErrorMessage('');
    setIsReadyForScan(true);
    
    // Message diff√©rent selon le type d'op√©ration
    const message = type === 'entree' 
      ? "Veuillez scanner le code du contenant √† prendre en charge" 
      : "Veuillez scanner le code du contenant √† d√©poser";
    
    Alert.alert(
      type === 'entree' ? "Prise en charge" : "D√©p√¥t",
      message,
      [{ text: "Annuler", onPress: () => setScanMode('') }]
    );
  };

  const handleContenantScan = async (code) => {
    if (!siteScanned) {
      Alert.alert('Erreur', 'Veuillez d\'abord scanner un site');
      return;
    }

    try {
      // Mode d√©p√¥t (sortie) - v√©rifier que le colis est dans la liste des colis pris en charge
      if (operationType === 'sortie') {
        const isInTakingCare = takingCarePackages.some(pkg => pkg.code === code);
        if (!isInTakingCare) {
          Alert.alert(
            "Colis non reconnu",
            "Ce colis ne fait pas partie des colis que vous avez en prise en charge.",
            [{ text: "OK" }]
          );
          return;
        }
        
        // Retirer le colis de la liste des colis pris en charge
        setTakingCarePackages(takingCarePackages.filter(pkg => pkg.code !== code));
      }

      // Obtenir la date actuelle au format appropri√©
      const currentDate = new Date();
      const currentDateISO = currentDate.toISOString();

      // Ajouter le contenant √† la liste
      const newContenant = {
        id: Date.now().toString(),
        code: code,
        idColis: code,
        timeStamp: currentDate.toLocaleTimeString(),
        date: currentDate.toLocaleDateString(),
        scanDate: currentDateISO,
        site: siteCode,
        type: operationType, // Ajout du type d'op√©ration (entr√©e/sortie)
      };
      
      setScannedContenants([newContenant, ...scannedContenants]);
    } catch (error) {
      console.error('Erreur lors de la gestion du scan:', error);
      setScanMode('');
    }
  };

  const renderScannedItem = ({ item }) => (
    <View style={[styles.contenantItem, item.type === 'sortie' ? styles.contenantItemSortie : styles.contenantItemEntree]}>
      <View style={styles.contenantInfo}>
        <Text style={styles.contenantCode}>{item.code}</Text>
        <View style={styles.contenantTypeRow}>
          <View style={item.type === 'sortie' ? styles.typeTagSortie : styles.typeTagEntree}>
            <Text style={styles.typeTagText}>{item.type === 'sortie' ? 'D√©p√¥t' : 'Prise en charge'}</Text>
          </View>
          <Text style={styles.contenantTime}>{item.timeStamp}</Text>
        </View>
      </View>
      <TouchableOpacity
        style={styles.deleteContenantButton}
        onPress={() => removeScannedContenant(item.id)}
      >
        <Ionicons name="trash-outline" size={20} color="#e74c3c" />
      </TouchableOpacity>
    </View>
  );

  const removeScannedContenant = (id) => {
    setScannedContenants(scannedContenants.filter(contenant => contenant.id !== id));
  };

  const handleTransmit = async () => {
    if (scannedContenants.length === 0) {
      Alert.alert('Attention', 'Aucun contenant scann√© √† transmettre.');
      return;
    }

    setLoading(true);

    try {
      // V√©rifier et afficher les donn√©es de la session pour le d√©bogage
      console.log('Donn√©es de session:', JSON.stringify(sessionData, null, 2));
      console.log('Donn√©es de route:', JSON.stringify(route.params, null, 2));
      
      // R√©cup√©rer les donn√©es de la tourn√©e et du v√©hicule avec plus de v√©rifications
      const tourneeName = sessionData.tournee?.nom || route.params?.tournee?.nom || '';
      const tourneeId = sessionData.tournee?.id || route.params?.tournee?.id || '';
      const vehiculeName = sessionData.vehicule?.immatriculation || route.params?.vehicule?.immatriculation || '';
      const vehiculeId = sessionData.vehicule?.id || route.params?.vehicule?.id || '';
      
      // Utiliser les d√©tails du site valid√© s'ils sont disponibles
      let siteName, siteId, siteAdresse, siteCodePostal, siteVille;
      
      if (siteDetails) {
        // Utiliser les bonnes cl√©s du siteDetails (nommage uniforme)
        siteName = siteDetails.name || siteCode;
        siteId = siteDetails.id || '';
        siteAdresse = siteDetails.address || '';
        siteCodePostal = siteDetails.codePostal || '';
        siteVille = siteDetails.city || '';
      } else {
        // Sinon on utilise ce qu'on a par d√©faut
        siteName = sessionData.tournee?.siteDepart || route.params?.tournee?.siteDepart || siteCode || 'Non sp√©cifi√©';
        siteId = '';
      }
      
      console.log('Donn√©es r√©cup√©r√©es pour les scans:', {
        tourneeName,
        tourneeId,
        vehiculeName,
        vehiculeId,
        siteName,
        siteId,
        siteCode
      });

      // R√©cup√©rer l'ID de session actuel
      const currentSessionId = await AsyncStorage.getItem('currentSessionId') || `session_${Date.now()}`;
      
      // Pr√©parer les scans avec tous les champs n√©cessaires
      const scansToSubmit = scannedContenants.map(scan => {
        const scanDate = scan.scanDate || new Date().toISOString();
        
        // Le code du contenant devient l'ID du colis
        const scanItem = {
          code: scan.code,
          idColis: scan.code || scan.idColis,
          scanDate: scanDate,
          tournee: tourneeName,
          tourneeId: tourneeId,
          vehicule: vehiculeName,
          vehiculeId: vehiculeId,
          immatriculation: vehiculeName,
          site: siteName,
          siteId: siteId,
          siteCode: siteCode,
          siteDepart: siteName,
          siteD√©part: siteName,
          sessionId: currentSessionId, // Ajouter l'ID de session pour le filtrage ult√©rieur
          operationType: scan.type || 'entree', // Ajout du type d'op√©ration
          status: scan.type === 'sortie' ? 'livr√©' : 'en-cours', // Status bas√© sur le type d'op√©ration
          type: scan.type || 'entree' // Assurer que le type est inclus explicitement
        };
        
        // Ajouter siteFin uniquement pour les colis livr√©s
        if (scan.type === 'sortie') {
          // Pour les op√©rations de sortie (d√©p√¥t), ajouter des informations sp√©cifiques
          const currentDate = new Date();
          
          // Utiliser le nom du site actuel comme site d'arriv√©e
          scanItem.siteFin = siteName;
          // Ajouter date et heure d'arriv√©e au format correct
          scanItem.dateArrivee = currentDate.toLocaleDateString();
          scanItem.heureArrivee = currentDate.toLocaleTimeString();
          // Ajouter ces champs suppl√©mentaires pour assurer la compatibilit√©
          scanItem.dateHeureFin = currentDate.toISOString();
          scanItem.statut = 'Livr√©';
          scanItem.status = 'livr√©'; // Assurez-vous que les deux formats sont pr√©sents
          scanItem.coursierLivraison = sessionData.coursierCharg || route.params?.coursierCharg || '';
        }
        
        // Ajouter les d√©tails du site s'ils sont disponibles
        if (siteDetails) {
          scanItem.siteDetails = {
            adresse: siteAdresse,
            codePostal: siteCodePostal,
            ville: siteVille
          };
        }

        // Ajouter la localisation si disponible
        if (sessionData.location) {
          scanItem.location = {
            latitude: sessionData.location.coords.latitude,
            longitude: sessionData.location.coords.longitude,
            accuracy: sessionData.location.coords.accuracy
          };
        }

        return scanItem;
      });
      
      // Afficher les donn√©es qui seront transmises
      console.log('Transmission des scans:', JSON.stringify(scansToSubmit, null, 2)); // D√©comment√© pour d√©bogage
      
      // Envoyer les scans √† Firebase
      const result = await firebaseService.addScans(scansToSubmit);
      console.log('R√©sultat de la transmission:', result);
      
      // Si la transmission r√©ussit, mettre √† jour l'historique local
      if (result.success) {
        // --- Logique de consolidation --- 
        const updatedScansMap = new Map();
        historicalScans.forEach(scan => {
          // Assurer qu'on a un code pour la cl√© de la map
          if (scan.code) {
            updatedScansMap.set(scan.code, scan);
          }
        });
        scansToSubmit.forEach(scan => {
          if (scan.code) {
            const originalScan = scannedContenants.find(s => s.code === scan.code);
            const scanForHistory = {
              ...scan,
              timeStamp: originalScan?.timeStamp || dateUtils.formatTime(scan.scanDate),
            };
            updatedScansMap.set(scan.code, scanForHistory);
          }
        });
        const newHistory = Array.from(updatedScansMap.values());
        newHistory.sort((a, b) => {
          const dateA = a.scanDate ? new Date(a.scanDate).getTime() : 0;
          const dateB = b.scanDate ? new Date(b.scanDate).getTime() : 0;
          if (isNaN(dateA) && isNaN(dateB)) return 0;
          if (isNaN(dateA)) return 1;
          if (isNaN(dateB)) return -1;
          return dateB - dateA;
        });
        // --- Fin de la logique de consolidation ---

        // Sauvegarder l'historique consolid√© dans AsyncStorage
        await AsyncStorage.setItem('scanHistory', JSON.stringify(newHistory));
        
        // Mise √† jour de l'√©tat React DIFF√âR√âE apr√®s les interactions
        InteractionManager.runAfterInteractions(() => {
          setHistoricalScans(newHistory);
        });
        
        // Mettre √† jour la liste des paquets pris en charge
        if (operationType === 'entree') {
          setTakingCarePackages([...scansToSubmit, ...takingCarePackages]);
        } else if (operationType === 'sortie') {
          const codesDeposited = scansToSubmit.map(scan => scan.code);
          setTakingCarePackages(takingCarePackages.filter(pkg => pkg.code && !codesDeposited.includes(pkg.code)));
        }
        
        // R√©initialiser compl√®tement l'√©tat pour revenir √† l'√©cran de scan de site
        resetScan(); // Cette fonction r√©initialise les √©tats de base

        // S'assurer que tous les √©tats sont correctement r√©initialis√©s pour revenir √† l'√©cran initial
        setShowOperationTypeSelection(false);
        setOperationType('entree'); // R√©initialiser √† l'entr√©e de colis par d√©faut
        
        // Important: D√©sactiver le chargement AVANT l'alerte
        setLoading(false);
        
        // Afficher l'alerte de succ√®s
        Alert.alert(
          'Succ√®s',
          `${scansToSubmit.length} scan(s) transmis avec succ√®s`,
          [{ text: 'OK' }]
        );
      } else {
        setLoading(false);
        throw new Error(result.error || '√âchec de la transmission');
      }
    } catch (error) {
      console.error('Erreur lors de la transmission:', error);
      setLoading(false);
      Alert.alert('Erreur', `√âchec de la transmission: ${error.message}`);
    }
  };

  const resetScan = () => {
    setScanMode('');
    setSiteScanned(false);
    setSiteCode('');
    setScannedContenants([]);
    setManualCodeInput('');
    setSiteDetails(null);
  };

  const navigateToHistory = () => {
    setShowHistoryModal(true);
  };

  // Fonction pour obtenir les d√©tails de la session actuelle
  const getSessionDetails = async () => {
    try {
      const currentSession = await firebaseService.getCurrentSession();
      if (currentSession) {
        setSessionId(currentSession.id);
        setTournee(currentSession.tournee);
        setVehicule(currentSession.vehicule);
        setPole(currentSession.pole);
      }
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration de la session:", error);
    }
  };

  // Fonction pour effacer l'historique des scans
  const clearHistoricalScans = async () => {
    try {
      Alert.alert(
        'Effacer l\'historique',
        'Voulez-vous vraiment effacer tout l\'historique des scans?',
        [
          {
            text: 'Annuler',
            style: 'cancel'
          },
          {
            text: 'Effacer',
            onPress: async () => {
              await AsyncStorage.removeItem('scanHistory');
              setHistoricalScans([]);
              Alert.alert('Succ√®s', 'Historique effac√© avec succ√®s');
            },
            style: 'destructive'
          }
        ]
      );
    } catch (error) {
      console.error('Erreur lors de l\'effacement de l\'historique:', error);
      Alert.alert('Erreur', 'Impossible d\'effacer l\'historique');
    }
  };

  // Ajout d'une fonction pour effacer explicitement tous les scans de la session actuelle
  const clearCurrentSessionScans = async () => {
    try {
      const currentSessionId = await AsyncStorage.getItem('currentSessionId');
      if (!currentSessionId) {
        Alert.alert('Erreur', 'Impossible de d√©terminer la session actuelle');
        return;
      }
      
      Alert.alert(
        'R√©initialiser l\'historique',
        'Cette action va supprimer tous les scans associ√©s √† votre session actuelle. Continuer?',
        [
          {
            text: 'Annuler',
            style: 'cancel'
          },
          {
            text: 'Supprimer',
            onPress: async () => {
              try {
                // Supprimer les scans associ√©s √† la session actuelle
                setLoading(true);
                console.log(`Suppression des scans de la session ${currentSessionId}...`);
                
                // Fonction c√¥t√© service qui devrait √™tre impl√©ment√©e
                // pour supprimer tous les scans de la session
                const result = await firebaseService.clearSessionScans(currentSessionId);
                
                // Supprimer l'historique local √©galement
                await AsyncStorage.removeItem('scanHistory');
                setHistoricalScans([]);
                
                setLoading(false);
                Alert.alert('Succ√®s', 'Historique r√©initialis√© avec succ√®s');
              } catch (error) {
                setLoading(false);
                console.error('Erreur lors de la suppression des scans:', error);
                Alert.alert('Erreur', `√âchec de la suppression: ${error.message}`);
              }
            },
            style: 'destructive'
          }
        ]
      );
    } catch (error) {
      console.error('Erreur:', error);
      Alert.alert('Erreur', 'Une erreur est survenue');
    }
  };

  // Handler de d√©connexion avec effacement complet de l'historique
  const handleLogout = async () => {
    try {
      Alert.alert(
        'D√©connexion',
        'Voulez-vous vous d√©connecter? L\'historique des scans sera effac√©.',
        [
          {
            text: 'Annuler',
            style: 'cancel'
          },
          {
            text: 'D√©connecter',
            onPress: async () => {
              try {
                setLoading(true);
                console.log('D√©connexion en cours...');

                // Appeler la m√©thode de d√©connexion de Firebase
                await firebaseService.logout();
                console.log('D√©connexion Firebase r√©ussie');
                
                // Effacer toutes les donn√©es de session
                await AsyncStorage.removeItem('userSessionActive');
                // On conserve current_session_id pour que la tourn√©e visit√©e reste en m√©moire
                await AsyncStorage.removeItem('scanHistory');
                await AsyncStorage.removeItem('user_selas_id');
                
                // R√©initialiser les √©tats
                setHistoricalScans([]);
                setScannedContenants([]);
                setSiteScanned(false);
                setSiteCode('');
                
                setLoading(false);
                
                // Rediriger vers l'√©cran de connexion
                navigation.reset({
                  index: 0,
                  routes: [{ name: 'Login' }]
                });
              } catch (error) {
                setLoading(false);
                console.error('Erreur lors du processus de d√©connexion:', error);
                Alert.alert('Erreur', 'Impossible de se d√©connecter. Veuillez r√©essayer.');
              }
            }
          }
        ]
      );
    } catch (error) {
      console.error('Erreur lors de la d√©connexion:', error);
    }
  };

  // Utiliser directement les fonctions de formatage de dateUtils
  // au lieu de red√©finir des fonctions similaires

  // Effet pour √©couter les √©v√©nements de scan Zebra
  useEffect(() => {
    if (isReadyForScan) {
      // Afficher un message pour indiquer que l'application est pr√™te pour le scan
      console.log('Pr√™t √† recevoir des scans du scanner Zebra');
      
      // Configuration pour recevoir les scans du mat√©riel Zebra
      const handleZebraScan = (event) => {
        // Le scanner Zebra envoie g√©n√©ralement les donn√©es comme des entr√©es clavier
        // Nous devons v√©rifier que nous sommes en mode scan et traiter les donn√©es
        if (event && event.nativeEvent && event.nativeEvent.key === 'Enter' && scanMode) {
          // R√©cup√©rer le texte scann√© (par exemple depuis un champ de texte cach√© ou via une API Zebra)
          // Pour les besoins de cet exemple, nous utiliserons la valeur de manualCodeInput
          if (manualCodeInput.trim()) {
            processScannedData(manualCodeInput.trim());
            setManualCodeInput(''); // R√©initialiser apr√®s le traitement
          }
        }
      };
      
      // Ajoutez ici l'initialisation sp√©cifique au scanner Zebra si n√©cessaire
      // Exemple : ZebraScanner.initialize() si une API Zebra est disponible
      
      // Pour cet exemple, on simule en utilisant l'√©couteur de clavier (pour Enter)
      Keyboard.addListener('keyDown', handleZebraScan);
      
      return () => {
        // Nettoyage lors du d√©montage
        Keyboard.removeListener('keyDown', handleZebraScan);
        // D√©sinitialiser le scanner Zebra si n√©cessaire
        // Exemple : ZebraScanner.deinitialize()
      };
    }
  }, [isReadyForScan, scanMode, manualCodeInput]);


  const loadHistoricalScans = async () => {
    try {
      const jsonValue = await AsyncStorage.getItem('scanHistory');
      if (jsonValue !== null) {
        const history = JSON.parse(jsonValue);
        
        // R√©cup√©rer l'ID de la tourn√©e actuelle
        const currentSession = await firebaseService.getCurrentSession();
        const currentTourneeId = currentSession?.tournee?.id || sessionData?.tournee?.id || '';
        
        // Filtrer l'historique local
        const today = new Date();
        today.setHours(0, 0, 0, 0); // D√©but de la journ√©e
        
        const filteredHistory = history.filter(item => {
          // Convertir la date de l'item en objet Date
          let itemDate;
          try {
            itemDate = new Date(item.date);
            if (isNaN(itemDate.getTime())) {
              // Si la date n'est pas valide, essayer un autre format
              const parts = item.date.split('/');
              if (parts.length === 3) {
                itemDate = new Date(parts[2], parts[1] - 1, parts[0]);
              }
            }
          } catch (e) {
            // En cas d'erreur, consid√©rer cet item comme non valide pour le filtre
            return false;
          }

          // S'assurer que nous avons une date valide
          if (!itemDate || isNaN(itemDate.getTime())) return false;
          
          itemDate.setHours(0, 0, 0, 0); // Normaliser √† minuit
          
          // V√©rifier la tourn√©e
          const isSameTournee = !currentTourneeId || item.tourneeId === currentTourneeId;
          
          // V√©rifier le statut (inclut les visites sans colis)
          const hasValidStatus = item.status === 'en-cours' || item.status === 'livr√©';
          
          // L'item doit √™tre du jour courant ET de la m√™me tourn√©e ET avoir un statut valide
          return itemDate.getTime() === today.getTime() && isSameTournee && hasValidStatus;
        });
        
        console.log(`Historique local filtr√©: ${filteredHistory.length} scans (jour + tourn√©e + statut)`);
        
        // Consolider l'historique filtr√© avant de mettre √† jour l'√©tat
        const consolidatedHistory = consolidateAndSortScans([], filteredHistory);

        // Enrichir avec le nom complet du site depuis Firestore
        const enrichedHistory = await Promise.all(
          consolidatedHistory.map(async (scan) => {
            // Tenter de r√©cup√©rer les d√©tails du site en utilisant siteId ou code
            try {
              const siteIdentifier = scan.siteId || scan.code; // Utiliser ID ou code
              // V√©rifier si l'identifiant est probablement un site avant d'appeler getSiteById
              if (siteIdentifier && 
                  !siteIdentifier.startsWith('TEST_CONTENANT_') && 
                  !siteIdentifier.match(/^[0-9]{13,}$/)) { 
                const siteInfo = await firebaseService.getSiteById(siteIdentifier);
                if (siteInfo) {
                  // Enrichir le scan avec les d√©tails complets
                  return { 
                    ...scan, 
                    siteName: siteInfo.nom || siteInfo.name, // Ajouter le nom pour affichage facile
                    siteDetails: { ...siteInfo } 
                  };
                }
              }
            } catch (e) {
              console.warn(`[loadHistoricalScans] Erreur r√©cup√©ration d√©tails site pour ${scan.code || scan.id}:`, e);
            }
            // Si non trouv√© ou erreur, retourner le scan original
            return scan;
          })
        );
        
        // Mettre √† jour l'√©tat avec l'historique enrichi
        setHistoricalScans(enrichedHistory);
        setSessionHistoryLoaded(true);
      }
    } catch (error) {
      console.error('Erreur lors du chargement de l\'historique:', error);
    }
  };

  const loadFirestoreScans = async () => {
    try {
      // On ne charge les scans Firestore que si la session est active
      const userSessionActive = await AsyncStorage.getItem('userSessionActive');
      if (userSessionActive !== 'true') {
        // Si aucune session active, on ne charge pas l'historique Firestore
        return;
      }

      // R√©cup√©rer l'ID de session actuel
      const currentSessionId = await AsyncStorage.getItem('currentSessionId');
      console.log('Chargement des scans pour la session:', currentSessionId);

      // R√©cup√©rer l'ID de la tourn√©e actuelle
      const currentSession = await firebaseService.getCurrentSession();
      const currentTourneeId = currentSession?.tournee?.id || sessionData?.tournee?.id || '';
      console.log('Tourn√©e actuelle:', currentTourneeId);

      setLoading(true); // Afficher l'indicateur de chargement

      // R√©cup√©rer tous les scans de l'utilisateur (sans limite)
      const scans = await firebaseService.getScans();
      
      if (scans && scans.length > 0) {
        // Ne garder que les scans du jour (J0)
        const today = new Date();
        today.setHours(0, 0, 0, 0); // D√©but de la journ√©e
        
        const filteredScans = scans.filter(scan => {
          // Convertir la date du scan en objet Date
          const scanDate = dateUtils.convertTimestampToDate(scan.scanDate || scan.createdAt);
          if (!scanDate) return false;
          
          // R√©cup√©rer juste la date (sans l'heure)
          const scanDateOnly = new Date(scanDate);
          scanDateOnly.setHours(0, 0, 0, 0);
          
          // V√©rifier la tourn√©e (si une tourn√©e actuelle est d√©finie)
          const isSameTournee = !currentTourneeId || scan.tourneeId === currentTourneeId;
          
          // V√©rifier le statut (inclut "pas_de_colis")
          const hasValidStatus = scan.status === 'en-cours' || scan.status === 'livr√©';
          
          // Le scan doit √™tre du jour courant ET de la m√™me tourn√©e ET avoir un statut valide
          return scanDateOnly.getTime() === today.getTime() && isSameTournee && hasValidStatus;
        });
        
        // Convertir les scans Firestore filtr√©s en format compatible avec l'historique local
        const formattedScans = filteredScans.map(scan => {
          // D√©duire le statut si manquant, bas√© sur le type d'op√©ration
          let status = scan.status;
          if (!status) {
            status = scan.operationType === 'sortie' ? 'livr√©' : 'en-cours';
          }
          
          return {
            id: scan.id || Date.now().toString(),
            code: scan.code,
            timeStamp: dateUtils.formatTime(scan.scanDate || scan.createdAt),
            date: dateUtils.formatDate(scan.scanDate || scan.createdAt),
            site: scan.site,
            fromFirestore: true,
            sessionId: scan.sessionId,
            // Utiliser le statut (corrig√© si n√©cessaire)
            status: status, 
            // S'assurer que le type est aussi pr√©sent
            type: scan.operationType || (status === 'livr√©' ? 'sortie' : 'entree'), 
            tournee: scan.tournee || '',
            tourneeId: scan.tourneeId || '',
            scanDate: scan.scanDate ? dateUtils.convertTimestampToDate(scan.scanDate).toISOString() : (scan.createdAt ? dateUtils.convertTimestampToDate(scan.createdAt).toISOString() : new Date().toISOString()) // Garder une date ISO pour le tri
          };
        });
        
        // Consolider et trier
        const consolidatedScans = consolidateAndSortScans(historicalScans, formattedScans);
        // Enrichir avec le nom complet du site depuis Firestore
        const enrichedScans = await Promise.all(
          consolidatedScans.map(async (scan) => {
            try {
              // Tenter de r√©cup√©rer les d√©tails du site
              try {
                // Utiliser l'ID du site si disponible, sinon le code barre
                const siteIdentifier = scan.siteId || scan.code; // Assumer que siteId existe
                if (siteIdentifier && 
                    !siteIdentifier.startsWith('TEST_CONTENANT_') && 
                    !siteIdentifier.match(/^[0-9]{13,}$/)) {
                  // Utiliser une variable locale au lieu de r√©assigner l'√©tat siteDetails
                  const siteInfo = await firebaseService.getSiteById(siteIdentifier); 
                  if (siteInfo) {
                    // Modifier l'objet scan directement
                    scan.siteName = siteInfo.nom || siteInfo.name; // Utiliser le nom du site s'il est trouv√©
                    scan.siteDetails = siteInfo; // Ajouter les d√©tails au scan
                  } else {
                     // Si siteInfo est null, indiquer le nom comme code
                     scan.siteName = scan.code; 
                  }
                } else {
                   scan.siteName = scan.code; // Fallback si aucun identifiant
                }
              } catch (siteError) {
                console.warn(`[loadFirestoreScans] Impossible de r√©cup√©rer les d√©tails du site pour l'identifiant ${scan.siteId || scan.code}:`, siteError);
                scan.siteName = scan.code; // Afficher le code si erreur
              }
              
              // Ne r√©cup√©rer les informations sur le site que s'il ne s'agit pas d'un conteneur
              if (scan.site && 
                  !scan.site.startsWith('TEST_CONTENANT_') && 
                  !scan.site.match(/^[0-9]{13,}$/)) {
                const siteInfo = await firebaseService.getSiteById(scan.site);
                if (siteInfo) return { ...scan, siteDetails: { ...siteInfo } };
              }
            } catch (e) {
              console.error('Erreur r√©cup√©ration nom site Firestore:', e);
            }
            return scan;
          })
        );
        
        // Mettre √† jour l'√©tat avec l'historique enrichi
        setHistoricalScans(enrichedScans);
        setSessionHistoryLoaded(true);
        
        // Sauvegarder √©galement dans AsyncStorage pour la persistance locale temporaire
        await AsyncStorage.setItem('scanHistory', JSON.stringify(enrichedScans));
      }
      
      setLoading(false); // Masquer l'indicateur de chargement
    } catch (error) {
      console.error('Erreur lors du chargement des scans depuis Firestore:', error);
      setLoading(false); // Masquer l'indicateur de chargement en cas d'erreur
    }
  };

  // --- AJOUTER CETTE FONCTION D'AIDE --- 
  // Fonction pour consolider et trier les scans
  const consolidateAndSortScans = (existingScans, newScans) => {
    const map = new Map();

    // Ajouter les scans existants √† la map
    existingScans.forEach(scan => {
      if (scan.code) map.set(scan.code, scan);
    });

    // Mettre √† jour ou ajouter les nouveaux scans
    newScans.forEach(scan => {
      if (scan.code) map.set(scan.code, scan);
    });

    // Convertir la map en tableau
    const consolidated = Array.from(map.values());

    // Trier
    consolidated.sort((a, b) => {
      const dateA = a.scanDate ? new Date(a.scanDate).getTime() : 0;
      const dateB = b.scanDate ? new Date(b.scanDate).getTime() : 0;
      if (isNaN(dateA) && isNaN(dateB)) return 0;
      if (isNaN(dateA)) return 1;
      if (isNaN(dateB)) return -1;
      return dateB - dateA;
    });

    return consolidated;
  };
  // --- FIN DE L'AJOUT ---

  const loadTakingCarePackages = async () => {
    try {
      const scansEnCours = await firebaseService.getScansEnCours();
      // Filtrer pour exclure les scans "pas_de_colis"
      const filteredScans = scansEnCours.filter(scan => 
        scan.status !== 'pas_de_colis' &&
        !(scan.code && scan.code.startsWith('SITE_'))
      );
      console.log(`‚úÖ ${filteredScans.length} paquet(s) pris en charge r√©cup√©r√©(s) (sans les "pas_de_colis")`);
      setTakingCarePackages(filteredScans);
    } catch (error) {
      console.error('‚ùå Erreur lors du chargement des paquets pris en charge:', error);
    }
  };

  // üîπ Simulation d'un scan avec des sites valides
  const simulateScan = () => {
    if (scanMode === 'site') {
      // Sites de test qui seront reconnus comme valides
      const sitesDemoValides = [
        'SITE123',
        'SITE456',
        'SITE789',
        'LAB001',
        '12345'
      ];
      
      // S√©lectionner un site al√©atoire parmi les sites valides pour la d√©mo
      return sitesDemoValides[Math.floor(Math.random() * sitesDemoValides.length)];
    } else {
      // Si on est en mode sortie (d√©p√¥t), on doit scanner un colis d√©j√† pris en charge
      if (operationType === 'sortie') {
        // V√©rifier si des colis sont disponibles
        if (takingCarePackages.length > 0) {
          // S√©lectionner un colis al√©atoire parmi les colis pris en charge
          const randomPackage = takingCarePackages[Math.floor(Math.random() * takingCarePackages.length)];
          return randomPackage.code;
        } else {
          // Aucun colis disponible pour le d√©p√¥t - cette condition est g√©r√©e dans handleSimulatedScan
          return '';
        }
      } else {
        // Simuler un scan de contenant pour prise en charge
        // Utiliser un pr√©fixe sp√©cifique pour les tests afin de pouvoir les identifier facilement
        const testId = Date.now(); // Utiliser le timestamp actuel pour cr√©er un ID unique
        return `TEST_CONTENANT_${testId}`;
      }
    }
  };

  // Modification pour les tests : fonction mock qui simule verifySiteCode
  const mockVerifySiteCode = async (siteCode) => {
    // Sites de test qui seront automatiquement valid√©s
    const sitesDemoValides = {
      'SITE123': { nom: 'Site Test 1', adresse: '123 Rue Principale', ville: 'Paris', codePostal: '75001' },
      'SITE456': { nom: 'Site Test 2', adresse: '456 Avenue R√©publique', ville: 'Lyon', codePostal: '69001' },
      'SITE789': { nom: 'Site Test 3', adresse: '789 Boulevard des Tests', ville: 'Toulouse', codePostal: '31000' },
      '12345': { nom: 'Laboratoire Central', adresse: '12 Rue des Sciences', ville: 'Montpellier', codePostal: '34000' },
      'LAB001': { nom: 'Laboratoire Mobile', adresse: 'Zone Industrielle', ville: 'Bordeaux', codePostal: '33000' }
    };

    // V√©rifier si le code scann√© est dans notre liste de sites de test
    if (sitesDemoValides[siteCode]) {
      // Retourner une structure simulant la r√©ponse de Firebase
      return {
        valid: true,
        site: {
          id: `mock_${siteCode}`,
          code: siteCode,
          nom: sitesDemoValides[siteCode].nom,
          adresse: sitesDemoValides[siteCode].adresse,
          ville: sitesDemoValides[siteCode].ville,
          codePostal: sitesDemoValides[siteCode].codePostal
        }
      };
    }

    // Si ce n'est pas un site de test, passer √† la v√©rification normale dans Firebase
    return await firebaseService.verifySiteCode(siteCode);
  };

  const processScannedData = async (data) => {
    console.log('Code scann√©:', data);
    try {
      // Cas 1: Nous n'avons pas encore scann√© de site
      if (!siteScanned && scanMode === 'site') {
        console.log('[processScannedData] Mode: Scan de site. Donn√©es:', data);
        const siteVerification = await firebaseService.verifySiteCode(data);
        console.log('[processScannedData] R√©sultat de verifySiteCode:', JSON.stringify(siteVerification));

        if (siteVerification.site) {
          // Enregistrer les infos du site
          setSiteCode(data);
          setSiteDetails(siteVerification.site);
          // setSiteScanned(true); // Mis plus bas pour ne l'activer qu'apr√®s succ√®s
          // setScanMode(''); // Mis plus bas
          // setShowOperationTypeSelection(true); // Mis plus bas

          // --- MODIFI√â: Ne trouver que le premier site non visit√© avec ce nom ---
          let occurrenceIndex = null;
          if (tourneeProgressRef.current?.getSitesWithStatus) {
            const sitesList = tourneeProgressRef.current.getSitesWithStatus();
            console.log('[processScannedData] sitesList depuis tourneeProgressRef:', JSON.stringify(sitesList.map(s => ({ id: s.id, name: s.name, visited: s.visited, uniqueDisplayId: s.uniqueDisplayId }))));
            const siteNameToFind = siteVerification.site.nom || siteVerification.site.name;
            console.log('[processScannedData] Nom du site √† trouver:', siteNameToFind);

            // Trouver le premier site non visit√© avec ce nom
            occurrenceIndex = sitesList.findIndex(s => !s.visited && (s.name === siteNameToFind || s.nom === siteNameToFind)); // Ajout de s.nom
            console.log(`[processScannedData] Occurrence index trouv√©e pour ${siteNameToFind}:`, occurrenceIndex);
            
            // Si aucun site non visit√© n'est trouv√©, ne rien faire
            if (occurrenceIndex === -1) {
              Alert.alert(
                'Site d√©j√† visit√© ou non trouv√©', // Message mis √† jour
                'Ce site a d√©j√† √©t√© visit√©, ne fait pas partie de cette tourn√©e, ou son nom ne correspond pas exactement.', // Message mis √† jour
                [{ text: 'OK', onPress: () => {
                  // R√©initialiser l'√©tat pour permettre un nouveau scan
                  setSiteScanned(false);
                  setSiteDetails(null);
                  setSiteCode('');
                  setShowOperationTypeSelection(false);
                }}]
              );
              return;
            }
          } else {
            console.warn('[processScannedData] tourneeProgressRef.current.getSitesWithStatus non disponible.');
            Alert.alert('Erreur', 'Impossible de r√©cup√©rer la liste des sites de la tourn√©e.');
            return;
          }

          // Marquage en session via l'index si trouv√©, sinon par site.id
          const identifier = siteVerification.site.id || (siteVerification.site.code || data);
          console.log('[processScannedData] Identifier pour markSiteVisitedInSession:', identifier);
          console.log('[processScannedData] currentSessionId avant appel:', currentSessionId);
          console.log('[processScannedData] occurrenceIndex avant appel:', occurrenceIndex);

          if (!currentSessionId) {
            console.error('[processScannedData] ID de session manquant avant markSiteVisitedInSession');
            Alert.alert('Erreur Critique', 'ID de session manquant. Impossible de continuer.');
            return;
          }
          
          // Ne marquer qu'un seul site √† la fois, en utilisant l'index sp√©cifique
          if (occurrenceIndex !== -1 && occurrenceIndex !== null) { // Condition d√©j√† pr√©sente, mais on log avant
            const markSuccess = await firebaseService.markSiteVisitedInSession(currentSessionId, identifier, occurrenceIndex);
            console.log('[processScannedData] R√©sultat de markSiteVisitedInSession:', markSuccess);
            
            if (markSuccess) {
              setSiteScanned(true); // Activer seulement si le marquage Firestore a r√©ussi
              setScanMode(''); 
              setShowOperationTypeSelection(true);

              // Mise √† jour du UI local - mettre √† jour uniquement le site sp√©cifique
              if (tourneeProgressRef.current?.markSiteAsVisitedLocally) {
                console.log('[processScannedData] Appel de markSiteAsVisitedLocally avec:', identifier, occurrenceIndex);
                await tourneeProgressRef.current.markSiteAsVisitedLocally(identifier, occurrenceIndex); // AJOUT DE AWAIT
                // Temporairement comment√© pour tester si la coche se met √† jour correctement sans rechargement imm√©diat
                // await updateTourneeProgress(); 
              } else if (tourneeProgressRef.current?.loadTourneeDetails) {
                console.log('[processScannedData] Appel de loadTourneeDetails(true) car markSiteAsVisitedLocally non dispo.');
                await tourneeProgressRef.current.loadTourneeDetails(true);
              }
            } else {
              Alert.alert('Erreur', '√âchec du marquage du site comme visit√© dans la session Firestore.');
              // Garder siteScanned √† false, etc.
            }
            
            // Si updateTourneeProgress a √©t√© comment√©, on peut appeler loadHistoricalData ici
            // si c'est n√©cessaire pour d'autres parties de l'UI non li√©es √† TourneeProgress.
            // Pour l'instant, on isole le probl√®me de la coche.
            // await loadHistoricalData(); 

          } else {
             console.warn('[processScannedData] occurrenceIndex invalide, markSiteVisitedInSession non appel√©.');
             // Potentiellement une alerte ici si ce cas ne devrait pas arriver
          }
          return;
        } else { // siteVerification.site est null/undefined
          console.log('[processScannedData] Aucun site valide retourn√© par verifySiteCode pour le code:', data);
          Alert.alert('Site Inconnu', 'Le code scann√© ne correspond √† aucun site connu.');
           // R√©initialiser pour permettre un nouveau scan
          setSiteScanned(false);
          setSiteDetails(null);
          setSiteCode('');
          setShowOperationTypeSelection(false);
        }
      }
      
      // Cas 2: Site d√©j√† scann√©, nous scannons maintenant un contenant
      if (siteScanned && scanMode === 'contenant') {
        console.log('[processScannedData] Mode: Scan de contenant. Donn√©es:', data);
        handleContenantScan(data);
        // Rester en mode scan contenant pour permettre les scans multiples
        setScanMode('contenant');
      }
    } catch (error) {
      console.error('Erreur lors de la gestion du scan:', error);
      setErrorMessage('Erreur: ' + error.message); // Afficher l'erreur √† l'utilisateur
      setScanMode(''); // R√©initialiser le mode scan
      // Optionnel: r√©initialiser d'autres √©tats si n√©cessaire
      setSiteScanned(false);
      setSiteDetails(null);
      setSiteCode('');
      setShowOperationTypeSelection(false);
    }
  };

  // G√©rer la simulation d'un scan (pour le d√©veloppement et les tests)
  const handleSimulatedScan = () => {
    // V√©rifier si on est en mode sortie sans colis pris en charge
    if (scanMode === 'contenant' && operationType === 'sortie' && takingCarePackages.length === 0) {
      Alert.alert(
        "Aucun colis disponible",
        "Vous n'avez aucun colis en prise en charge √† d√©poser.",
        [{ text: "OK" }]
      );
      return;
    }
    
    const fakeData = simulateScan();
    if (fakeData) {
      console.log(`Simulation de scan avec donn√©es: ${fakeData}`);
    processScannedData(fakeData);
    } else {
      console.error("Erreur lors de la simulation du scan: aucune donn√©e g√©n√©r√©e");
      Alert.alert(
        "Erreur",
        "Impossible de simuler un scan. Veuillez r√©essayer.",
        [{ text: "OK" }]
      );
    }
  };

  const handleManualScan = () => {
    if (manualCodeInput.trim() === '') {
      Alert.alert('Erreur', 'Veuillez entrer un code valide');
      return;
    }
    
    processScannedData(manualCodeInput.trim());
    setManualCodeInput('');
  };

  const activateSiteScan = () => {
    setScanMode('site');
    setErrorMessage('');
    setIsReadyForScan(true);
    
    // Montrer une alerte avec plusieurs options pour scanner
    Alert.alert(
      "Scanner un site",
      "Comment souhaitez-vous scanner le site ?",
      [
        {
          text: "Scanner manuellement",
          onPress: () => showManualSiteInput()
        },
        {
          text: "Simuler scan",
          onPress: handleSimulatedScan
        },
        {
          text: "Annuler",
          style: "cancel",
          onPress: () => setScanMode('')
        }
      ]
    );
  };

  // Fonction pour afficher une bo√Æte de dialogue pour saisir manuellement le code du site
  const showManualSiteInput = () => {
    // Utiliser Alert.prompt sur iOS, mais sur Android, cette fonction n'existe pas
    // donc nous utilisons une m√©thode alternative
    if (Platform.OS === 'ios') {
      Alert.prompt(
        "Scanner site manuellement",
        "Entrez le code ou le nom du site",
        [
          { text: "Annuler", onPress: () => setScanMode(''), style: "cancel" },
          { 
            text: "Scanner", 
            onPress: (code) => {
              if (code && code.trim()) {
                processScannedData(code.trim());
              } else {
                setScanMode('');
                Alert.alert("Erreur", "Veuillez entrer un code de site valide");
              }
            }
          }
        ],
        "plain-text"
      );
    } else {
      // Sur Android, utiliser une solution simple avec TextInput
      Alert.alert(
        "Scanner site manuellement",
        "Entrez le code du site dans le champ de texte en haut de l'√©cran, puis appuyez sur Scanner",
        [
          { text: "OK" }
        ]
      );
      // Focus sur le champ de saisie manuelle
      // Note: ceci est une approche simplifi√©e, une solution plus robuste
      // utiliserait un modal personnalis√© avec TextInput
      setManualCodeInput('');
      // On garde le mode scan actif pour que le bouton scanner manuel fonctionne
    }
  };

  // Afficher la page de s√©lection du type d'op√©ration
  const showOperationSelection = () => {
    setShowOperationTypeSelection(true);
  };

  // Commencer le scan de contenant avec un type d'op√©ration sp√©cifique
  const startContenantScan = (type) => {
    setOperationType(type);
    setShowOperationTypeSelection(false);
    setScanMode('contenant');
    setErrorMessage('');
    setIsReadyForScan(true);
    
    // Message diff√©rent selon le type d'op√©ration
    const message = type === 'entree' 
      ? "Veuillez scanner le code du contenant √† prendre en charge" 
      : "Veuillez scanner le code du contenant √† d√©poser";
    
    Alert.alert(
      type === 'entree' ? "Prise en charge" : "D√©p√¥t",
      message,
      [{ text: "Annuler", onPress: () => setScanMode('') }]
    );
  };

  const handleContenantScan = async (code) => {
    if (!siteScanned) {
      Alert.alert('Erreur', 'Veuillez d\'abord scanner un site');
      return;
    }

    try {
      // Mode d√©p√¥t (sortie) - v√©rifier que le colis est dans la liste des colis pris en charge
      if (operationType === 'sortie') {
        const isInTakingCare = takingCarePackages.some(pkg => pkg.code === code);
        if (!isInTakingCare) {
          Alert.alert(
            "Colis non reconnu",
            "Ce colis ne fait pas partie des colis que vous avez en prise en charge.",
            [{ text: "OK" }]
          );
          return;
        }
        
        // Retirer le colis de la liste des colis pris en charge
        setTakingCarePackages(takingCarePackages.filter(pkg => pkg.code !== code));
      }

      // Obtenir la date actuelle au format appropri√©
      const currentDate = new Date();
      const currentDateISO = currentDate.toISOString();

      // Ajouter le contenant √† la liste
      const newContenant = {
        id: Date.now().toString(),
        code: code,
        idColis: code,
        timeStamp: currentDate.toLocaleTimeString(),
        date: currentDate.toLocaleDateString(),
        scanDate: currentDateISO,
        site: siteCode,
        type: operationType, // Ajout du type d'op√©ration (entr√©e/sortie)
      };
      
      setScannedContenants([newContenant, ...scannedContenants]);
    } catch (error) {
      console.error('Erreur lors de la gestion du scan:', error);
      setScanMode('');
    }
  };

  const renderScannedItem = ({ item }) => (
    <View style={[styles.contenantItem, item.type === 'sortie' ? styles.contenantItemSortie : styles.contenantItemEntree]}>
      <View style={styles.contenantInfo}>
        <Text style={styles.contenantCode}>{item.code}</Text>
        <View style={styles.contenantTypeRow}>
          <View style={item.type === 'sortie' ? styles.typeTagSortie : styles.typeTagEntree}>
            <Text style={styles.typeTagText}>{item.type === 'sortie' ? 'D√©p√¥t' : 'Prise en charge'}</Text>
          </View>
          <Text style={styles.contenantTime}>{item.timeStamp}</Text>
        </View>
      </View>
      <TouchableOpacity
        style={styles.deleteContenantButton}
        onPress={() => removeScannedContenant(item.id)}
      >
        <Ionicons name="trash-outline" size={20} color="#e74c3c" />
      </TouchableOpacity>
    </View>
  );

  const removeScannedContenant = (id) => {
    setScannedContenants(scannedContenants.filter(contenant => contenant.id !== id));
  };

  const handleTransmit = async () => {
    if (scannedContenants.length === 0) {
      Alert.alert('Attention', 'Aucun contenant scann√© √† transmettre.');
      return;
    }

    setLoading(true);

    try {
      // V√©rifier et afficher les donn√©es de la session pour le d√©bogage
      console.log('Donn√©es de session:', JSON.stringify(sessionData, null, 2));
      console.log('Donn√©es de route:', JSON.stringify(route.params, null, 2));
      
      // R√©cup√©rer les donn√©es de la tourn√©e et du v√©hicule avec plus de v√©rifications
      const tourneeName = sessionData.tournee?.nom || route.params?.tournee?.nom || '';
      const tourneeId = sessionData.tournee?.id || route.params?.tournee?.id || '';
      const vehiculeName = sessionData.vehicule?.immatriculation || route.params?.vehicule?.immatriculation || '';
      const vehiculeId = sessionData.vehicule?.id || route.params?.vehicule?.id || '';
      
      // Utiliser les d√©tails du site valid√© s'ils sont disponibles
      let siteName, siteId, siteAdresse, siteCodePostal, siteVille;
      
      if (siteDetails) {
        // Utiliser les bonnes cl√©s du siteDetails (nommage uniforme)
        siteName = siteDetails.name || siteCode;
        siteId = siteDetails.id || '';
        siteAdresse = siteDetails.address || '';
        siteCodePostal = siteDetails.codePostal || '';
        siteVille = siteDetails.city || '';
      } else {
        // Sinon on utilise ce qu'on a par d√©faut
        siteName = sessionData.tournee?.siteDepart || route.params?.tournee?.siteDepart || siteCode || 'Non sp√©cifi√©';
        siteId = '';
      }
      
      console.log('Donn√©es r√©cup√©r√©es pour les scans:', {
        tourneeName,
        tourneeId,
        vehiculeName,
        vehiculeId,
        siteName,
        siteId,
        siteCode
      });

      // R√©cup√©rer l'ID de session actuel
      const currentSessionId = await AsyncStorage.getItem('currentSessionId') || `session_${Date.now()}`;
      
      // Pr√©parer les scans avec tous les champs n√©cessaires
      const scansToSubmit = scannedContenants.map(scan => {
        const scanDate = scan.scanDate || new Date().toISOString();
        
        // Le code du contenant devient l'ID du colis
        const scanItem = {
          code: scan.code,
          idColis: scan.code || scan.idColis,
          scanDate: scanDate,
          tournee: tourneeName,
          tourneeId: tourneeId,
          vehicule: vehiculeName,
          vehiculeId: vehiculeId,
          immatriculation: vehiculeName,
          site: siteName,
          siteId: siteId,
          siteCode: siteCode,
          siteDepart: siteName,
          siteD√©part: siteName,
          sessionId: currentSessionId, // Ajouter l'ID de session pour le filtrage ult√©rieur
          operationType: scan.type || 'entree', // Ajout du type d'op√©ration
          status: scan.type === 'sortie' ? 'livr√©' : 'en-cours', // Status bas√© sur le type d'op√©ration
          type: scan.type || 'entree' // Assurer que le type est inclus explicitement
        };
        
        // Ajouter siteFin uniquement pour les colis livr√©s
        if (scan.type === 'sortie') {
          // Pour les op√©rations de sortie (d√©p√¥t), ajouter des informations sp√©cifiques
          const currentDate = new Date();
          
          // Utiliser le nom du site actuel comme site d'arriv√©e
          scanItem.siteFin = siteName;
          // Ajouter date et heure d'arriv√©e au format correct
          scanItem.dateArrivee = currentDate.toLocaleDateString();
          scanItem.heureArrivee = currentDate.toLocaleTimeString();
          // Ajouter ces champs suppl√©mentaires pour assurer la compatibilit√©
          scanItem.dateHeureFin = currentDate.toISOString();
          scanItem.statut = 'Livr√©';
          scanItem.status = 'livr√©'; // Assurez-vous que les deux formats sont pr√©sents
          scanItem.coursierLivraison = sessionData.coursierCharg || route.params?.coursierCharg || '';
        }
        
        // Ajouter les d√©tails du site s'ils sont disponibles
        if (siteDetails) {
          scanItem.siteDetails = {
            adresse: siteAdresse,
            codePostal: siteCodePostal,
            ville: siteVille
          };
        }

        // Ajouter la localisation si disponible
        if (sessionData.location) {
          scanItem.location = {
            latitude: sessionData.location.coords.latitude,
            longitude: sessionData.location.coords.longitude,
            accuracy: sessionData.location.coords.accuracy
          };
        }

        return scanItem;
      });
      
      // Afficher les donn√©es qui seront transmises
      console.log('Transmission des scans:', JSON.stringify(scansToSubmit, null, 2)); // D√©comment√© pour d√©bogage
      
      // Envoyer les scans √† Firebase
      const result = await firebaseService.addScans(scansToSubmit);
      console.log('R√©sultat de la transmission:', result);
      
      // Si la transmission r√©ussit, mettre √† jour l'historique local
      if (result.success) {
        // --- Logique de consolidation --- 
        const updatedScansMap = new Map();
        historicalScans.forEach(scan => {
          // Assurer qu'on a un code pour la cl√© de la map
          if (scan.code) {
            updatedScansMap.set(scan.code, scan);
          }
        });
        scansToSubmit.forEach(scan => {
          if (scan.code) {
            const originalScan = scannedContenants.find(s => s.code === scan.code);
            const scanForHistory = {
              ...scan,
              timeStamp: originalScan?.timeStamp || dateUtils.formatTime(scan.scanDate),
            };
            updatedScansMap.set(scan.code, scanForHistory);
          }
        });
        const newHistory = Array.from(updatedScansMap.values());
        newHistory.sort((a, b) => {
          const dateA = a.scanDate ? new Date(a.scanDate).getTime() : 0;
          const dateB = b.scanDate ? new Date(b.scanDate).getTime() : 0;
          if (isNaN(dateA) && isNaN(dateB)) return 0;
          if (isNaN(dateA)) return 1;
          if (isNaN(dateB)) return -1;
          return dateB - dateA;
        });
        // --- Fin de la logique de consolidation ---

        // Sauvegarder l'historique consolid√© dans AsyncStorage
        await AsyncStorage.setItem('scanHistory', JSON.stringify(newHistory));
        
        // Mise √† jour de l'√©tat React DIFF√âR√âE apr√®s les interactions
        InteractionManager.runAfterInteractions(() => {
          setHistoricalScans(newHistory);
        });
        
        // Mettre √† jour la liste des paquets pris en charge
        if (operationType === 'entree') {
          setTakingCarePackages([...scansToSubmit, ...takingCarePackages]);
        } else if (operationType === 'sortie') {
          const codesDeposited = scansToSubmit.map(scan => scan.code);
          setTakingCarePackages(takingCarePackages.filter(pkg => pkg.code && !codesDeposited.includes(pkg.code)));
        }
        
        // R√©initialiser compl√®tement l'√©tat pour revenir √† l'√©cran de scan de site
        resetScan(); // Cette fonction r√©initialise les √©tats de base

        // S'assurer que tous les √©tats sont correctement r√©initialis√©s pour revenir √† l'√©cran initial
        setShowOperationTypeSelection(false);
        setOperationType('entree'); // R√©initialiser √† l'entr√©e de colis par d√©faut
        
        // Important: D√©sactiver le chargement AVANT l'alerte
        setLoading(false);
        
        // Afficher l'alerte de succ√®s
        Alert.alert(
          'Succ√®s',
          `${scansToSubmit.length} scan(s) transmis avec succ√®s`,
          [{ text: 'OK' }]
        );
      } else {
        setLoading(false);
        throw new Error(result.error || '√âchec de la transmission');
      }
    } catch (error) {
      console.error('Erreur lors de la transmission:', error);
      setLoading(false);
      Alert.alert('Erreur', `√âchec de la transmission: ${error.message}`);
    }
  };

  const resetScan = () => {
    setScanMode('');
    setSiteScanned(false);
    setSiteCode('');
    setScannedContenants([]);
    setManualCodeInput('');
    setSiteDetails(null);
  };

  const navigateToHistory = () => {
    setShowHistoryModal(true);
  };

  // Fonction pour obtenir les d√©tails de la session actuelle
  const getSessionDetails = async () => {
    try {
      const currentSession = await firebaseService.getCurrentSession();
      if (currentSession) {
        setSessionId(currentSession.id);
        setTournee(currentSession.tournee);
        setVehicule(currentSession.vehicule);
        setPole(currentSession.pole);
      }
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration de la session:", error);
    }
  };

  // Fonction pour effacer l'historique des scans
  const clearHistoricalScans = async () => {
    try {
      Alert.alert(
        'Effacer l\'historique',
        'Voulez-vous vraiment effacer tout l\'historique des scans?',
        [
          {
            text: 'Annuler',
            style: 'cancel'
          },
          {
            text: 'Effacer',
            onPress: async () => {
              await AsyncStorage.removeItem('scanHistory');
              setHistoricalScans([]);
              Alert.alert('Succ√®s', 'Historique effac√© avec succ√®s');
            },
            style: 'destructive'
          }
        ]
      );
    } catch (error) {
      console.error('Erreur lors de l\'effacement de l\'historique:', error);
      Alert.alert('Erreur', 'Impossible d\'effacer l\'historique');
    }
  };

  // Ajout d'une fonction pour effacer explicitement tous les scans de la session actuelle
  const clearCurrentSessionScans = async () => {
    try {
      const currentSessionId = await AsyncStorage.getItem('currentSessionId');
      if (!currentSessionId) {
        Alert.alert('Erreur', 'Impossible de d√©terminer la session actuelle');
        return;
      }
      
      Alert.alert(
        'R√©initialiser l\'historique',
        'Cette action va supprimer tous les scans associ√©s √† votre session actuelle. Continuer?',
        [
          {
            text: 'Annuler',
            style: 'cancel'
          },
          {
            text: 'Supprimer',
            onPress: async () => {
              try {
                // Supprimer les scans associ√©s √† la session actuelle
                setLoading(true);
                console.log(`Suppression des scans de la session ${currentSessionId}...`);
                
                // Fonction c√¥t√© service qui devrait √™tre impl√©ment√©e
                // pour supprimer tous les scans de la session
                const result = await firebaseService.clearSessionScans(currentSessionId);
                
                // Supprimer l'historique local √©galement
                await AsyncStorage.removeItem('scanHistory');
                setHistoricalScans([]);
                
                setLoading(false);
                Alert.alert('Succ√®s', 'Historique r√©initialis√© avec succ√®s');
              } catch (error) {
                setLoading(false);
                console.error('Erreur lors de la suppression des scans:', error);
                Alert.alert('Erreur', `√âchec de la suppression: ${error.message}`);
              }
            },
            style: 'destructive'
          }
        ]
      );
    } catch (error) {
      console.error('Erreur:', error);
      Alert.alert('Erreur', 'Une erreur est survenue');
    }
  };

  // Handler de d√©connexion avec effacement complet de l'historique
  const handleLogout = async () => {
    try {
      Alert.alert(
        'D√©connexion',
        'Voulez-vous vous d√©connecter? L\'historique des scans sera effac√©.',
        [
          {
            text: 'Annuler',
            style: 'cancel'
          },
          {
            text: 'D√©connecter',
            onPress: async () => {
              try {
                setLoading(true);
                console.log('D√©connexion en cours...');

                // Appeler la m√©thode de d√©connexion de Firebase
                await firebaseService.logout();
                console.log('D√©connexion Firebase r√©ussie');
                
                // Effacer toutes les donn√©es de session
                await AsyncStorage.removeItem('userSessionActive');
                // On conserve current_session_id pour que la tourn√©e visit√©e reste en m√©moire
                await AsyncStorage.removeItem('scanHistory');
                await AsyncStorage.removeItem('user_selas_id');
                
                // R√©initialiser les √©tats
                setHistoricalScans([]);
                setScannedContenants([]);
                setSiteScanned(false);
                setSiteCode('');
                
                setLoading(false);
                
                // Rediriger vers l'√©cran de connexion
                navigation.reset({
                  index: 0,
                  routes: [{ name: 'Login' }]
                });
              } catch (error) {
                setLoading(false);
                console.error('Erreur lors du processus de d√©connexion:', error);
                Alert.alert('Erreur', 'Impossible de se d√©connecter. Veuillez r√©essayer.');
              }
            }
          }
        ]
      );
    } catch (error) {
      console.error('Erreur lors de la d√©connexion:', error);
    }
  };

  // Utiliser directement les fonctions de formatage de dateUtils
  // au lieu de red√©finir des fonctions similaires

  // Effet pour √©couter les √©v√©nements de scan Zebra
  useEffect(() => {
    if (isReadyForScan) {
      // Afficher un message pour indiquer que l'application est pr√™te pour le scan
      console.log('Pr√™t √† recevoir des scans du scanner Zebra');
      
      // Configuration pour recevoir les scans du mat√©riel Zebra
      const handleZebraScan = (event) => {
        // Le scanner Zebra envoie g√©n√©ralement les donn√©es comme des entr√©es clavier
        // Nous devons v√©rifier que nous sommes en mode scan et traiter les donn√©es
        if (event && event.nativeEvent && event.nativeEvent.key === 'Enter' && scanMode) {
          // R√©cup√©rer le texte scann√© (par exemple depuis un champ de texte cach√© ou via une API Zebra)
          // Pour les besoins de cet exemple, nous utiliserons la valeur de manualCodeInput
          if (manualCodeInput.trim()) {
            processScannedData(manualCodeInput.trim());
            setManualCodeInput(''); // R√©initialiser apr√®s le traitement
          }
        }
      };
      
      // Ajoutez ici l'initialisation sp√©cifique au scanner Zebra si n√©cessaire
      // Exemple : ZebraScanner.initialize() si une API Zebra est disponible
      
      // Pour cet exemple, on simule en utilisant l'√©couteur de clavier (pour Enter)
      Keyboard.addListener('keyDown', handleZebraScan);
      
      return () => {
        // Nettoyage lors du d√©montage
        Keyboard.removeListener('keyDown', handleZebraScan);
        // D√©sinitialiser le scanner Zebra si n√©cessaire
        // Exemple : ZebraScanner.deinitialize()
      };
    }
  }, [isReadyForScan, scanMode, manualCodeInput]);


  const loadHistoricalScans = async () => {
    try {
      const jsonValue = await AsyncStorage.getItem('scanHistory');
      if (jsonValue !== null) {
        const history = JSON.parse(jsonValue);
        
        // R√©cup√©rer l'ID de la tourn√©e actuelle
        const currentSession = await firebaseService.getCurrentSession();
        const currentTourneeId = currentSession?.tournee?.id || sessionData?.tournee?.id || '';
        
        // Filtrer l'historique local
        const today = new Date();
        today.setHours(0, 0, 0, 0); // D√©but de la journ√©e
        
        const filteredHistory = history.filter(item => {
          // Convertir la date de l'item en objet Date
          let itemDate;
          try {
            itemDate = new Date(item.date);
            if (isNaN(itemDate.getTime())) {
              // Si la date n'est pas valide, essayer un autre format
              const parts = item.date.split('/');
              if (parts.length === 3) {
                itemDate = new Date(parts[2], parts[1] - 1, parts[0]);
              }
            }
          } catch (e) {
            // En cas d'erreur, consid√©rer cet item comme non valide pour le filtre
            return false;
          }

          // S'assurer que nous avons une date valide
          if (!itemDate || isNaN(itemDate.getTime())) return false;
          
          itemDate.setHours(0, 0, 0, 0); // Normaliser √† minuit
          
          // V√©rifier la tourn√©e
          const isSameTournee = !currentTourneeId || item.tourneeId === currentTourneeId;
          
          // V√©rifier le statut (inclut les visites sans colis)
          const hasValidStatus = item.status === 'en-cours' || item.status === 'livr√©';
          
          // L'item doit √™tre du jour courant ET de la m√™me tourn√©e ET avoir un statut valide
          return itemDate.getTime() === today.getTime() && isSameTournee && hasValidStatus;
        });
        
        console.log(`Historique local filtr√©: ${filteredHistory.length} scans (jour + tourn√©e + statut)`);
        
        // Consolider l'historique filtr√© avant de mettre √† jour l'√©tat
        const consolidatedHistory = consolidateAndSortScans([], filteredHistory);

        // Enrichir avec le nom complet du site depuis Firestore
        const enrichedHistory = await Promise.all(
          consolidatedHistory.map(async (scan) => {
            // Tenter de r√©cup√©rer les d√©tails du site en utilisant siteId ou code
            try {
              const siteIdentifier = scan.siteId || scan.code; // Utiliser ID ou code
              // V√©rifier si l'identifiant est probablement un site avant d'appeler getSiteById
              if (siteIdentifier && 
                  !siteIdentifier.startsWith('TEST_CONTENANT_') && 
                  !siteIdentifier.match(/^[0-9]{13,}$/)) { 
                const siteInfo = await firebaseService.getSiteById(siteIdentifier);
                if (siteInfo) {
                  // Enrichir le scan avec les d√©tails complets
                  return { 
                    ...scan, 
                    siteName: siteInfo.nom || siteInfo.name, // Ajouter le nom pour affichage facile
                    siteDetails: { ...siteInfo } 
                  };
                }
              }
            } catch (e) {
              console.warn(`[loadHistoricalScans] Erreur r√©cup√©ration d√©tails site pour ${scan.code || scan.id}:`, e);
            }
            // Si non trouv√© ou erreur, retourner le scan original
            return scan;
          })
        );
        
        // Mettre √† jour l'√©tat avec l'historique enrichi
        setHistoricalScans(enrichedHistory);
        setSessionHistoryLoaded(true);
      }
    } catch (error) {
      console.error('Erreur lors du chargement de l\'historique:', error);
    }
  };

  const loadFirestoreScans = async () => {
    try {
      // On ne charge les scans Firestore que si la session est active
      const userSessionActive = await AsyncStorage.getItem('userSessionActive');
      if (userSessionActive !== 'true') {
        // Si aucune session active, on ne charge pas l'historique Firestore
        return;
      }

      // R√©cup√©rer l'ID de session actuel
      const currentSessionId = await AsyncStorage.getItem('currentSessionId');
      console.log('Chargement des scans pour la session:', currentSessionId);

      // R√©cup√©rer l'ID de la tourn√©e actuelle
      const currentSession = await firebaseService.getCurrentSession();
      const currentTourneeId = currentSession?.tournee?.id || sessionData?.tournee?.id || '';
      console.log('Tourn√©e actuelle:', currentTourneeId);

      setLoading(true); // Afficher l'indicateur de chargement

      // R√©cup√©rer tous les scans de l'utilisateur (sans limite)
      const scans = await firebaseService.getScans();
      
      if (scans && scans.length > 0) {
        // Ne garder que les scans du jour (J0)
        const today = new Date();
        today.setHours(0, 0, 0, 0); // D√©but de la journ√©e
        
        const filteredScans = scans.filter(scan => {
          // Convertir la date du scan en objet Date
          const scanDate = dateUtils.convertTimestampToDate(scan.scanDate || scan.createdAt);
          if (!scanDate) return false;
          
          // R√©cup√©rer juste la date (sans l'heure)
          const scanDateOnly = new Date(scanDate);
          scanDateOnly.setHours(0, 0, 0, 0);
          
          // V√©rifier la tourn√©e (si une tourn√©e actuelle est d√©finie)
          const isSameTournee = !currentTourneeId || scan.tourneeId === currentTourneeId;
          
          // V√©rifier le statut (inclut "pas_de_colis")
          const hasValidStatus = scan.status === 'en-cours' || scan.status === 'livr√©';
          
          // Le scan doit √™tre du jour courant ET de la m√™me tourn√©e ET avoir un statut valide
          return scanDateOnly.getTime() === today.getTime() && isSameTournee && hasValidStatus;
        });
        
        // Convertir les scans Firestore filtr√©s en format compatible avec l'historique local
        const formattedScans = filteredScans.map(scan => {
          // D√©duire le statut si manquant, bas√© sur le type d'op√©ration
          let status = scan.status;
          if (!status) {
            status = scan.operationType === 'sortie' ? 'livr√©' : 'en-cours';
          }
          
          return {
            id: scan.id || Date.now().toString(),
            code: scan.code,
            timeStamp: dateUtils.formatTime(scan.scanDate || scan.createdAt),
            date: dateUtils.formatDate(scan.scanDate || scan.createdAt),
            site: scan.site,
            fromFirestore: true,
            sessionId: scan.sessionId,
            // Utiliser le statut (corrig√© si n√©cessaire)
            status: status, 
            // S'assurer que le type est aussi pr√©sent
            type: scan.operationType || (status === 'livr√©' ? 'sortie' : 'entree'), 
            tournee: scan.tournee || '',
            tourneeId: scan.tourneeId || '',
            scanDate: scan.scanDate ? dateUtils.convertTimestampToDate(scan.scanDate).toISOString() : (scan.createdAt ? dateUtils.convertTimestampToDate(scan.createdAt).toISOString() : new Date().toISOString()) // Garder une date ISO pour le tri
          };
        });
        
        // Consolider et trier
        const consolidatedScans = consolidateAndSortScans(historicalScans, formattedScans);
        // Enrichir avec le nom complet du site depuis Firestore
        const enrichedScans = await Promise.all(
          consolidatedScans.map(async (scan) => {
            try {
              // Tenter de r√©cup√©rer les d√©tails du site
              try {
                // Utiliser l'ID du site si disponible, sinon le code barre
                const siteIdentifier = scan.siteId || scan.code; // Assumer que siteId existe
                if (siteIdentifier && 
                    !siteIdentifier.startsWith('TEST_CONTENANT_') && 
                    !siteIdentifier.match(/^[0-9]{13,}$/)) {
                  // Utiliser une variable locale au lieu de r√©assigner l'√©tat siteDetails
                  const siteInfo = await firebaseService.getSiteById(siteIdentifier); 
                  if (siteInfo) {
                    // Modifier l'objet scan directement
                    scan.siteName = siteInfo.nom || siteInfo.name; // Utiliser le nom du site s'il est trouv√©
                    scan.siteDetails = siteInfo; // Ajouter les d√©tails au scan
                  } else {
                     // Si siteInfo est null, indiquer le nom comme code
                     scan.siteName = scan.code; 
                  }
                } else {
                   scan.siteName = scan.code; // Fallback si aucun identifiant
                }
              } catch (siteError) {
                console.warn(`[loadFirestoreScans] Impossible de r√©cup√©rer les d√©tails du site pour l'identifiant ${scan.siteId || scan.code}:`, siteError);
                scan.siteName = scan.code; // Afficher le code si erreur
              }
              
              // Ne r√©cup√©rer les informations sur le site que s'il ne s'agit pas d'un conteneur
              if (scan.site && 
                  !scan.site.startsWith('TEST_CONTENANT_') && 
                  !scan.site.match(/^[0-9]{13,}$/)) {
                const siteInfo = await firebaseService.getSiteById(scan.site);
                if (siteInfo) return { ...scan, siteDetails: { ...siteInfo } };
              }
            } catch (e) {
              console.error('Erreur r√©cup√©ration nom site Firestore:', e);
            }
            return scan;
          })
        );
        
        // Mettre √† jour l'√©tat avec l'historique enrichi
        setHistoricalScans(enrichedScans);
        setSessionHistoryLoaded(true);
        
        // Sauvegarder √©galement dans AsyncStorage pour la persistance locale temporaire
        await AsyncStorage.setItem('scanHistory', JSON.stringify(enrichedScans));
      }
      
      setLoading(false); // Masquer l'indicateur de chargement
    } catch (error) {
      console.error('Erreur lors du chargement des scans depuis Firestore:', error);
      setLoading(false); // Masquer l'indicateur de chargement en cas d'erreur
    }
  };

  // --- AJOUTER CETTE FONCTION D'AIDE --- 
  // Fonction pour consolider et trier les scans
  const consolidateAndSortScans = (existingScans, newScans) => {
    const map = new Map();

    // Ajouter les scans existants √† la map
    existingScans.forEach(scan => {
      if (scan.code) map.set(scan.code, scan);
    });

    // Mettre √† jour ou ajouter les nouveaux scans
    newScans.forEach(scan => {
      if (scan.code) map.set(scan.code, scan);
    });

    // Convertir la map en tableau
    const consolidated = Array.from(map.values());

    // Trier
    consolidated.sort((a, b) => {
      const dateA = a.scanDate ? new Date(a.scanDate).getTime() : 0;
      const dateB = b.scanDate ? new Date(b.scanDate).getTime() : 0;
      if (isNaN(dateA) && isNaN(dateB)) return 0;
      if (isNaN(dateA)) return 1;
      if (isNaN(dateB)) return -1;
      return dateB - dateA;
    });

    return consolidated;
  };
  // --- FIN DE L'AJOUT ---

  const loadTakingCarePackages = async () => {
    try {
      const scansEnCours = await firebaseService.getScansEnCours();
      // Filtrer pour exclure les scans "pas_de_colis"
      const filteredScans = scansEnCours.filter(scan => 
        scan.status !== 'pas_de_colis' &&
        !(scan.code && scan.code.startsWith('SITE_'))
      );
      console.log(`‚úÖ ${filteredScans.length} paquet(s) pris en charge r√©cup√©r√©(s) (sans les "pas_de_colis")`);
      setTakingCarePackages(filteredScans);
    } catch (error) {
      console.error('‚ùå Erreur lors du chargement des paquets pris en charge:', error);
    }
  };

  // üîπ Simulation d'un scan avec des sites valides
  const simulateScan = () => {
    if (scanMode === 'site') {
      // Sites de test qui seront reconnus comme valides
      const sitesDemoValides = [
        'SITE123',
        'SITE456',
        'SITE789',
        'LAB001',
        '12345'
      ];
      
      // S√©lectionner un site al√©atoire parmi les sites valides pour la d√©mo
      return sitesDemoValides[Math.floor(Math.random() * sitesDemoValides.length)];
    } else {
      // Si on est en mode sortie (d√©p√¥t), on doit scanner un colis d√©j√† pris en charge
      if (operationType === 'sortie') {
        // V√©rifier si des colis sont disponibles
        if (takingCarePackages.length > 0) {
          // S√©lectionner un colis al√©atoire parmi les colis pris en charge
          const randomPackage = takingCarePackages[Math.floor(Math.random() * takingCarePackages.length)];
          return randomPackage.code;
        } else {
          // Aucun colis disponible pour le d√©p√¥t - cette condition est g√©r√©e dans handleSimulatedScan
          return '';
        }
      } else {
        // Simuler un scan de contenant pour prise en charge
        // Utiliser un pr√©fixe sp√©cifique pour les tests afin de pouvoir les identifier facilement
        const testId = Date.now(); // Utiliser le timestamp actuel pour cr√©er un ID unique
        return `TEST_CONTENANT_${testId}`;
      }
    }
  };

  // Modification pour les tests : fonction mock qui simule verifySiteCode
  const mockVerifySiteCode = async (siteCode) => {
    // Sites de test qui seront automatiquement valid√©s
    const sitesDemoValides = {
      'SITE123': { nom: 'Site Test 1', adresse: '123 Rue Principale', ville: 'Paris', codePostal: '75001' },
      'SITE456': { nom: 'Site Test 2', adresse: '456 Avenue R√©publique', ville: 'Lyon', codePostal: '69001' },
      'SITE789': { nom: 'Site Test 3', adresse: '789 Boulevard des Tests', ville: 'Toulouse', codePostal: '31000' },
      '12345': { nom: 'Laboratoire Central', adresse: '12 Rue des Sciences', ville: 'Montpellier', codePostal: '34000' },
      'LAB001': { nom: 'Laboratoire Mobile', adresse: 'Zone Industrielle', ville: 'Bordeaux', codePostal: '33000' }
    };

    // V√©rifier si le code scann√© est dans notre liste de sites de test
    if (sitesDemoValides[siteCode]) {
      // Retourner une structure simulant la r√©ponse de Firebase
      return {
        valid: true,
        site: {
          id: `mock_${siteCode}`,
          code: siteCode,
          nom: sitesDemoValides[siteCode].nom,
          adresse: sitesDemoValides[siteCode].adresse,
          ville: sitesDemoValides[siteCode].ville,
          codePostal: sitesDemoValides[siteCode].codePostal
        }
      };
    }

    // Si ce n'est pas un site de test, passer √† la v√©rification normale dans Firebase
    return await firebaseService.verifySiteCode(siteCode);
  };

  const processScannedData = async (data) => {
    console.log('Code scann√©:', data);
    try {
      // Cas 1: Nous n'avons pas encore scann√© de site
      if (!siteScanned && scanMode === 'site') {
        console.log('[processScannedData] Mode: Scan de site. Donn√©es:', data);
        const siteVerification = await firebaseService.verifySiteCode(data);
        console.log('[processScannedData] R√©sultat de verifySiteCode:', JSON.stringify(siteVerification));

        if (siteVerification.site) {
          // Enregistrer les infos du site
          setSiteCode(data);
          setSiteDetails(siteVerification.site);
          // setSiteScanned(true); // Mis plus bas pour ne l'activer qu'apr√®s succ√®s
          // setScanMode(''); // Mis plus bas
          // setShowOperationTypeSelection(true); // Mis plus bas

          // --- MODIFI√â: Ne trouver que le premier site non visit√© avec ce nom ---
          let occurrenceIndex = null;
          if (tourneeProgressRef.current?.getSitesWithStatus) {
            const sitesList = tourneeProgressRef.current.getSitesWithStatus();
            console.log('[processScannedData] sitesList depuis tourneeProgressRef:', JSON.stringify(sitesList.map(s => ({ id: s.id, name: s.name, visited: s.visited, uniqueDisplayId: s.uniqueDisplayId }))));
            const siteNameToFind = siteVerification.site.nom || siteVerification.site.name;
            console.log('[processScannedData] Nom du site √† trouver:', siteNameToFind);

            // Trouver le premier site non visit√© avec ce nom
            occurrenceIndex = sitesList.findIndex(s => !s.visited && (s.name === siteNameToFind || s.nom === siteNameToFind)); // Ajout de s.nom
            console.log(`[processScannedData] Occurrence index trouv√©e pour ${siteNameToFind}:`, occurrenceIndex);
            
            // Si aucun site non visit√© n'est trouv√©, ne rien faire
            if (occurrenceIndex === -1) {
              Alert.alert(
                'Site d√©j√† visit√© ou non trouv√©', // Message mis √† jour
                'Ce site a d√©j√† √©t√© visit√©, ne fait pas partie de cette tourn√©e, ou son nom ne correspond pas exactement.', // Message mis √† jour
                [{ text: 'OK', onPress: () => {
                  // R√©initialiser l'√©tat pour permettre un nouveau scan
                  setSiteScanned(false);
                  setSiteDetails(null);
                  setSiteCode('');
                  setShowOperationTypeSelection(false);
                }}]
              );
              return;
            }
          } else {
            console.warn('[processScannedData] tourneeProgressRef.current.getSitesWithStatus non disponible.');
            Alert.alert('Erreur', 'Impossible de r√©cup√©rer la liste des sites de la tourn√©e.');
            return;
          }

          // Marquage en session via l'index si trouv√©, sinon par site.id
          const identifier = siteVerification.site.id || (siteVerification.site.code || data);
          console.log('[processScannedData] Identifier pour markSiteVisitedInSession:', identifier);
          console.log('[processScannedData] currentSessionId avant appel:', currentSessionId);
          console.log('[processScannedData] occurrenceIndex avant appel:', occurrenceIndex);

          if (!currentSessionId) {
            console.error('[processScannedData] ID de session manquant avant markSiteVisitedInSession');
            Alert.alert('Erreur Critique', 'ID de session manquant. Impossible de continuer.');
            return;
          }
          
          // Ne marquer qu'un seul site √† la fois, en utilisant l'index sp√©cifique
          if (occurrenceIndex !== -1 && occurrenceIndex !== null) { // Condition d√©j√† pr√©sente, mais on log avant
            const markSuccess = await firebaseService.markSiteVisitedInSession(currentSessionId, identifier, occurrenceIndex);
            console.log('[processScannedData] R√©sultat de markSiteVisitedInSession:', markSuccess);
            
            if (markSuccess) {
              setSiteScanned(true); // Activer seulement si le marquage Firestore a r√©ussi
              setScanMode(''); 
              setShowOperationTypeSelection(true);

              // Mise √† jour du UI local - mettre √† jour uniquement le site sp√©cifique
              if (tourneeProgressRef.current?.markSiteAsVisitedLocally) {
                console.log('[processScannedData] Appel de markSiteAsVisitedLocally avec:', identifier, occurrenceIndex);
                await tourneeProgressRef.current.markSiteAsVisitedLocally(identifier, occurrenceIndex); // AJOUT DE AWAIT
                // Temporairement comment√© pour tester si la coche se met √† jour correctement sans rechargement imm√©diat
                // await updateTourneeProgress(); 
              } else if (tourneeProgressRef.current?.loadTourneeDetails) {
                console.log('[processScannedData] Appel de loadTourneeDetails(true) car markSiteAsVisitedLocally non dispo.');
                await tourneeProgressRef.current.loadTourneeDetails(true);
              }
            } else {
              Alert.alert('Erreur', '√âchec du marquage du site comme visit√© dans la session Firestore.');
              // Garder siteScanned √† false, etc.
            }
            
            // Si updateTourneeProgress a √©t√© comment√©, on peut appeler loadHistoricalData ici
            // si c'est n√©cessaire pour d'autres parties de l'UI non li√©es √† TourneeProgress.
            // Pour l'instant, on isole le probl√®me de la coche.
            // await loadHistoricalData(); 

          } else {
             console.warn('[processScannedData] occurrenceIndex invalide, markSiteVisitedInSession non appel√©.');
             // Potentiellement une alerte ici si ce cas ne devrait pas arriver
          }
          return;
        } else { // siteVerification.site est null/undefined
          console.log('[processScannedData] Aucun site valide retourn√© par verifySiteCode pour le code:', data);
          Alert.alert('Site Inconnu', 'Le code scann√© ne correspond √† aucun site connu.');
           // R√©initialiser pour permettre un nouveau scan
          setSiteScanned(false);
          setSiteDetails(null);
          setSiteCode('');
          setShowOperationTypeSelection(false);
        }
      }
      
      // Cas 2: Site d√©j√† scann√©, nous scannons maintenant un contenant
      if (siteScanned && scanMode === 'contenant') {
        console.log('[processScannedData] Mode: Scan de contenant. Donn√©es:', data);
        handleContenantScan(data);
        // Rester en mode scan contenant pour permettre les scans multiples
        setScanMode('contenant');
      }
    } catch (error) {
      console.error('Erreur lors de la gestion du scan:', error);
      setErrorMessage('Erreur: ' + error.message); // Afficher l'erreur √† l'utilisateur
      setScanMode(''); // R√©initialiser le mode scan
      // Optionnel: r√©initialiser d'autres √©tats si n√©cessaire
      setSiteScanned(false);
      setSiteDetails(null);
      setSiteCode('');
      setShowOperationTypeSelection(false);
    }
  };

  // G√©rer la simulation d'un scan (pour le d√©veloppement et les tests)
  const handleSimulatedScan = () => {
    // V√©rifier si on est en mode sortie sans colis pris en charge
    if (scanMode === 'contenant' && operationType === 'sortie' && takingCarePackages.length === 0) {
      Alert.alert(
        "Aucun colis disponible",
        "Vous n'avez aucun colis en prise en charge √† d√©poser.",
        [{ text: "OK" }]
      );
      return;
    }
    
    const fakeData = simulateScan();
    if (fakeData) {
      console.log(`Simulation de scan avec donn√©es: ${fakeData}`);
    processScannedData(fakeData);
    } else {
      console.error("Erreur lors de la simulation du scan: aucune donn√©e g√©n√©r√©e");
      Alert.alert(
        "Erreur",
        "Impossible de simuler un scan. Veuillez r√©essayer.",
        [{ text: "OK" }]
      );
    }
  };

  const handleManualScan = () => {
    if (manualCodeInput.trim() === '') {
      Alert.alert('Erreur', 'Veuillez entrer un code valide');
      return;
    }
    
    processScannedData(manualCodeInput.trim());
    setManualCodeInput('');
  };

  const activateSiteScan = () => {
    setScanMode('site');
    setErrorMessage('');
    setIsReadyForScan(true);
    
    // Montrer une alerte avec plusieurs options pour scanner
    Alert.alert(
      "Scanner un site",
      "Comment souhaitez-vous scanner le site ?",
      [
        {
          text: "Scanner manuellement",
          onPress: () => showManualSiteInput()
        },
        {
          text: "Simuler scan",
          onPress: handleSimulatedScan
        },
        {
          text: "Annuler",
          style: "cancel",
          onPress: () => setScanMode('')
        }
      ]
    );
  };

  // Fonction pour afficher une bo√Æte de dialogue pour saisir manuellement le code du site
  const showManualSiteInput = () => {
    // Utiliser Alert.prompt sur iOS, mais sur Android, cette fonction n'existe pas
    // donc nous utilisons une m√©thode alternative
    if (Platform.OS === 'ios') {
      Alert.prompt(
        "Scanner site manuellement",
        "Entrez le code ou le nom du site",
        [
          { text: "Annuler", onPress: () => setScanMode(''), style: "cancel" },
          { 
            text: "Scanner", 
            onPress: (code) => {
              if (code && code.trim()) {
                processScannedData(code.trim());
              } else {
                setScanMode('');
                Alert.alert("Erreur", "Veuillez entrer un code de site valide");
              }
            }
          }
        ],
        "plain-text"
      );
    } else {
      // Sur Android, utiliser une solution simple avec TextInput
      Alert.alert(
        "Scanner site manuellement",
        "Entrez le code du site dans le champ de texte en haut de l'√©cran, puis appuyez sur Scanner",
        [
          { text: "OK" }
        ]
      );
      // Focus sur le champ de saisie manuelle
      // Note: ceci est une approche simplifi√©e, une solution plus robuste
      // utiliserait un modal personnalis√© avec TextInput
      setManualCodeInput('');
      // On garde le mode scan actif pour que le bouton scanner manuel fonctionne
    }
  };

  // Afficher la page de s√©lection du type d'op√©ration
  const showOperationSelection = () => {
    setShowOperationTypeSelection(true);
  };

  // Commencer le scan de contenant avec un type d'op√©ration sp√©cifique
  const startContenantScan = (type) => {
    setOperationType(type);
    setShowOperationTypeSelection(false);
    setScanMode('contenant');
    setErrorMessage('');
    setIsReadyForScan(true);
    
    // Message diff√©rent selon le type d'op√©ration
    const message = type === 'entree' 
      ? "Veuillez scanner le code du contenant √† prendre en charge" 
      : "Veuillez scanner le code du contenant √† d√©poser";
    
    Alert.alert(
      type === 'entree' ? "Prise en charge" : "D√©p√¥t",
      message,
      [{ text: "Annuler", onPress: () => setScanMode('') }]
    );
  };

  const handleContenantScan = async (code) => {
    if (!siteScanned) {
      Alert.alert('Erreur', 'Veuillez d\'abord scanner un site');
      return;
    }

    try {
      // Mode d√©p√¥t (sortie) - v√©rifier que le colis est dans la liste des colis pris en charge
      if (operationType === 'sortie') {
        const isInTakingCare = takingCarePackages.some(pkg => pkg.code === code);
        if (!isInTakingCare) {
          Alert.alert(
            "Colis non reconnu",
            "Ce colis ne fait pas partie des colis que vous avez en prise en charge.",
            [{ text: "OK" }]
          );
          return;
        }
        
        // Retirer le colis de la liste des colis pris en charge
        setTakingCarePackages(takingCarePackages.filter(pkg => pkg.code !== code));
      }

      // Obtenir la date actuelle au format appropri√©
      const currentDate = new Date();
      const currentDateISO = currentDate.toISOString();

      // Ajouter le contenant √† la liste
      const newContenant = {
        id: Date.now().toString(),
        code: code,
        idColis: code,
        timeStamp: currentDate.toLocaleTimeString(),
        date: currentDate.toLocaleDateString(),
        scanDate: currentDateISO,
        site: siteCode,
        type: operationType, // Ajout du type d'op√©ration (entr√©e/sortie)
      };
      
      setScannedContenants([newContenant, ...scannedContenants]);
    } catch (error) {
      console.error('Erreur lors de la gestion du scan:', error);
      setScanMode('');
    }
  };

  const renderScannedItem = ({ item }) => (
    <View style={[styles.contenantItem, item.type === 'sortie' ? styles.contenantItemSortie : styles.contenantItemEntree]}>
      <View style={styles.contenantInfo}>
        <Text style={styles.contenantCode}>{item.code}</Text>
        <View style={styles.contenantTypeRow}>
          <View style={item.type === 'sortie' ? styles.typeTagSortie : styles.typeTagEntree}>
            <Text style={styles.typeTagText}>{item.type === 'sortie' ? 'D√©p√¥t' : 'Prise en charge'}</Text>
          </View>
          <Text style={styles.contenantTime}>{item.timeStamp}</Text>
        </View>
      </View>
      <TouchableOpacity
        style={styles.deleteContenantButton}
        onPress={() => removeScannedContenant(item.id)}
      >
        <Ionicons name="trash-outline" size={20} color="#e74c3c" />
      </TouchableOpacity>
    </View>
  );

  const removeScannedContenant = (id) => {
    setScannedContenants(scannedContenants.filter(contenant => contenant.id !== id));
  };

  const handleTransmit = async () => {
    if (scannedContenants.length === 0) {
      Alert.alert('Attention', 'Aucun contenant scann√© √† transmettre.');
      return;
    }

    setLoading(true);

    try {
      // V√©rifier et afficher les donn√©es de la session pour le d√©bogage
      console.log('Donn√©es de session:', JSON.stringify(sessionData, null, 2));
      console.log('Donn√©es de route:', JSON.stringify(route.params, null, 2));
      
      // R√©cup√©rer les donn√©es de la tourn√©e et du v√©hicule avec plus de v√©rifications
      const tourneeName = sessionData.tournee?.nom || route.params?.tournee?.nom || '';
      const tourneeId = sessionData.tournee?.id || route.params?.tournee?.id || '';
      const vehiculeName = sessionData.vehicule?.immatriculation || route.params?.vehicule?.immatriculation || '';
      const vehiculeId = sessionData.vehicule?.id || route.params?.vehicule?.id || '';
      
      // Utiliser les d√©tails du site valid√© s'ils sont disponibles
      let siteName, siteId, siteAdresse, siteCodePostal, siteVille;
      
      if (siteDetails) {
        // Utiliser les bonnes cl√©s du siteDetails (nommage uniforme)
        siteName = siteDetails.name || siteCode;
        siteId = siteDetails.id || '';
        siteAdresse = siteDetails.address || '';
        siteCodePostal = siteDetails.codePostal || '';
        siteVille = siteDetails.city || '';
      } else {
        // Sinon on utilise ce qu'on a par d√©faut
        siteName = sessionData.tournee?.siteDepart || route.params?.tournee?.siteDepart || siteCode || 'Non sp√©cifi√©';
        siteId = '';
      }
      
      console.log('Donn√©es r√©cup√©r√©es pour les scans:', {
        tourneeName,
        tourneeId,
        vehiculeName,
        vehiculeId,
        siteName,
        siteId,
        siteCode
      });

      // R√©cup√©rer l'ID de session actuel
      const currentSessionId = await AsyncStorage.getItem('currentSessionId') || `session_${Date.now()}`;
      
      // Pr√©parer les scans avec tous les champs n√©cessaires
      const scansToSubmit = scannedContenants.map(scan => {
        const scanDate = scan.scanDate || new Date().toISOString();
        
        // Le code du contenant devient l'ID du colis
        const scanItem = {
          code: scan.code,
          idColis: scan.code || scan.idColis,
          scanDate: scanDate,
          tournee: tourneeName,
          tourneeId: tourneeId,
          vehicule: vehiculeName,
          vehiculeId: vehiculeId,
          immatriculation: vehiculeName,
          site: siteName,
          siteId: siteId,
          siteCode: siteCode,
          siteDepart: siteName,
          siteD√©part: siteName,
          sessionId: currentSessionId, // Ajouter l'ID de session pour le filtrage ult√©rieur
          operationType: scan.type || 'entree', // Ajout du type d'op√©ration
          status: scan.type === 'sortie' ? 'livr√©' : 'en-cours', // Status bas√© sur le type d'op√©ration
          type: scan.type || 'entree' // Assurer que le type est inclus explicitement
        };
        
        // Ajouter siteFin uniquement pour les colis livr√©s
        if (scan.type === 'sortie') {
          // Pour les op√©rations de sortie (d√©p√¥t), ajouter des informations sp√©cifiques
          const currentDate = new Date();
          
          // Utiliser le nom du site actuel comme site d'arriv√©e
          scanItem.siteFin = siteName;
          // Ajouter date et heure d'arriv√©e au format correct
          scanItem.dateArrivee = currentDate.toLocaleDateString();
          scanItem.heureArrivee = currentDate.toLocaleTimeString();
          // Ajouter ces champs suppl√©mentaires pour assurer la compatibilit√©
          scanItem.dateHeureFin = currentDate.toISOString();
          scanItem.statut = 'Livr√©';
          scanItem.status = 'livr√©'; // Assurez-vous que les deux formats sont pr√©sents
          scanItem.coursierLivraison = sessionData.coursierCharg || route.params?.coursierCharg || '';
        }
        
        // Ajouter les d√©tails du site s'ils sont disponibles
        if (siteDetails) {
          scanItem.siteDetails = {
            adresse: siteAdresse,
            codePostal: siteCodePostal,
            ville: siteVille
          };
        }

        // Ajouter la localisation si disponible
        if (sessionData.location) {
          scanItem.location = {
            latitude: sessionData.location.coords.latitude,
            longitude: sessionData.location.coords.longitude,
            accuracy: sessionData.location.coords.accuracy
          };
        }

        return scanItem;
      });
      
      // Afficher les donn√©es qui seront transmises
      console.log('Transmission des scans:', JSON.stringify(scansToSubmit, null, 2)); // D√©comment√© pour d√©bogage
      
      // Envoyer les scans √† Firebase
      const result = await firebaseService.addScans(scansToSubmit);
      console.log('R√©sultat de la transmission:', result);
      
      // Si la transmission r√©ussit, mettre √† jour l'historique local
      if (result.success) {
        // --- Logique de consolidation --- 
        const updatedScansMap = new Map();
        historicalScans.forEach(scan => {
          // Assurer qu'on a un code pour la cl√© de la map
          if (scan.code) {
            updatedScansMap.set(scan.code, scan);
          }
        });
        scansToSubmit.forEach(scan => {
          if (scan.code) {
            const originalScan = scannedContenants.find(s => s.code === scan.code);
            const scanForHistory = {
              ...scan,
              timeStamp: originalScan?.timeStamp || dateUtils.formatTime(scan.scanDate),
            };
            updatedScansMap.set(scan.code, scanForHistory);
          }
        });
        const newHistory = Array.from(updatedScansMap.values());
        newHistory.sort((a, b) => {
          const dateA = a.scanDate ? new Date(a.scanDate).getTime() : 0;
          const dateB = b.scanDate ? new Date(b.scanDate).getTime() : 0;
          if (isNaN(dateA) && isNaN(dateB)) return 0;
          if (isNaN(dateA)) return 1;
          if (isNaN(dateB)) return -1;
          return dateB - dateA;
        });
        // --- Fin de la logique de consolidation ---

        // Sauvegarder l'historique consolid√© dans AsyncStorage
        await AsyncStorage.setItem('scanHistory', JSON.stringify(newHistory));
        
        // Mise √† jour de l'√©tat React DIFF√âR√âE apr√®s les interactions
        InteractionManager.runAfterInteractions(() => {
          setHistoricalScans(newHistory);
        });
        
        // Mettre √† jour la liste des paquets pris en charge
        if (operationType === 'entree') {
          setTakingCarePackages([...scansToSubmit, ...takingCarePackages]);
        } else if (operationType === 'sortie') {
          const codesDeposited = scansToSubmit.map(scan => scan.code);
          setTakingCarePackages(takingCarePackages.filter(pkg => pkg.code && !codesDeposited.includes(pkg.code)));
        }
        
        // R√©initialiser compl√®tement l'√©tat pour revenir √† l'√©cran de scan de site
        resetScan(); // Cette fonction r√©initialise les √©tats de base

        // S'assurer que tous les √©tats sont correctement r√©initialis√©s pour revenir √† l'√©cran initial
        setShowOperationTypeSelection(false);
        setOperationType('entree'); // R√©initialiser √† l'entr√©e de colis par d√©faut
        
        // Important: D√©sactiver le chargement AVANT l'alerte
        setLoading(false);
        
        // Afficher l'alerte de succ√®s
        Alert.alert(
          'Succ√®s',
          `${scansToSubmit.length} scan(s) transmis avec succ√®s`,
          [{ text: 'OK' }]
        );
      } else {
        setLoading(false);
        throw new Error(result.error || '√âchec de la transmission');
      }
    } catch (error) {
      console.error('Erreur lors de la transmission:', error);
      setLoading(false);
      Alert.alert('Erreur', `√âchec de la transmission: ${error.message}`);
    }
  };

  const resetScan = () => {
    setScanMode('');
    setSiteScanned(false);
    setSiteCode('');
    setScannedContenants([]);
    setManualCodeInput('');
    setSiteDetails(null);
  };

  const navigateToHistory = () => {
    setShowHistoryModal(true);
  };

  // Fonction pour obtenir les d√©tails de la session actuelle
  const getSessionDetails = async () => {
    try {
      const currentSession = await firebaseService.getCurrentSession();
      if (currentSession) {
        setSessionId(currentSession.id);
        setTournee(currentSession.tournee);
        setVehicule(currentSession.vehicule);
        setPole(currentSession.pole);
      }
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration de la session:", error);
    }
  };

  // Fonction pour effacer l'historique des scans
  const clearHistoricalScans = async () => {
    try {
      Alert.alert(
        'Effacer l\'historique',
        'Voulez-vous vraiment effacer tout l\'historique des scans?',
        [
          {
            text: 'Annuler',
            style: 'cancel'
          },
          {
            text: 'Effacer',
            onPress: async () => {
              await AsyncStorage.removeItem('scanHistory');
              setHistoricalScans([]);
              Alert.alert('Succ√®s', 'Historique effac√© avec succ√®s');
            },
            style: 'destructive'
          }
        ]
      );
    } catch (error) {
      console.error('Erreur lors de l\'effacement de l\'historique:', error);
      Alert.alert('Erreur', 'Impossible d\'effacer l\'historique');
    }
  };

  // Ajout d'une fonction pour effacer explicitement tous les scans de la session actuelle
  const clearCurrentSessionScans = async () => {
    try {
      const currentSessionId = await AsyncStorage.getItem('currentSessionId');
      if (!currentSessionId) {
        Alert.alert('Erreur', 'Impossible de d√©terminer la session actuelle');
        return;
      }
      
      Alert.alert(
        'R√©initialiser l\'historique',
        'Cette action va supprimer tous les scans associ√©s √† votre session actuelle. Continuer?',
        [
          {
            text: 'Annuler',
            style: 'cancel'
          },
          {
            text: 'Supprimer',
            onPress: async () => {
              try {
                // Supprimer les scans associ√©s √† la session actuelle
                setLoading(true);
                console.log(`Suppression des scans de la session ${currentSessionId}...`);
                
                // Fonction c√¥t√© service qui devrait √™tre impl√©ment√©e
                // pour supprimer tous les scans de la session
                const result = await firebaseService.clearSessionScans(currentSessionId);
                
                // Supprimer l'historique local √©galement
                await AsyncStorage.removeItem('scanHistory');
                setHistoricalScans([]);
                
                setLoading(false);
                Alert.alert('Succ√®s', 'Historique r√©initialis√© avec succ√®s');
              } catch (error) {
                setLoading(false);
                console.error('Erreur lors de la suppression des scans:', error);
                Alert.alert('Erreur', `√âchec de la suppression: ${error.message}`);
              }
            },
            style: 'destructive'
          }
        ]
      );
    } catch (error) {
      console.error('Erreur:', error);
      Alert.alert('Erreur', 'Une erreur est survenue');
    }
  };

  // Handler de d√©connexion avec effacement complet de l'historique
  const handleLogout = async () => {
    try {
      Alert.alert(
        'D√©connexion',
        'Voulez-vous vous d√©connecter? L\'historique des scans sera effac√©.',
        [
          {
            text: 'Annuler',
            style: 'cancel'
          },
          {
            text: 'D√©connecter',
            onPress: async () => {
              try {
                setLoading(true);
                console.log('D√©connexion en cours...');

                // Appeler la m√©thode de d√©connexion de Firebase
                await firebaseService.logout();
                console.log('D√©connexion Firebase r√©ussie');
                
                // Effacer toutes les donn√©es de session
                await AsyncStorage.removeItem('userSessionActive');
                // On conserve current_session_id pour que la tourn√©e visit√©e reste en m√©moire
                await AsyncStorage.removeItem('scanHistory');
                await AsyncStorage.removeItem('user_selas_id');
                
                // R√©initialiser les √©tats
                setHistoricalScans([]);
                setScannedContenants([]);
                setSiteScanned(false);
                setSiteCode('');
                
                setLoading(false);
                
                // Rediriger vers l'√©cran de connexion
                navigation.reset({
                  index: 0,
                  routes: [{ name: 'Login' }]
                });
              } catch (error) {
                setLoading(false);
                console.error('Erreur lors du processus de d√©connexion:', error);
                Alert.alert('Erreur', 'Impossible de se d√©connecter. Veuillez r√©essayer.');
              }
            }
          }
        ]
      );
    } catch (error) {
      console.error('Erreur lors de la d√©connexion:', error);
    }
  };

  // Utiliser directement les fonctions de formatage de dateUtils
  // au lieu de red√©finir des fonctions similaires

  // Effet pour √©couter les √©v√©nements de scan Zebra
  useEffect(() => {
    if (isReadyForScan) {
      // Afficher un message pour indiquer que l'application est pr√™te pour le scan
      console.log('Pr√™t √† recevoir des scans du scanner Zebra');
      
      // Configuration pour recevoir les scans du mat√©riel Zebra
      const handleZebraScan = (event) => {
        // Le scanner Zebra envoie g√©n√©ralement les donn√©es comme des entr√©es clavier
        // Nous devons v√©rifier que nous sommes en mode scan et traiter les donn√©es
        if (event && event.nativeEvent && event.nativeEvent.key === 'Enter' && scanMode) {
          // R√©cup√©rer le texte scann√© (par exemple depuis un champ de texte cach√© ou via une API Zebra)
          // Pour les besoins de cet exemple, nous utiliserons la valeur de manualCodeInput
          if (manualCodeInput.trim()) {
            processScannedData(manualCodeInput.trim());
            setManualCodeInput(''); // R√©initialiser apr√®s le traitement
          }
        }
      };
      
      // Ajoutez ici l'initialisation sp√©cifique au scanner Zebra si n√©cessaire
      // Exemple : ZebraScanner.initialize() si une API Zebra est disponible
      
      // Pour cet exemple, on simule en utilisant l'√©couteur de clavier (pour Enter)
      Keyboard.addListener('keyDown', handleZebraScan);
      
      return () => {
        // Nettoyage lors du d√©montage
        Keyboard.removeListener('keyDown', handleZebraScan);
        // D√©sinitialiser le scanner Zebra si n√©cessaire
        // Exemple : ZebraScanner.deinitialize()
      };
    }
  }, [isReadyForScan, scanMode, manualCodeInput]);


  const loadHistoricalScans = async () => {
    try {
      const jsonValue = await AsyncStorage.getItem('scanHistory');
      if (jsonValue !== null) {
        const history = JSON.parse(jsonValue);
        
        // R√©cup√©rer l'ID de la tourn√©e actuelle
        const currentSession = await firebaseService.getCurrentSession();
        const currentTourneeId = currentSession?.tournee?.id || sessionData?.tournee?.id || '';
        
        // Filtrer l'historique local
        const today = new Date();
        today.setHours(0, 0, 0, 0); // D√©but de la journ√©e
        
        const filteredHistory = history.filter(item => {
          // Convertir la date de l'item en objet Date
          let itemDate;
          try {
            itemDate = new Date(item.date);
            if (isNaN(itemDate.getTime())) {
              // Si la date n'est pas valide, essayer un autre format
              const parts = item.date.split('/');
              if (parts.length === 3) {
                itemDate = new Date(parts[2], parts[1] - 1, parts[0]);
              }
            }
          } catch (e) {
            // En cas d'erreur, consid√©rer cet item comme non valide pour le filtre
            return false;
          }

          // S'assurer que nous avons une date valide
          if (!itemDate || isNaN(itemDate.getTime())) return false;
          
          itemDate.setHours(0, 0, 0, 0); // Normaliser √† minuit
          
          // V√©rifier la tourn√©e
          const isSameTournee = !currentTourneeId || item.tourneeId === currentTourneeId;
          
          // V√©rifier le statut (inclut les visites sans colis)
          const hasValidStatus = item.status === 'en-cours' || item.status === 'livr√©';
          
          // L'item doit √™tre du jour courant ET de la m√™me tourn√©e ET avoir un statut valide
          return itemDate.getTime() === today.getTime() && isSameTournee && hasValidStatus;
        });
        
        console.log(`Historique local filtr√©: ${filteredHistory.length} scans (jour + tourn√©e + statut)`);
        
        // Consolider l'historique filtr√© avant de mettre √† jour l'√©tat
        const consolidatedHistory = consolidateAndSortScans([], filteredHistory);

        // Enrichir avec le nom complet du site depuis Firestore
        const enrichedHistory = await Promise.all(
          consolidatedHistory.map(async (scan) => {
            // Tenter de r√©cup√©rer les d√©tails du site en utilisant siteId ou code
            try {
              const siteIdentifier = scan.siteId || scan.code; // Utiliser ID ou code
              // V√©rifier si l'identifiant est probablement un site avant d'appeler getSiteById
              if (siteIdentifier && 
                  !siteIdentifier.startsWith('TEST_CONTENANT_') && 
                  !siteIdentifier.match(/^[0-9]{13,}$/)) { 
                const siteInfo = await firebaseService.getSiteById(siteIdentifier);
                if (siteInfo) {
                  // Enrichir le scan avec les d√©tails complets
                  return { 
                    ...scan, 
                    siteName: siteInfo.nom || siteInfo.name, // Ajouter le nom pour affichage facile
                    siteDetails: { ...siteInfo } 
                  };
                }
              }
            } catch (e) {
              console.warn(`[loadHistoricalScans] Erreur r√©cup√©ration d√©tails site pour ${scan.code || scan.id}:`, e);
            }
            // Si non trouv√© ou erreur, retourner le scan original
            return scan;
          })
        );
        
        // Mettre √† jour l'√©tat avec l'historique enrichi
        setHistoricalScans(enrichedHistory);
        setSessionHistoryLoaded(true);
      }
    } catch (error) {
      console.error('Erreur lors du chargement de l\'historique:', error);
    }
  };

  const loadFirestoreScans = async () => {
    try {
      // On ne charge les scans Firestore que si la session est active
      const userSessionActive = await AsyncStorage.getItem('userSessionActive');
      if (userSessionActive !== 'true') {
        // Si aucune session active, on ne charge pas l'historique Firestore
        return;
      }

      // R√©cup√©rer l'ID de session actuel
      const currentSessionId = await AsyncStorage.getItem('currentSessionId');
      console.log('Chargement des scans pour la session:', currentSessionId);

      // R√©cup√©rer l'ID de la tourn√©e actuelle
      const currentSession = await firebaseService.getCurrentSession();
      const currentTourneeId = currentSession?.tournee?.id || sessionData?.tournee?.id || '';
      console.log('Tourn√©e actuelle:', currentTourneeId);

      setLoading(true); // Afficher l'indicateur de chargement

      // R√©cup√©rer tous les scans de l'utilisateur (sans limite)
      const scans = await firebaseService.getScans();
      
      if (scans && scans.length > 0) {
        // Ne garder que les scans du jour (J0)
        const today = new Date();
        today.setHours(0, 0, 0, 0); // D√©but de la journ√©e
        
        const filteredScans = scans.filter(scan => {
          // Convertir la date du scan en objet Date
          const scanDate = dateUtils.convertTimestampToDate(scan.scanDate || scan.createdAt);
          if (!scanDate) return false;
          
          // R√©cup√©rer juste la date (sans l'heure)
          const scanDateOnly = new Date(scanDate);
          scanDateOnly.setHours(0, 0, 0, 0);
          
          // V√©rifier la tourn√©e (si une tourn√©e actuelle est d√©finie)
          const isSameTournee = !currentTourneeId || scan.tourneeId === currentTourneeId;
          
          // V√©rifier le statut (inclut "pas_de_colis")
          const hasValidStatus = scan.status === 'en-cours' || scan.status === 'livr√©';
          
          // Le scan doit √™tre du jour courant ET de la m√™me tourn√©e ET avoir un statut valide
          return scanDateOnly.getTime() === today.getTime() && isSameTournee && hasValidStatus;
        });
        
        // Convertir les scans Firestore filtr√©s en format compatible avec l'historique local
        const formattedScans = filteredScans.map(scan => {
          // D√©duire le statut si manquant, bas√© sur le type d'op√©ration
          let status = scan.status;
          if (!status) {
            status = scan.operationType === 'sortie' ? 'livr√©' : 'en-cours';
          }
          
          return {
            id: scan.id || Date.now().toString(),
            code: scan.code,
            timeStamp: dateUtils.formatTime(scan.scanDate || scan.createdAt),
            date: dateUtils.formatDate(scan.scanDate || scan.createdAt),
            site: scan.site,
            fromFirestore: true,
            sessionId: scan.sessionId,
            // Utiliser le statut (corrig√© si n√©cessaire)
            status: status, 
            // S'assurer que le type est aussi pr√©sent
            type: scan.operationType || (status === 'livr√©' ? 'sortie' : 'entree'), 
            tournee: scan.tournee || '',
            tourneeId: scan.tourneeId || '',
            scanDate: scan.scanDate ? dateUtils.convertTimestampToDate(scan.scanDate).toISOString() : (scan.createdAt ? dateUtils.convertTimestampToDate(scan.createdAt).toISOString() : new Date().toISOString()) // Garder une date ISO pour le tri
          };
        });
        
        // Consolider et trier
        const consolidatedScans = consolidateAndSortScans(historicalScans, formattedScans);
        // Enrichir avec le nom complet du site depuis Firestore
        const enrichedScans = await Promise.all(
          consolidatedScans.map(async (scan) => {
            try {
              // Tenter de r√©cup√©rer les d√©tails du site
              try {
                // Utiliser l'ID du site si disponible, sinon le code barre
                const siteIdentifier = scan.siteId || scan.code; // Assumer que siteId existe
                if (siteIdentifier && 
                    !siteIdentifier.startsWith('TEST_CONTENANT_') && 
                    !siteIdentifier.match(/^[0-9]{13,}$/)) {
                  // Utiliser une variable locale au lieu de r√©assigner l'√©tat siteDetails
                  const siteInfo = await firebaseService.getSiteById(siteIdentifier); 
                  if (siteInfo) {
                    // Modifier l'objet scan directement
                    scan.siteName = siteInfo.nom || siteInfo.name; // Utiliser le nom du site s'il est trouv√©
                    scan.siteDetails = siteInfo; // Ajouter les d√©tails au scan
                  } else {
                     // Si siteInfo est null, indiquer le nom comme code
                     scan.siteName = scan.code; 
                  }
                } else {
                   scan.siteName = scan.code; // Fallback si aucun identifiant
                }
              } catch (siteError) {
                console.warn(`[loadFirestoreScans] Impossible de r√©cup√©rer les d√©tails du site pour l'identifiant ${scan.siteId || scan.code}:`, siteError);
                scan.siteName = scan.code; // Afficher le code si erreur
              }
              
              // Ne r√©cup√©rer les informations sur le site que s'il ne s'agit pas d'un conteneur
              if (scan.site && 
                  !scan.site.startsWith('TEST_CONTENANT_') && 
                  !scan.site.match(/^[0-9]{13,}$/)) {
                const siteInfo = await firebaseService.getSiteById(scan.site);
                if (siteInfo) return { ...scan, siteDetails: { ...siteInfo } };
              }
            } catch (e) {
              console.error('Erreur r√©cup√©ration nom site Firestore:', e);
            }
            return scan;
          })
        );
        
        // Mettre √† jour l'√©tat avec l'historique enrichi
        setHistoricalScans(enrichedScans);
        setSessionHistoryLoaded(true);
        
        // Sauvegarder √©galement dans AsyncStorage pour la persistance locale temporaire
        await AsyncStorage.setItem('scanHistory', JSON.stringify(enrichedScans));
      }
      
      setLoading(false); // Masquer l'indicateur de chargement
    } catch (error) {
      console.error('Erreur lors du chargement des scans depuis Firestore:', error);
      setLoading(false); // Masquer l'indicateur de chargement en cas d'erreur
    }
  };

  // --- AJOUTER CETTE FONCTION D'AIDE --- 
  // Fonction pour consolider et trier les scans
  const consolidateAndSortScans = (existingScans, newScans) => {
    const map = new Map();

    // Ajouter les scans existants √† la map
    existingScans.forEach(scan => {
      if (scan.code) map.set(scan.code, scan);
    });

    // Mettre √† jour ou ajouter les nouveaux scans
    newScans.forEach(scan => {
      if (scan.code) map.set(scan.code, scan);
    });

    // Convertir la map en tableau
    const consolidated = Array.from(map.values());

    // Trier
    consolidated.sort((a, b) => {
      const dateA = a.scanDate ? new Date(a.scanDate).getTime() : 0;
      const dateB = b.scanDate ? new Date(b.scanDate).getTime() : 0;
      if (isNaN(dateA) && isNaN(dateB)) return 0;
      if (isNaN(dateA)) return 1;
      if (isNaN(dateB)) return -1;
      return dateB - dateA;
    });

    return consolidated;
  };
  // --- FIN DE L'AJOUT ---

  const loadTakingCarePackages = async () => {
    try {
      const scansEnCours = await firebaseService.getScansEnCours();
      // Filtrer pour exclure les scans "pas_de_colis"
      const filteredScans = scansEnCours.filter(scan => 
        scan.status !== 'pas_de_colis' &&
        !(scan.code && scan.code.startsWith('SITE_'))
      );
      console.log(`‚úÖ ${filteredScans.length} paquet(s) pris en charge r√©cup√©r√©(s) (sans les "pas_de_colis")`);
      setTakingCarePackages(filteredScans);
    } catch (error) {
      console.error('‚ùå Erreur lors du chargement des paquets pris en charge:', error);
    }
  };

  // üîπ Simulation d'un scan avec des sites valides
  const simulateScan = () => {
    if (scanMode === 'site') {
      // Sites de test qui seront reconnus comme valides
      const sitesDemoValides = [
        'SITE123',
        'SITE456',
        'SITE789',
        'LAB001',
        '12345'
      ];
      
      // S√©lectionner un site al√©atoire parmi les sites valides pour la d√©mo
      return sitesDemoValides[Math.floor(Math.random() * sitesDemoValides.length)];
    } else {
      // Si on est en mode sortie (d√©p√¥t), on doit scanner un colis d√©j√† pris en charge
      if (operationType === 'sortie') {
        // V√©rifier si des colis sont disponibles
        if (takingCarePackages.length > 0) {
          // S√©lectionner un colis al√©atoire parmi les colis pris en charge
          const randomPackage = takingCarePackages[Math.floor(Math.random() * takingCarePackages.length)];
          return randomPackage.code;
        } else {
          // Aucun colis disponible pour le d√©p√¥t - cette condition est g√©r√©e dans handleSimulatedScan
          return '';
        }
      } else {
        // Simuler un scan de contenant pour prise en charge
        // Utiliser un pr√©fixe sp√©cifique pour les tests afin de pouvoir les identifier facilement
        const testId = Date.now(); // Utiliser le timestamp actuel pour cr√©er un ID unique
        return `TEST_CONTENANT_${testId}`;
      }
    }
  };

  // Modification pour les tests : fonction mock qui simule verifySiteCode
  const mockVerifySiteCode = async (siteCode) => {
    // Sites de test qui seront automatiquement valid√©s
    const sitesDemoValides = {
      'SITE123': { nom: 'Site Test 1', adresse: '123 Rue Principale', ville: 'Paris', codePostal: '75001' },
      'SITE456': { nom: 'Site Test 2', adresse: '456 Avenue R√©publique', ville: 'Lyon', codePostal: '69001' },
      'SITE789': { nom: 'Site Test 3', adresse: '789 Boulevard des Tests', ville: 'Toulouse', codePostal: '31000' },
      '12345': { nom: 'Laboratoire Central', adresse: '12 Rue des Sciences', ville: 'Montpellier', codePostal: '34000' },
      'LAB001': { nom: 'Laboratoire Mobile', adresse: 'Zone Industrielle', ville: 'Bordeaux', codePostal: '33000' }
    };

    // V√©rifier si le code scann√© est dans notre liste de sites de test
    if (sitesDemoValides[siteCode]) {
      // Retourner une structure simulant la r√©ponse de Firebase
      return {
        valid: true,
        site: {
          id: `mock_${siteCode}`,
          code: siteCode,
          nom: sitesDemoValides[siteCode].nom,
          adresse: sitesDemoValides[siteCode].adresse,
          ville: sitesDemoValides[siteCode].ville,
          codePostal: sitesDemoValides[siteCode].codePostal
        }
      };
    }

    // Si ce n'est pas un site de test, passer √† la v√©rification normale dans Firebase
    return await firebaseService.verifySiteCode(siteCode);
  };

  const processScannedData = async (data) => {
    console.log('Code scann√©:', data);
    try {
      // Cas 1: Nous n'avons pas encore scann√© de site
      if (!siteScanned && scanMode === 'site') {
        console.log('[processScannedData] Mode: Scan de site. Donn√©es:', data);
        const siteVerification = await firebaseService.verifySiteCode(data);
        console.log('[processScannedData] R√©sultat de verifySiteCode:', JSON.stringify(siteVerification));

        if (siteVerification.site) {
          // Enregistrer les infos du site
          setSiteCode(data);
          setSiteDetails(siteVerification.site);
          // setSiteScanned(true); // Mis plus bas pour ne l'activer qu'apr√®s succ√®s
          // setScanMode(''); // Mis plus bas
          // setShowOperationTypeSelection(true); // Mis plus bas

          // --- MODIFI√â: Ne trouver que le premier site non visit√© avec ce nom ---
          let occurrenceIndex = null;
          if (tourneeProgressRef.current?.getSitesWithStatus) {
            const sitesList = tourneeProgressRef.current.getSitesWithStatus();
            console.log('[processScannedData] sitesList depuis tourneeProgressRef:', JSON.stringify(sitesList.map(s => ({ id: s.id, name: s.name, visited: s.visited, uniqueDisplayId: s.uniqueDisplayId }))));
            const siteNameToFind = siteVerification.site.nom || siteVerification.site.name;
            console.log('[processScannedData] Nom du site √† trouver:', siteNameToFind);

            // Trouver le premier site non visit√© avec ce nom
            occurrenceIndex = sitesList.findIndex(s => !s.visited && (s.name === siteNameToFind || s.nom === siteNameToFind)); // Ajout de s.nom
            console.log(`[processScannedData] Occurrence index trouv√©e pour ${siteNameToFind}:`, occurrenceIndex);
            
            // Si aucun site non visit√© n'est trouv√©, ne rien faire
            if (occurrenceIndex === -1) {
              Alert.alert(
                'Site d√©j√† visit√© ou non trouv√©', // Message mis √† jour
                'Ce site a d√©j√† √©t√© visit√©, ne fait pas partie de cette tourn√©e, ou son nom ne correspond pas exactement.', // Message mis √† jour
                [{ text: 'OK', onPress: () => {
                  // R√©initialiser l'√©tat pour permettre un nouveau scan
                  setSiteScanned(false);
                  setSiteDetails(null);
                  setSiteCode('');
                  setShowOperationTypeSelection(false);
                }}]
              );
              return;
            }
          } else {
            console.warn('[processScannedData] tourneeProgressRef.current.getSitesWithStatus non disponible.');
            Alert.alert('Erreur', 'Impossible de r√©cup√©rer la liste des sites de la tourn√©e.');
            return;
          }

          // Marquage en session via l'index si trouv√©, sinon par site.id
          const identifier = siteVerification.site.id || (siteVerification.site.code || data);
          console.log('[processScannedData] Identifier pour markSiteVisitedInSession:', identifier);
          console.log('[processScannedData] currentSessionId avant appel:', currentSessionId);
          console.log('[processScannedData] occurrenceIndex avant appel:', occurrenceIndex);

          if (!currentSessionId) {
            console.error('[processScannedData] ID de session manquant avant markSiteVisitedInSession');
            Alert.alert('Erreur Critique', 'ID de session manquant. Impossible de continuer.');
            return;
          }
          
          // Ne marquer qu'un seul site √† la fois, en utilisant l'index sp√©cifique
          if (occurrenceIndex !== -1 && occurrenceIndex !== null) { // Condition d√©j√† pr√©sente, mais on log avant
            const markSuccess = await firebaseService.markSiteVisitedInSession(currentSessionId, identifier, occurrenceIndex);
            console.log('[processScannedData] R√©sultat de markSiteVisitedInSession:', markSuccess);
            
            if (markSuccess) {
              setSiteScanned(true); // Activer seulement si le marquage Firestore a r√©ussi
              setScanMode(''); 
              setShowOperationTypeSelection(true);

              // Mise √† jour du UI local - mettre √† jour uniquement le site sp√©cifique
              if (tourneeProgressRef.current?.markSiteAsVisitedLocally) {
                console.log('[processScannedData] Appel de markSiteAsVisitedLocally avec:', identifier, occurrenceIndex);
                await tourneeProgressRef.current.markSiteAsVisitedLocally(identifier, occurrenceIndex); // AJOUT DE AWAIT
                // Temporairement comment√© pour tester si la coche se met √† jour correctement sans rechargement imm√©diat
                // await updateTourneeProgress(); 
              } else if (tourneeProgressRef.current?.loadTourneeDetails) {
                console.log('[processScannedData] Appel de loadTourneeDetails(true) car markSiteAsVisitedLocally non dispo.');
                await tourneeProgressRef.current.loadTourneeDetails(true);
              }
            } else {
              Alert.alert('Erreur', '√âchec du marquage du site comme visit√© dans la session Firestore.');
              // Garder siteScanned √† false, etc.
            }
            
            // Si updateTourneeProgress a √©t√© comment√©, on peut appeler loadHistoricalData ici
            // si c'est n√©cessaire pour d'autres parties de l'UI non li√©es √† TourneeProgress.
            // Pour l'instant, on isole le probl√®me de la coche.
            // await loadHistoricalData(); 

          } else {
             console.warn('[processScannedData] occurrenceIndex invalide, markSiteVisitedInSession non appel√©.');
             // Potentiellement une alerte ici si ce cas ne devrait pas arriver
          }
          return;
        } else { // siteVerification.site est null/undefined
          console.log('[processScannedData] Aucun site valide retourn√© par verifySiteCode pour le code:', data);
          Alert.alert('Site Inconnu', 'Le code scann√© ne correspond √† aucun site connu.');
           // R√©initialiser pour permettre un nouveau scan
          setSiteScanned(false);
          setSiteDetails(null);
          setSiteCode('');
          setShowOperationTypeSelection(false);
        }
      }
      
      // Cas 2: Site d√©j√† scann√©, nous scannons maintenant un contenant
      if (siteScanned && scanMode === 'contenant') {
        console.log('[processScannedData] Mode: Scan de contenant. Donn√©es:', data);
        handleContenantScan(data);
        // Rester en mode scan contenant pour permettre les scans multiples
        setScanMode('contenant');
      }
    } catch (error) {
      console.error('Erreur lors de la gestion du scan:', error);
      setErrorMessage('Erreur: ' + error.message); // Afficher l'erreur √† l'utilisateur
      setScanMode(''); // R√©initialiser le mode scan
      // Optionnel: r√©initialiser d'autres √©tats si n√©cessaire
      setSiteScanned(false);
      setSiteDetails(null);
      setSiteCode('');
      setShowOperationTypeSelection(false);
    }
  };

  // G√©rer la simulation d'un scan (pour le d√©veloppement et les tests)
  const handleSimulatedScan = () => {
    // V√©rifier si on est en mode sortie sans colis pris en charge
    if (scanMode === 'contenant' && operationType === 'sortie' && takingCarePackages.length === 0) {
      Alert.alert(
        "Aucun colis disponible",
        "Vous n'avez aucun colis en prise en charge √† d√©poser.",
        [{ text: "OK" }]
      );
      return;
    }
    
    const fakeData = simulateScan();
    if (fakeData) {
      console.log(`Simulation de scan avec donn√©es: ${fakeData}`);
    processScannedData(fakeData);
    } else {
      console.error("Erreur lors de la simulation du scan: aucune donn√©e g√©n√©r√©e");
      Alert.alert(
        "Erreur",
        "Impossible de simuler un scan. Veuillez r√©essayer.",
        [{ text: "OK" }]
      );
    }
  };

  const handleManualScan = () => {
    if (manualCodeInput.trim() === '') {
      Alert.alert('Erreur', 'Veuillez entrer un code valide');
      return;
    }
    
    processScannedData(manualCodeInput.trim());
    setManualCodeInput('');
  };

  const activateSiteScan = () => {
    setScanMode('site');
    setErrorMessage('');
    setIsReadyForScan(true);
    
    // Montrer une alerte avec plusieurs options pour scanner
    Alert.alert(
      "Scanner un site",
      "Comment souhaitez-vous scanner le site ?",
      [
        {
          text: "Scanner manuellement",
          onPress: () => showManualSiteInput()
        },
        {
          text: "Simuler scan",
          onPress: handleSimulatedScan
        },
        {
          text: "Annuler",
          style: "cancel",
          onPress: () => setScanMode('')
        }
      ]
    );
  };

  // Fonction pour afficher une bo√Æte de dialogue pour saisir manuellement le code du site
  const showManualSiteInput = () => {
    // Utiliser Alert.prompt sur iOS, mais sur Android, cette fonction n'existe pas
    // donc nous utilisons une m√©thode alternative
    if (Platform.OS === 'ios') {
      Alert.prompt(
        "Scanner site manuellement",
        "Entrez le code ou le nom du site",
        [
          { text: "Annuler", onPress: () => setScanMode(''), style: "cancel" },
          { 
            text: "Scanner", 
            onPress: (code) => {
              if (code && code.trim()) {
                processScannedData(code.trim());
              } else {
                setScanMode('');
                Alert.alert("Erreur", "Veuillez entrer un code de site valide");
              }
            }
          }
        ],
        "plain-text"
      );
    } else {
      // Sur Android, utiliser une solution simple avec TextInput
      Alert.alert(
        "Scanner site manuellement",
        "Entrez le code du site dans le champ de texte en haut de l'√©cran, puis appuyez sur Scanner",
        [
          { text: "OK" }
        ]
      );
      // Focus sur le champ de saisie manuelle
      // Note: ceci est une approche simplifi√©e, une solution plus robuste
      // utiliserait un modal personnalis√© avec TextInput
      setManualCodeInput('');
      // On garde le mode scan actif pour que le bouton scanner manuel fonctionne
    }
  };

  // Afficher la page de s√©lection du type d'op√©ration
  const showOperationSelection = () => {
    setShowOperationTypeSelection(true);
  };

  // Commencer le scan de contenant avec un type d'op√©ration sp√©cifique
  const startContenantScan = (type) => {
    setOperationType(type);
    setShowOperationTypeSelection(false);
    setScanMode('contenant');
    setErrorMessage('');
    setIsReadyForScan(true);
    
    // Message diff√©rent selon le type d'op√©ration
    const message = type === 'entree' 
      ? "Veuillez scanner le code du contenant √† prendre en charge" 
      : "Veuillez scanner le code du contenant √† d√©poser";
    
    Alert.alert(
      type === 'entree' ? "Prise en charge" : "D√©p√¥t",
      message,
      [{ text: "Annuler", onPress: () => setScanMode('') }]
    );
  };

  const handleContenantScan = async (code) => {
    if (!siteScanned) {
      Alert.alert('Erreur', 'Veuillez d\'abord scanner un site');
      return;
    }

    try {
      // Mode d√©p√¥t (sortie) - v√©rifier que le colis est dans la liste des colis pris en charge
      if (operationType === 'sortie') {
        const isInTakingCare = takingCarePackages.some(pkg => pkg.code === code);
        if (!isInTakingCare) {
          Alert.alert(
            "Colis non reconnu",
            "Ce colis ne fait pas partie des colis que vous avez en prise en charge.",
            [{ text: "OK" }]
          );
          return;
        }
        
        // Retirer le colis de la liste des colis pris en charge
        setTakingCarePackages(takingCarePackages.filter(pkg => pkg.code !== code));
      }

      // Obtenir la date actuelle au format appropri√©
      const currentDate = new Date();
      const currentDateISO = currentDate.toISOString();

      // Ajouter le contenant √† la liste
      const newContenant = {
        id: Date.now().toString(),
        code: code,
        idColis: code,
        timeStamp: currentDate.toLocaleTimeString(),
        date: currentDate.toLocaleDateString(),
        scanDate: currentDateISO,
        site: siteCode,
        type: operationType, // Ajout du type d'op√©ration (entr√©e/sortie)
      };
      
      setScannedContenants([newContenant, ...scannedContenants]);
    } catch (error) {
      console.error('Erreur lors de la gestion du scan:', error);
      setScanMode('');
    }
  };

  const renderScannedItem = ({ item }) => (
    <View style={[styles.contenantItem, item.type === 'sortie' ? styles.contenantItemSortie : styles.contenantItemEntree]}>
      <View style={styles.contenantInfo}>
        <Text style={styles.contenantCode}>{item.code}</Text>
        <View style={styles.contenantTypeRow}>
          <View style={item.type === 'sortie' ? styles.typeTagSortie : styles.typeTagEntree}>
            <Text style={styles.typeTagText}>{item.type === 'sortie' ? 'D√©p√¥t' : 'Prise en charge'}</Text>
          </View>
          <Text style={styles.contenantTime}>{item.timeStamp}</Text>
        </View>
      </View>
      <TouchableOpacity
        style={styles.deleteContenantButton}
        onPress={() => removeScannedContenant(item.id)}
      >
        <Ionicons name="trash-outline" size={20} color="#e74c3c" />
      </TouchableOpacity>
    </View>
  );

  const removeScannedContenant = (id) => {
    setScannedContenants(scannedContenants.filter(contenant => contenant.id !== id));
  };

  const handleTransmit = async () => {
    if (scannedContenants.length === 0) {
      Alert.alert('Attention', 'Aucun contenant scann√© √† transmettre.');
      return;
    }

    setLoading(true);

    try {
      // V√©rifier et afficher les donn√©es de la session pour le d√©bogage
      console.log('Donn√©es de session:', JSON.stringify(sessionData, null, 2));
      console.log('Donn√©es de route:', JSON.stringify(route.params, null, 2));
      
      // R√©cup√©rer les donn√©es de la tourn√©e et du v√©hicule avec plus de v√©rifications
      const tourneeName = sessionData.tournee?.nom || route.params?.tournee?.nom || '';
      const tourneeId = sessionData.tournee?.id || route.params?.tournee?.id || '';
      const vehiculeName = sessionData.vehicule?.immatriculation || route.params?.vehicule?.immatriculation || '';
      const vehiculeId = sessionData.vehicule?.id || route.params?.vehicule?.id || '';
      
      // Utiliser les d√©tails du site valid√© s'ils sont disponibles
      let siteName, siteId, siteAdresse, siteCodePostal, siteVille;
      
      if (siteDetails) {
        // Utiliser les bonnes cl√©s du siteDetails (nommage uniforme)
        siteName = siteDetails.name || siteCode;
        siteId = siteDetails.id || '';
        siteAdresse = siteDetails.address || '';
        siteCodePostal = siteDetails.codePostal || '';
        siteVille = siteDetails.city || '';
      } else {
        // Sinon on utilise ce qu'on a par d√©faut
        siteName = sessionData.tournee?.siteDepart || route.params?.tournee?.siteDepart || siteCode || 'Non sp√©cifi√©';
        siteId = '';
      }
      
      console.log('Donn√©es r√©cup√©r√©es pour les scans:', {
        tourneeName,
        tourneeId,
        vehiculeName,
        vehiculeId,
        siteName,
        siteId,
        siteCode
      });

      // R√©cup√©rer l'ID de session actuel
      const currentSessionId = await AsyncStorage.getItem('currentSessionId') || `session_${Date.now()}`;
      
      // Pr√©parer les scans avec tous les champs n√©cessaires
      const scansToSubmit = scannedContenants.map(scan => {
        const scanDate = scan.scanDate || new Date().toISOString();
        
        // Le code du contenant devient l'ID du colis
        const scanItem = {
          code: scan.code,
          idColis: scan.code || scan.idColis,
          scanDate: scanDate,
          tournee: tourneeName,
          tourneeId: tourneeId,
          vehicule: vehiculeName,
          vehiculeId: vehiculeId,
          immatriculation: vehiculeName,
          site: siteName,
          siteId: siteId,
          siteCode: siteCode,
          siteDepart: siteName,
          siteD√©part: siteName,
          sessionId: currentSessionId, // Ajouter l'ID de session pour le filtrage ult√©rieur
          operationType: scan.type || 'entree', // Ajout du type d'op√©ration
          status: scan.type === 'sortie' ? 'livr√©' : 'en-cours', // Status bas√© sur le type d'op√©ration
          type: scan.type || 'entree' // Assurer que le type est inclus explicitement
        };
        
        // Ajouter siteFin uniquement pour les colis livr√©s
        if (scan.type === 'sortie') {
          // Pour les op√©rations de sortie (d√©p√¥t), ajouter des informations sp√©cifiques
          const currentDate = new Date();
          
          // Utiliser le nom du site actuel comme site d'arriv√©e
          scanItem.siteFin = siteName;
          // Ajouter date et heure d'arriv√©e au format correct
          scanItem.dateArrivee = currentDate.toLocaleDateString();
          scanItem.heureArrivee = currentDate.toLocaleTimeString();
          // Ajouter ces champs suppl√©mentaires pour assurer la compatibilit√©
          scanItem.dateHeureFin = currentDate.toISOString();
          scanItem.statut = 'Livr√©';
          scanItem.status = 'livr√©'; // Assurez-vous que les deux formats sont pr√©sents
          scanItem.coursierLivraison = sessionData.coursierCharg || route.params?.coursierCharg || '';
        }
        
        // Ajouter les d√©tails du site s'ils sont disponibles
        if (siteDetails) {
          scanItem.siteDetails = {
            adresse: siteAdresse,
            codePostal: siteCodePostal,
            ville: siteVille
          };
        }

        // Ajouter la localisation si disponible
        if (sessionData.location) {
          scanItem.location = {
            latitude: sessionData.location.coords.latitude,
            longitude: sessionData.location.coords.longitude,
            accuracy: sessionData.location.coords.accuracy
          };
        }

        return scanItem;
      });
      
      // Afficher les donn√©es qui seront transmises
      console.log('Transmission des scans:', JSON.stringify(scansToSubmit, null, 2)); // D√©comment√© pour d√©bogage
      
      // Envoyer les scans √† Firebase
      const result = await firebaseService.addScans(scansToSubmit);
      console.log('R√©sultat de la transmission:', result);
      
      // Si la transmission r√©ussit, mettre √† jour l'historique local
      if (result.success) {
        // --- Logique de consolidation --- 
        const updatedScansMap = new Map();
        historicalScans.forEach(scan => {
          // Assurer qu'on a un code pour la cl√© de la map
          if (scan.code) {
            updatedScansMap.set(scan.code, scan);
          }
        });
        scansToSubmit.forEach(scan => {
          if (scan.code) {
            const originalScan = scannedContenants.find(s => s.code === scan.code);
            const scanForHistory = {
              ...scan,
              timeStamp: originalScan?.timeStamp || dateUtils.formatTime(scan.scanDate),
            };
            updatedScansMap.set(scan.code, scanForHistory);
          }
        });
        const newHistory = Array.from(updatedScansMap.values());
        newHistory.sort((a, b) => {
          const dateA = a.scanDate ? new Date(a.scanDate).getTime() : 0;
          const dateB = b.scanDate ? new Date(b.scanDate).getTime() : 0;
          if (isNaN(dateA) && isNaN(dateB)) return 0;
          if (isNaN(dateA)) return 1;
          if (isNaN(dateB)) return -1;
          return dateB - dateA;
        });
        // --- Fin de la logique de consolidation ---

        // Sauvegarder l'historique consolid√© dans AsyncStorage
        await AsyncStorage.setItem('scanHistory', JSON.stringify(newHistory));
        
        // Mise √† jour de l'√©tat React DIFF√âR√âE apr√®s les interactions
        InteractionManager.runAfterInteractions(() => {
          setHistoricalScans(newHistory);
        });
        
        // Mettre √† jour la liste des paquets pris en charge
        if (operationType === 'entree') {
          setTakingCarePackages([...scansToSubmit, ...takingCarePackages]);
        } else if (operationType === 'sortie') {
          const codesDeposited = scansToSubmit.map(scan => scan.code);
          setTakingCarePackages(takingCarePackages.filter(pkg => pkg.code && !codesDeposited.includes(pkg.code)));
        }
        
        // R√©initialiser compl√®tement l'√©tat pour revenir √† l'√©cran de scan de site
        resetScan(); // Cette fonction r√©initialise les √©tats de base

        // S'assurer que tous les √©tats sont correctement r√©initialis√©s pour revenir √† l'√©cran initial
        setShowOperationTypeSelection(false);
        setOperationType('entree'); // R√©initialiser √† l'entr√©e de colis par d√©faut
        
        // Important: D√©sactiver le chargement AVANT l'alerte
        setLoading(false);
        
        // Afficher l'alerte de succ√®s
        Alert.alert(
          'Succ√®s',
          `${scansToSubmit.length} scan(s) transmis avec succ√®s`,
          [{ text: 'OK' }]
        );
      } else {
        setLoading(false);
        throw new Error(result.error || '√âchec de la transmission');
      }
    } catch (error) {
      console.error('Erreur lors de la transmission:', error);
      setLoading(false);
      Alert.alert('Erreur', `√âchec de la transmission: ${error.message}`);
    }
  };

  const resetScan = () => {
    setScanMode('');
    setSiteScanned(false);
    setSiteCode('');
    setScannedContenants([]);
    setManualCodeInput('');
    setSiteDetails(null);
  };

  const navigateToHistory = () => {
    setShowHistoryModal(true);
  };

  // Fonction pour obtenir les d√©tails de la session actuelle
  const getSessionDetails = async () => {
    try {
      const currentSession = await firebaseService.getCurrentSession();
      if (currentSession) {
        setSessionId(currentSession.id);
        setTournee(currentSession.tournee);
        setVehicule(currentSession.vehicule);
        setPole(currentSession.pole);
      }
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration de la session:", error);
    }
  };

  // Fonction pour effacer l'historique des scans
  const clearHistoricalScans = async () => {
    try {
      Alert.alert(
        'Effacer l\'historique',
        'Voulez-vous vraiment effacer tout l\'historique des scans?',
        [
          {
            text: 'Annuler',
            style: 'cancel'
          },
          {
            text: 'Effacer',
            onPress: async () => {
              await AsyncStorage.removeItem('scanHistory');
              setHistoricalScans([]);
              Alert.alert('Succ√®s', 'Historique effac√© avec succ√®s');
            },
            style: 'destructive'
          }
        ]
      );
    } catch (error) {
      console.error('Erreur lors de l\'effacement de l\'historique:', error);
      Alert.alert('Erreur', 'Impossible d\'effacer l\'historique');
    }
  };

  // Ajout d'une fonction pour effacer explicitement tous les scans de la session actuelle
  const clearCurrentSessionScans = async () => {
    try {
      const currentSessionId = await AsyncStorage.getItem('currentSessionId');
      if (!currentSessionId) {
        Alert.alert('Erreur', 'Impossible de d√©terminer la session actuelle');
        return;
      }
      
      Alert.alert(
        'R√©initialiser l\'historique',
        'Cette action va supprimer tous les scans associ√©s √† votre session actuelle. Continuer?',
        [
          {
            text: 'Annuler',
            style: 'cancel'
          },
          {
            text: 'Supprimer',
            onPress: async () => {
              try {
                // Supprimer les scans associ√©s √† la session actuelle
                setLoading(true);
                console.log(`Suppression des scans de la session ${currentSessionId}...`);
                
                // Fonction c√¥t√© service qui devrait √™tre impl√©ment√©e
                // pour supprimer tous les scans de la session
                const result = await firebaseService.clearSessionScans(currentSessionId);
                
                // Supprimer l'historique local √©galement
                await AsyncStorage.removeItem('scanHistory');
                setHistoricalScans([]);
                
                setLoading(false);
                Alert.alert('Succ√®s', 'Historique r√©initialis√© avec succ√®s');
              } catch (error) {
                setLoading(false);
                console.error('Erreur lors de la suppression des scans:', error);
                Alert.alert('Erreur', `√âchec de la suppression: ${error.message}`);
              }
            },
            style: 'destructive'
          }
        ]
      );
    } catch (error) {
      console.error('Erreur:', error);
      Alert.alert('Erreur', 'Une erreur est survenue');
    }
  };

  // Handler de d√©connexion avec effacement complet de l'historique
  const handleLogout = async () => {
    try {
      Alert.alert(
        'D√©connexion',
        'Voulez-vous vous d√©connecter? L\'historique des scans sera effac√©.',
        [
          {
            text: 'Annuler',
            style: 'cancel'
          },
          {
            text: 'D√©connecter',
            onPress: async () => {
              try {
                setLoading(true);
                console.log('D√©connexion en cours...');

                // Appeler la m√©thode de d√©connexion de Firebase
                await firebaseService.logout();
                console.log('D√©connexion Firebase r√©ussie');
                
                // Effacer toutes les donn√©es de session
                await AsyncStorage.removeItem('userSessionActive');
                // On conserve current_session_id pour que la tourn√©e visit√©e reste en m√©moire
                await AsyncStorage.removeItem('scanHistory');
                await AsyncStorage.removeItem('user_selas_id');
                
                // R√©initialiser les √©tats
                setHistoricalScans([]);
                setScannedContenants([]);
                setSiteScanned(false);
                setSiteCode('');
                
                setLoading(false);
                
                // Rediriger vers l'√©cran de connexion
                navigation.reset({
                  index: 0,
                  routes: [{ name: 'Login' }]
                });
              } catch (error) {
                setLoading(false);
                console.error('Erreur lors du processus de d√©connexion:', error);
                Alert.alert('Erreur', 'Impossible de se d√©connecter. Veuillez r√©essayer.');
              }
            }
          }
        ]
      );
    } catch (error) {
      console.error('Erreur lors de la d√©connexion:', error);
    }
  };

  // Utiliser directement les fonctions de formatage de dateUtils
  // au lieu de red√©finir des fonctions similaires

  // Effet pour √©couter les √©v√©nements de scan Zebra
  useEffect(() => {
    if (isReadyForScan) {
      // Afficher un message pour indiquer que l'application est pr√™te pour le scan
      console.log('Pr√™t √† recevoir des scans du scanner Zebra');
      
      // Configuration pour recevoir les scans du mat√©riel Zebra
      const handleZebraScan = (event) => {
        // Le scanner Zebra envoie g√©n√©ralement les donn√©es comme des entr√©es clavier
        // Nous devons v√©rifier que nous sommes en mode scan et traiter les donn√©es
        if (event && event.nativeEvent && event.nativeEvent.key === 'Enter' && scanMode) {
          // R√©cup√©rer le texte scann√© (par exemple depuis un champ de texte cach√© ou via une API Zebra)
          // Pour les besoins de cet exemple, nous utiliserons la valeur de manualCodeInput
          if (manualCodeInput.trim()) {
            processScannedData(manualCodeInput.trim());
            setManualCodeInput(''); // R√©initialiser apr√®s le traitement
          }
        }
      };
      
      // Ajoutez ici l'initialisation sp√©cifique au scanner Zebra si n√©cessaire
      // Exemple : ZebraScanner.initialize() si une API Zebra est disponible
      
      // Pour cet exemple, on simule en utilisant l'√©couteur de clavier (pour Enter)
      Keyboard.addListener('keyDown', handleZebraScan);
      
      return () => {
        // Nettoyage lors du d√©montage
        Keyboard.removeListener('keyDown', handleZebraScan);
        // D√©sinitialiser le scanner Zebra si n√©cessaire
        // Exemple : ZebraScanner.deinitialize()
      };
    }
  }, [isReadyForScan, scanMode, manualCodeInput]);


  const loadHistoricalScans = async () => {
    try {
      const jsonValue = await AsyncStorage.getItem('scanHistory');
      if (jsonValue !== null) {
        const history = JSON.parse(jsonValue);
        
        // R√©cup√©rer l'ID de la tourn√©e actuelle
        const currentSession = await firebaseService.getCurrentSession();
        const currentTourneeId = currentSession?.tournee?.id || sessionData?.tournee?.id || '';
        
        // Filtrer l'historique local
        const today = new Date();
        today.setHours(0, 0, 0, 0); // D√©but de la journ√©e
        
        const filteredHistory = history.filter(item => {
          // Convertir la date de l'item en objet Date
          let itemDate;
          try {
            itemDate = new Date(item.date);
            if (isNaN(itemDate.getTime())) {
              // Si la date n'est pas valide, essayer un autre format
              const parts = item.date.split('/');
              if (parts.length === 3) {
                itemDate = new Date(parts[2], parts[1] - 1, parts[0]);
              }
            }
          } catch (e) {
            // En cas d'erreur, consid√©rer cet item comme non valide pour le filtre
            return false;
          }

          // S'assurer que nous avons une date valide
          if (!itemDate || isNaN(itemDate.getTime())) return false;
          
          itemDate.setHours(0, 0, 0, 0); // Normaliser √† minuit
          
          // V√©rifier la tourn√©e
          const isSameTournee = !currentTourneeId || item.tourneeId === currentTourneeId;
          
          // V√©rifier le statut (inclut les visites sans colis)
          const hasValidStatus = item.status === 'en-cours' || item.status === 'livr√©';
          
          // L'item doit √™tre du jour courant ET de la m√™me tourn√©e ET avoir un statut valide
          return itemDate.getTime() === today.getTime() && isSameTournee && hasValidStatus;
        });
        
        console.log(`Historique local filtr√©: ${filteredHistory.length} scans (jour + tourn√©e + statut)`);
        
        // Consolider l'historique filtr√© avant de mettre √† jour l'√©tat
        const consolidatedHistory = consolidateAndSortScans([], filteredHistory);

        // Enrichir avec le nom complet du site depuis Firestore
        const enrichedHistory = await Promise.all(
          consolidatedHistory.map(async (scan) => {
            // Tenter de r√©cup√©rer les d√©tails du site en utilisant siteId ou code
            try {
              const siteIdentifier = scan.siteId || scan.code; // Utiliser ID ou code
              // V√©rifier si l'identifiant est probablement un site avant d'appeler getSiteById
              if (siteIdentifier && 
                  !siteIdentifier.startsWith('TEST_CONTENANT_') && 
                  !siteIdentifier.match(/^[0-9]{13,}$/)) { 
                const siteInfo = await firebaseService.getSiteById(siteIdentifier);
                if (siteInfo) {
                  // Enrichir le scan avec les d√©tails complets
                  return { 
                    ...scan, 
                    siteName: siteInfo.nom || siteInfo.name, // Ajouter le nom pour affichage facile
                    siteDetails: { ...siteInfo } 
                  };
                }
              }
            } catch (e) {
              console.warn(`[loadHistoricalScans] Erreur r√©cup√©ration d√©tails site pour ${scan.code || scan.id}:`, e);
            }
            // Si non trouv√© ou erreur, retourner le scan original
            return scan;
          })
        );
        
        // Mettre √† jour l'√©tat avec l'historique enrichi
        setHistoricalScans(enrichedHistory);
        setSessionHistoryLoaded(true);
      }
    } catch (error) {
      console.error('Erreur lors du chargement de l\'historique:', error);
    }
  };

  const loadFirestoreScans = async () => {
    try {
      // On ne charge les scans Firestore que si la session est active
      const userSessionActive = await AsyncStorage.getItem('userSessionActive');
      if (userSessionActive !== 'true') {
        // Si aucune session active, on ne charge pas l'historique Firestore
        return;
      }

      // R√©cup√©rer l'ID de session actuel
      const currentSessionId = await AsyncStorage.getItem('currentSessionId');
      console.log('Chargement des scans pour la session:', currentSessionId);

      // R√©cup√©rer l'ID de la tourn√©e actuelle
      const currentSession = await firebaseService.getCurrentSession();
      const currentTourneeId = currentSession?.tournee?.id || sessionData?.tournee?.id || '';
      console.log('Tourn√©e actuelle:', currentTourneeId);

      setLoading(true); // Afficher l'indicateur de chargement

      // R√©cup√©rer tous les scans de l'utilisateur (sans limite)
      const scans = await firebaseService.getScans();
      
      if (scans && scans.length > 0) {
        // Ne garder que les scans du jour (J0)
        const today = new Date();
        today.setHours(0, 0, 0, 0); // D√©but de la journ√©e
        
        const filteredScans = scans.filter(scan => {
          // Convertir la date du scan en objet Date
          const scanDate = dateUtils.convertTimestampToDate(scan.scanDate || scan.createdAt);
          if (!scanDate) return false;
          
          // R√©cup√©rer juste la date (sans l'heure)
          const scanDateOnly = new Date(scanDate);
          scanDateOnly.setHours(0, 0, 0, 0);
          
          // V√©rifier la tourn√©e (si une tourn√©e actuelle est d√©finie)
          const isSameTournee = !currentTourneeId || scan.tourneeId === currentTourneeId;
          
          // V√©rifier le statut (inclut "pas_de_colis")
          const hasValidStatus = scan.status === 'en-cours' || scan.status === 'livr√©';
          
          // Le scan doit √™tre du jour courant ET de la m√™me tourn√©e ET avoir un statut valide
          return scanDateOnly.getTime() === today.getTime() && isSameTournee && hasValidStatus;
        });
        
        // Convertir les scans Firestore filtr√©s en format compatible avec l'historique local
        const formattedScans = filteredScans.map(scan => {
          // D√©duire le statut si manquant, bas√© sur le type d'op√©ration
          let status = scan.status;
          if (!status) {
            status = scan.operationType === 'sortie' ? 'livr√©' : 'en-cours';
          }
          
          return {
            id: scan.id || Date.now().toString(),
            code: scan.code,
            timeStamp: dateUtils.formatTime(scan.scanDate || scan.createdAt),
            date: dateUtils.formatDate(scan.scanDate || scan.createdAt),
            site: scan.site,
            fromFirestore: true,
            sessionId: scan.sessionId,
            // Utiliser le statut (corrig√© si n√©cessaire)
            status: status, 
            // S'assurer que le type est aussi pr√©sent
            type: scan.operationType || (status === 'livr√©' ? 'sortie' : 'entree'), 
            tournee: scan.tournee || '',
            tourneeId: scan.tourneeId || '',
            scanDate: scan.scanDate ? dateUtils.convertTimestampToDate(scan.scanDate).toISOString() : (scan.createdAt ? dateUtils.convertTimestampToDate(scan.createdAt).toISOString() : new Date().toISOString()) // Garder une date ISO pour le tri
          };
        });
        
        // Consolider et trier
        const consolidatedScans = consolidateAndSortScans(historicalScans, formattedScans);
        // Enrichir avec le nom complet du site depuis Firestore
        const enrichedScans = await Promise.all(
          consolidatedScans.map(async (scan) => {
            try {
              // Tenter de r√©cup√©rer les d√©tails du site
              try {
                // Utiliser l'ID du site si disponible, sinon le code barre
                const siteIdentifier = scan.siteId || scan.code; // Assumer que siteId existe
                if (siteIdentifier && 
                    !siteIdentifier.startsWith('TEST_CONTENANT_') && 
                    !siteIdentifier.match(/^[0-9]{13,}$/)) {
                  // Utiliser une variable locale au lieu de r√©assigner l'√©tat siteDetails
                  const siteInfo = await firebaseService.getSiteById(siteIdentifier); 
                  if (siteInfo) {
                    // Modifier l'objet scan directement
                    scan.siteName = siteInfo.nom || siteInfo.name; // Utiliser le nom du site s'il est trouv√©
                    scan.siteDetails = siteInfo; // Ajouter les d√©tails au scan
                  } else {
                     // Si siteInfo est null, indiquer le nom comme code
                     scan.siteName = scan.code; 
                  }
                } else {
                   scan.siteName = scan.code; // Fallback si aucun identifiant
                }
              } catch (siteError) {
                console.warn(`[loadFirestoreScans] Impossible de r√©cup√©rer les d√©tails du site pour l'identifiant ${scan.siteId || scan.code}:`, siteError);
                scan.siteName = scan.code; // Afficher le code si erreur
              }
              
              // Ne r√©cup√©rer les informations sur le site que s'il ne s'agit pas d'un conteneur
              if (scan.site && 
                  !scan.site.startsWith('TEST_CONTENANT_') && 
                  !scan.site.match(/^[0-9]{13,}$/)) {
                const siteInfo = await firebaseService.getSiteById(scan.site);
                if (siteInfo) return { ...scan, siteDetails: { ...siteInfo } };
              }
            } catch (e) {
              console.error('Erreur r√©cup√©ration nom site Firestore:', e);
            }
            return scan;
          })
        );
        
        // Mettre √† jour l'√©tat avec l'historique enrichi
        setHistoricalScans(enrichedScans);
        setSessionHistoryLoaded(true);
        
        // Sauvegarder √©galement dans AsyncStorage pour la persistance locale temporaire
        await AsyncStorage.setItem('scanHistory', JSON.stringify(enrichedScans));
      }
      
      setLoading(false); // Masquer l'indicateur de chargement
    } catch (error) {
      console.error('Erreur lors du chargement des scans depuis Firestore:', error);
      setLoading(false); // Masquer l'indicateur de chargement en cas d'erreur
    }
  };

  // --- AJOUTER CETTE FONCTION D'AIDE --- 
  // Fonction pour consolider et trier les scans
  const consolidateAndSortScans = (existingScans, newScans) => {
    const map = new Map();

    // Ajouter les scans existants √† la map
    existingScans.forEach(scan => {
      if (scan.code) map.set(scan.code, scan);
    });

    // Mettre √† jour ou ajouter les nouveaux scans
    newScans.forEach(scan => {
      if (scan.code) map.set(scan.code, scan);
    });

    // Convertir la map en tableau
    const consolidated = Array.from(map.values());

    // Trier
    consolidated.sort((a, b) => {
      const dateA = a.scanDate ? new Date(a.scanDate).getTime() : 0;
      const dateB = b.scanDate ? new Date(b.scanDate).getTime() : 0;
      if (isNaN(dateA) && isNaN(dateB)) return 0;
      if (isNaN(dateA)) return 1;
      if (isNaN(dateB)) return -1;
      return dateB - dateA;
    });

    return consolidated;
  };
  // --- FIN DE L'AJOUT ---

  const loadTakingCarePackages = async () => {
    try {
      const scansEnCours = await firebaseService.getScansEnCours();
      // Filtrer pour exclure les scans "pas_de_colis"
      const filteredScans = scansEnCours.filter(scan => 
        scan.status !== 'pas_de_colis' &&
        !(scan.code && scan.code.startsWith('SITE_'))
      );
      console.log(`‚úÖ ${filteredScans.length} paquet(s) pris en charge r√©cup√©r√©(s) (sans les "pas_de_colis")`);
      setTakingCarePackages(filteredScans);
    } catch (error) {
      console.error('‚ùå Erreur lors du chargement des paquets pris en charge:', error);
    }
  };

  // üîπ Simulation d'un scan avec des sites valides
  const simulateScan = () => {
    if (scanMode === 'site') {
      // Sites de test qui seront reconnus comme valides
      const sitesDemoValides = [
        'SITE123',
        'SITE456',
        'SITE789',
        'LAB001',
        '12345'
      ];
      
      // S√©lectionner un site al√©atoire parmi les sites valides pour la d√©mo
      return sitesDemoValides[Math.floor(Math.random() * sitesDemoValides.length)];
    } else {
      // Si on est en mode sortie (d√©p√¥t), on doit scanner un colis d√©j√† pris en charge
      if (operationType === 'sortie') {
        // V√©rifier si des colis sont disponibles
        if (takingCarePackages.length > 0) {
          // S√©lectionner un colis al√©atoire parmi les colis pris en charge
          const randomPackage = takingCarePackages[Math.floor(Math.random() * takingCarePackages.length)];
          return randomPackage.code;
        } else {
          // Aucun colis disponible pour le d√©p√¥t - cette condition est g√©r√©e dans handleSimulatedScan
          return '';
        }
      } else {
        // Simuler un scan de contenant pour prise en charge
        // Utiliser un pr√©fixe sp√©cifique pour les tests afin de pouvoir les identifier facilement
        const testId = Date.now(); // Utiliser le timestamp actuel pour cr√©er un ID unique
        return `TEST_CONTENANT_${testId}`;
      }
    }
  };

  // Modification pour les tests : fonction mock qui simule verifySiteCode
  const mockVerifySiteCode = async (siteCode) => {
    // Sites de test qui seront automatiquement valid√©s
    const sitesDemoValides = {
      'SITE123': { nom: 'Site Test 1', adresse: '123 Rue Principale', ville: 'Paris', codePostal: '75001' },
      'SITE456': { nom: 'Site Test 2', adresse: '456 Avenue R√©publique', ville: 'Lyon', codePostal: '69001' },
      'SITE789': { nom: 'Site Test 3', adresse: '789 Boulevard des Tests', ville: 'Toulouse', codePostal: '31000' },
      '12345': { nom: 'Laboratoire Central', adresse: '12 Rue des Sciences', ville: 'Montpellier', codePostal: '34000' },
      'LAB001': { nom: 'Laboratoire Mobile', adresse: 'Zone Industrielle', ville: 'Bordeaux', codePostal: '33000' }
    };

    // V√©rifier si le code scann√© est dans notre liste de sites de test
    if (sitesDemoValides[siteCode]) {
      // Retourner une structure simulant la r√©ponse de Firebase
      return {
        valid: true,
        site: {
          id: `mock_${siteCode}`,
          code: siteCode,
          nom: sitesDemoValides[siteCode].nom,
          adresse: sitesDemoValides[siteCode].adresse,
          ville: sitesDemoValides[siteCode].ville,
          codePostal: sitesDemoValides[siteCode].codePostal
        }
      };
    }

    // Si ce n'est pas un site de test, passer √† la v√©rification normale dans Firebase
    return await firebaseService.verifySiteCode(siteCode);
  };

  const processScannedData = async (data) => {
    console.log('Code scann√©:', data);
    try {
      // Cas 1: Nous n'avons pas encore scann√© de site
      if (!siteScanned && scanMode === 'site') {
        console.log('[processScannedData] Mode: Scan de site. Donn√©es:', data);
        const siteVerification = await firebaseService.verifySiteCode(data);
        console.log('[processScannedData] R√©sultat de verifySiteCode:', JSON.stringify(siteVerification));

        if (siteVerification.site) {
          // Enregistrer les infos du site
          setSiteCode(data);
          setSiteDetails(siteVerification.site);
          // setSiteScanned(true); // Mis plus bas pour ne l'activer qu'apr√®s succ√®s
          // setScanMode(''); // Mis plus bas
          // setShowOperationTypeSelection(true); // Mis plus bas

          // --- MODIFI√â: Ne trouver que le premier site non visit√© avec ce nom ---
          let occurrenceIndex = null;
          if (tourneeProgressRef.current?.getSitesWithStatus) {
            const sitesList = tourneeProgressRef.current.getSitesWithStatus();
            console.log('[processScannedData] sitesList depuis tourneeProgressRef:', JSON.stringify(sitesList.map(s => ({ id: s.id, name: s.name, visited: s.visited, uniqueDisplayId: s.uniqueDisplayId }))));
            const siteNameToFind = siteVerification.site.nom || siteVerification.site.name;
            console.log('[processScannedData] Nom du site √† trouver:', siteNameToFind);

            // Trouver le premier site non visit√© avec ce nom
            occurrenceIndex = sitesList.findIndex(s => !s.visited && (s.name === siteNameToFind || s.nom === siteNameToFind)); // Ajout de s.nom
            console.log(`[processScannedData] Occurrence index trouv√©e pour ${siteNameToFind}:`, occurrenceIndex);
            
            // Si aucun site non visit√© n'est trouv√©, ne rien faire
            if (occurrenceIndex === -1) {
              Alert.alert(
                'Site d√©j√† visit√© ou non trouv√©', // Message mis √† jour
                'Ce site a d√©j√† √©t√© visit√©, ne fait pas partie de cette tourn√©e, ou son nom ne correspond pas exactement.', // Message mis √† jour
                [{ text: 'OK', onPress: () => {
                  // R√©initialiser l'√©tat pour permettre un nouveau scan
                  setSiteScanned(false);
                  setSiteDetails(null);
                  setSiteCode('');
                  setShowOperationTypeSelection(false);
                }}]
              );
              return;
            }
          } else {
            console.warn('[processScannedData] tourneeProgressRef.current.getSitesWithStatus non disponible.');
            Alert.alert('Erreur', 'Impossible de r√©cup√©rer la liste des sites de la tourn√©e.');
            return;
          }

          // Marquage en session via l'index si trouv√©, sinon par site.id
          const identifier = siteVerification.site.id || (siteVerification.site.code || data);
          console.log('[processScannedData] Identifier pour markSiteVisitedInSession:', identifier);
          console.log('[processScannedData] currentSessionId avant appel:', currentSessionId);
          console.log('[processScannedData] occurrenceIndex avant appel:', occurrenceIndex);

          if (!currentSessionId) {
            console.error('[processScannedData] ID de session manquant avant markSiteVisitedInSession');
            Alert.alert('Erreur Critique', 'ID de session manquant. Impossible de continuer.');
            return;
          }
          
          // Ne marquer qu'un seul site √† la fois, en utilisant l'index sp√©cifique
          if (occurrenceIndex !== -1 && occurrenceIndex !== null) { // Condition d√©j√† pr√©sente, mais on log avant
            const markSuccess = await firebaseService.markSiteVisitedInSession(currentSessionId, identifier, occurrenceIndex);
            console.log('[processScannedData] R√©sultat de markSiteVisitedInSession:', markSuccess);
            
            if (markSuccess) {
              setSiteScanned(true); // Activer seulement si le marquage Firestore a r√©ussi
              setScanMode(''); 
              setShowOperationTypeSelection(true);

              // Mise √† jour du UI local - mettre √† jour uniquement le site sp√©cifique
              if (tourneeProgressRef.current?.markSiteAsVisitedLocally) {
                console.log('[processScannedData] Appel de markSiteAsVisitedLocally avec:', identifier, occurrenceIndex);
                await tourneeProgressRef.current.markSiteAsVisitedLocally(identifier, occurrenceIndex); // AJOUT DE AWAIT
                // Temporairement comment√© pour tester si la coche se met √† jour correctement sans rechargement imm√©diat
                // await updateTourneeProgress(); 
              } else if (tourneeProgressRef.current?.loadTourneeDetails) {
                console.log('[processScannedData] Appel de loadTourneeDetails(true) car markSiteAsVisitedLocally non dispo.');
                await tourneeProgressRef.current.loadTourneeDetails(true);
              }
            } else {
              Alert.alert('Erreur', '√âchec du marquage du site comme visit√© dans la session Firestore.');
              // Garder siteScanned √† false, etc.
            }
            
            // Si updateTourneeProgress a √©t√© comment√©, on peut appeler loadHistoricalData ici
            // si c'est n√©cessaire pour d'autres parties de l'UI non li√©es √† TourneeProgress.
            // Pour l'instant, on isole le probl√®me de la coche.
            // await loadHistoricalData(); 

          } else {
             console.warn('[processScannedData] occurrenceIndex invalide, markSiteVisitedInSession non appel√©.');
             // Potentiellement une alerte ici si ce cas ne devrait pas arriver
          }
          return;
        } else { // siteVerification.site est null/undefined
          console.log('[processScannedData] Aucun site valide retourn√© par verifySiteCode pour le code:', data);
          Alert.alert('Site Inconnu', 'Le code scann√© ne correspond √† aucun site connu.');
           // R√©initialiser pour permettre un nouveau scan
          setSiteScanned(false);
          setSiteDetails(null);
          setSiteCode('');
          setShowOperationTypeSelection(false);
        }
      }
      
      // Cas 2: Site d√©j√† scann√©, nous scannons maintenant un contenant
      if (siteScanned && scanMode === 'contenant') {
        console.log('[processScannedData] Mode: Scan de contenant. Donn√©es:', data);
        handleContenantScan(data);
        // Rester en mode scan contenant pour permettre les scans multiples
        setScanMode('contenant');
      }
    } catch (error) {
      console.error('Erreur lors de la gestion du scan:', error);
      setErrorMessage('Erreur: ' + error.message); // Afficher l'erreur √† l'utilisateur
      setScanMode(''); // R√©initialiser le mode scan
      // Optionnel: r√©initialiser d'autres √©tats si n√©cessaire
      setSiteScanned(false);
      setSiteDetails(null);
      setSiteCode('');
      setShowOperationTypeSelection(false);
    }
  };

  // G√©rer la simulation d'un scan (pour le d√©veloppement et les tests)
  const handleSimulatedScan = () => {
    // V√©rifier si on est en mode sortie sans colis pris en charge
    if (scanMode === 'contenant' && operationType === 'sortie' && takingCarePackages.length === 0) {
      Alert.alert(
        "Aucun colis disponible",
        "Vous n'avez aucun colis en prise en charge √† d√©poser.",
        [{ text: "OK" }]
      );
      return;
    }
    
    const fakeData = simulateScan();
    if (fakeData) {
      console.log(`Simulation de scan avec donn√©es: ${fakeData}`);
    processScannedData(fakeData);
    } else {
      console.error("Erreur lors de la simulation du scan: aucune donn√©e g√©n√©r√©e");
      Alert.alert(
        "Erreur",
        "Impossible de simuler un scan. Veuillez r√©essayer.",
        [{ text: "OK" }]
      );
    }
  };

  const handleManualScan = () => {
    if (manualCodeInput.trim() === '') {
      Alert.alert('Erreur', 'Veuillez entrer un code valide');
      return;
    }
    
    processScannedData(manualCodeInput.trim());
    setManualCodeInput('');
  };

  const activateSiteScan = () => {
    setScanMode('site');
    setErrorMessage('');
    setIsReadyForScan(true);
    
    // Montrer une alerte avec plusieurs options pour scanner
    Alert.alert(
      "Scanner un site",
      "Comment souhaitez-vous scanner le site ?",
      [
        {
          text: "Scanner manuellement",
          onPress: () => showManualSiteInput()
        },
        {
          text: "Simuler scan",
          onPress: handleSimulatedScan
        },
        {
          text: "Annuler",
          style: "cancel",
          onPress: () => setScanMode('')
        }
      ]
    );
  };

  // Fonction pour afficher une bo√Æte de dialogue pour saisir manuellement le code du site
  const showManualSiteInput = () => {
    // Utiliser Alert.prompt sur iOS, mais sur Android, cette fonction n'existe pas
    // donc nous utilisons une m√©thode alternative
    if (Platform.OS === 'ios') {
      Alert.prompt(
        "Scanner site manuellement",
        "Entrez le code ou le nom du site",
        [
          { text: "Annuler", onPress: () => setScanMode(''), style: "cancel" },
          { 
            text: "Scanner", 
            onPress: (code) => {
              if (code && code.trim()) {
                processScannedData(code.trim());
              } else {
                setScanMode('');
                Alert.alert("Erreur", "Veuillez entrer un code de site valide");
              }
            }
          }
        ],
        "plain-text"
      );
    } else {
      // Sur Android, utiliser une solution simple avec TextInput
      Alert.alert(
        "Scanner site manuellement",
        "Entrez le code du site dans le champ de texte en haut de l'√©cran, puis appuyez sur Scanner",
        [
          { text: "OK" }
        ]
      );
      // Focus sur le champ de saisie manuelle
      // Note: ceci est une approche simplifi√©e, une solution plus robuste
      // utiliserait un modal personnalis√© avec TextInput
      setManualCodeInput('');
      // On garde le mode scan actif pour que le bouton scanner manuel fonctionne
    }
  };

  // Afficher la page de s√©lection du type d'op√©ration
  const showOperationSelection = () => {
    setShowOperationTypeSelection(true);
  };

  // Commencer le scan de contenant avec un type d'op√©ration sp√©cifique
  const startContenantScan = (type) => {
    setOperationType(type);
    setShowOperationTypeSelection(false);
    setScanMode('contenant');
    setErrorMessage('');
    setIsReadyForScan(true);
    
    // Message diff√©rent selon le type d'op√©ration
    const message = type === 'entree' 
      ? "Veuillez scanner le code du contenant √† prendre en charge" 
      : "Veuillez scanner le code du contenant √† d√©poser";
    
    Alert.alert(
      type === 'entree' ? "Prise en charge" : "D√©p√¥t",
      message,
      [{ text: "Annuler", onPress: () => setScanMode('') }]
    );
  };

  const handleContenantScan = async (code) => {
    if (!siteScanned) {
      Alert.alert('Erreur', 'Veuillez d\'abord scanner un site');
      return;
    }

    try {
      // Mode d√©p√¥t (sortie) - v√©rifier que le colis est dans la liste des colis pris en charge
      if (operationType === 'sortie') {
        const isInTakingCare = takingCarePackages.some(pkg => pkg.code === code);
        if (!isInTakingCare) {
          Alert.alert(
            "Colis non reconnu",
            "Ce colis ne fait pas partie des colis que vous avez en prise en charge.",
            [{ text: "OK" }]
          );
          return;
        }
        
        // Retirer le colis de la liste des colis pris en charge
        setTakingCarePackages(takingCarePackages.filter(pkg => pkg.code !== code));
      }

      // Obtenir la date actuelle au format appropri√©
      const currentDate = new Date();
      const currentDateISO = currentDate.toISOString();

      // Ajouter le contenant √† la liste
      const newContenant = {
        id: Date.now().toString(),
        code: code,
        idColis: code,
        timeStamp: currentDate.toLocaleTimeString(),
        date: currentDate.toLocaleDateString(),
        scanDate: currentDateISO,
        site: siteCode,
        type: operationType, // Ajout du type d'op√©ration (entr√©e/sortie)
      };
      
      setScannedContenants([newContenant, ...scannedContenants]);
    } catch (error) {
      console.error('Erreur lors de la gestion du scan:', error);
      setScanMode('');
    }
  };

  const renderScannedItem = ({ item }) => (
    <View style={[styles.contenantItem, item.type === 'sortie' ? styles.contenantItemSortie : styles.contenantItemEntree]}>
      <View style={styles.contenantInfo}>
        <Text style={styles.contenantCode}>{item.code}</Text>
        <View style={styles.contenantTypeRow}>
          <View style={item.type === 'sortie' ? styles.typeTagSortie : styles.typeTagEntree}>
            <Text style={styles.typeTagText}>{item.type === 'sortie' ? 'D√©p√¥t' : 'Prise en charge'}</Text>
          </View>
          <Text style={styles.contenantTime}>{item.timeStamp}</Text>
        </View>
      </View>
      <TouchableOpacity
        style={styles.deleteContenantButton}
        onPress={() => removeScannedContenant(item.id)}
      >
        <Ionicons name="trash-outline" size={20} color="#e74c3c" />
      </TouchableOpacity>
    </View>
  );

  const removeScannedContenant = (id) => {
    setScannedContenants(scannedContenants.filter(contenant => contenant.id !== id));
  };

  const handleTransmit = async () => {
    if (scannedContenants.length === 0) {
      Alert.alert('Attention', 'Aucun contenant scann√© √† transmettre.');
      return;
    }

    setLoading(true);

    try {
      // V√©rifier et afficher les donn√©es de la session pour le d√©bogage
      console.log('Donn√©es de session:', JSON.stringify(sessionData, null, 2));
      console.log('Donn√©es de route:', JSON.stringify(route.params, null, 2));
      
      // R√©cup√©rer les donn√©es de la tourn√©e et du v√©hicule avec plus de v√©rifications
      const tourneeName = sessionData.tournee?.nom || route.params?.tournee?.nom || '';
      const tourneeId = sessionData.tournee?.id || route.params?.tournee?.id || '';
      const vehiculeName = sessionData.vehicule?.immatriculation || route.params?.vehicule?.immatriculation || '';
      const vehiculeId = sessionData.vehicule?.id || route.params?.vehicule?.id || '';
      
      // Utiliser les d√©tails du site valid√© s'ils sont disponibles
      let siteName, siteId, siteAdresse, siteCodePostal, siteVille;
      
      if (siteDetails) {
        // Utiliser les bonnes cl√©s du siteDetails (nommage uniforme)
        siteName = siteDetails.name || siteCode;
        siteId = siteDetails.id || '';
        siteAdresse = siteDetails.address || '';
        siteCodePostal = siteDetails.codePostal || '';
        siteVille = siteDetails.city || '';
      } else {
        // Sinon on utilise ce qu'on a par d√©faut
        siteName = sessionData.tournee?.siteDepart || route.params?.tournee?.siteDepart || siteCode || 'Non sp√©cifi√©';
        siteId = '';
      }
      
      console.log('Donn√©es r√©cup√©r√©es pour les scans:', {
        tourneeName,
        tourneeId,
        vehiculeName,
        vehiculeId,
        siteName,
        siteId,
        siteCode
      });

      // R√©cup√©rer l'ID de session actuel
      const currentSessionId = await AsyncStorage.getItem('currentSessionId') || `session_${Date.now()}`;
      
      // Pr√©parer les scans avec tous les champs n√©cessaires
      const scansToSubmit = scannedContenants.map(scan => {
        const scanDate = scan.scanDate || new Date().toISOString();
        
        // Le code du contenant devient l'ID du colis
        const scanItem = {
          code: scan.code,
          idColis: scan.code || scan.idColis,
          scanDate: scanDate,
          tournee: tourneeName,
          tourneeId: tourneeId,
          vehicule: vehiculeName,
          vehiculeId: vehiculeId,
          immatriculation: vehiculeName,
          site: siteName,
          siteId: siteId,
          siteCode: siteCode,
          siteDepart: siteName,
          siteD√©part: siteName,
          sessionId: currentSessionId, // Ajouter l'ID de session pour le filtrage ult√©rieur
          operationType: scan.type || 'entree', // Ajout du type d'op√©ration
          status: scan.type === 'sortie' ? 'livr√©' : 'en-cours', // Status bas√© sur le type d'op√©ration
          type: scan.type || 'entree' // Assurer que le type est inclus explicitement
        };
        
        // Ajouter siteFin uniquement pour les colis livr√©s
        if (scan.type === 'sortie') {
          // Pour les op√©rations de sortie (d√©p√¥t), ajouter des informations sp√©cifiques
          const currentDate = new Date();
          
          // Utiliser le nom du site actuel comme site d'arriv√©e
          scanItem.siteFin = siteName;
          // Ajouter date et heure d'arriv√©e au format correct
          scanItem.dateArrivee = currentDate.toLocaleDateString();
          scanItem.heureArrivee = currentDate.toLocaleTimeString();
          // Ajouter ces champs suppl√©mentaires pour assurer la compatibilit√©
          scanItem.dateHeureFin = currentDate.toISOString();
          scanItem.statut = 'Livr√©';
          scanItem.status = 'livr√©'; // Assurez-vous que les deux formats sont pr√©sents
          scanItem.coursierLivraison = sessionData.coursierCharg || route.params?.coursierCharg || '';
        }
        
        // Ajouter les d√©tails du site s'ils sont disponibles
        if (siteDetails) {
          scanItem.siteDetails = {
            adresse: siteAdresse,
            codePostal: siteCodePostal,
            ville: siteVille
          };
        }

        // Ajouter la localisation si disponible
        if (sessionData.location) {
          scanItem.location = {
            latitude: sessionData.location.coords.latitude,
            longitude: sessionData.location.coords.longitude,
            accuracy: sessionData.location.coords.accuracy
          };
        }

        return scanItem;
      });
      
      // Afficher les donn√©es qui seront transmises
      console.log('Transmission des scans:', JSON.stringify(scansToSubmit, null, 2)); // D√©comment√© pour d√©bogage
      
      // Envoyer les scans √† Firebase
      const result = await firebaseService.addScans(scansToSubmit);
      console.log('R√©sultat de la transmission:', result);
      
      // Si la transmission r√©ussit, mettre √† jour l'historique local
      if (result.success) {
        // --- Logique de consolidation --- 
        const updatedScansMap = new Map();
        historicalScans.forEach(scan => {
          // Assurer qu'on a un code pour la cl√© de la map
          if (scan.code) {
            updatedScansMap.set(scan.code, scan);
          }
        });
        scansToSubmit.forEach(scan => {
          if (scan.code) {
            const originalScan = scannedContenants.find(s => s.code === scan.code);
            const scanForHistory = {
              ...scan,
              timeStamp: originalScan?.timeStamp || dateUtils.formatTime(scan.scanDate),
            };
            updatedScansMap.set(scan.code, scanForHistory);
          }
        });
        const newHistory = Array.from(updatedScansMap.values());
        newHistory.sort((a, b) => {
          const dateA = a.scanDate ? new Date(a.scanDate).getTime() : 0;
          const dateB = b.scanDate ? new Date(b.scanDate).getTime() : 0;
          if (isNaN(dateA) && isNaN(dateB)) return 0;
          if (isNaN(dateA)) return 1;
          if (isNaN(dateB)) return -1;
          return dateB - dateA;
        });
        // --- Fin de la logique de consolidation ---

        // Sauvegarder l'historique consolid√© dans AsyncStorage
        await AsyncStorage.setItem('scanHistory', JSON.stringify(newHistory));
        
        // Mise √† jour de l'√©tat React DIFF√âR√âE apr√®s les interactions
        InteractionManager.runAfterInteractions(() => {
          setHistoricalScans(newHistory);
        });
        
        // Mettre √† jour la liste des paquets pris en charge
        if (operationType === 'entree') {
          setTakingCarePackages([...scansToSubmit, ...takingCarePackages]);
        } else if (operationType === 'sortie') {
          const codesDeposited = scansToSubmit.map(scan => scan.code);
          setTakingCarePackages(takingCarePackages.filter(pkg => pkg.code && !codesDeposited.includes(pkg.code)));
        }
        
        // R√©initialiser compl√®tement l'√©tat pour revenir √† l'√©cran de scan de site
        resetScan(); // Cette fonction r√©initialise les √©tats de base

        // S'assurer que tous les √©tats sont correctement r√©initialis√©s pour revenir √† l'√©cran initial
        setShowOperationTypeSelection(false);
        setOperationType('entree'); // R√©initialiser √† l'entr√©e de colis par d√©faut
        
        // Important: D√©sactiver le chargement AVANT l'alerte
        setLoading(false);
        
        // Afficher l'alerte de succ√®s
        Alert.alert(
          'Succ√®s',
          `${scansToSubmit.length} scan(s) transmis avec succ√®s`,
          [{ text: 'OK' }]
        );
      } else {
        setLoading(false);
        throw new Error(result.error || '√âchec de la transmission');
      }
    } catch (error) {
      console.error('Erreur lors de la transmission:', error);
      setLoading(false);
      Alert.alert('Erreur', `√âchec de la transmission: ${error.message}`);
    }
  };

  const resetScan = () => {
    setScanMode('');
    setSiteScanned(false);
    setSiteCode('');
    setScannedContenants([]);
    setManualCodeInput('');
    setSiteDetails(null);
  };

  const navigateToHistory = () => {
    setShowHistoryModal(true);
  };

  // Fonction pour obtenir les d√©tails de la session actuelle
  const getSessionDetails = async () => {
    try {
      const currentSession = await firebaseService.getCurrentSession();
      if (currentSession) {
        setSessionId(currentSession.id);
        setTournee(currentSession.tournee);
        setVehicule(currentSession.vehicule);
        setPole(currentSession.pole);
      }
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration de la session:", error);
    }
  };

  // Fonction pour effacer l'historique des scans
  const clearHistoricalScans = async () => {
    try {
      Alert.alert(
        'Effacer l\'historique',
        'Voulez-vous vraiment effacer tout l\'historique des scans?',
        [
          {
            text: 'Annuler',
            style: 'cancel'
          },
          {
            text: 'Effacer',
            onPress: async () => {
              await AsyncStorage.removeItem('scanHistory');
              setHistoricalScans([]);
              Alert.alert('Succ√®s', 'Historique effac√© avec succ√®s');
            },
            style: 'destructive'
          }
        ]
      );
    } catch (error) {
      console.error('Erreur lors de l\'effacement de l\'historique:', error);
      Alert.alert('Erreur', 'Impossible d\'effacer l\'historique');
    }
  };

  // Ajout d'une fonction pour effacer explicitement tous les scans de la session actuelle
  const clearCurrentSessionScans = async () => {
    try {
      const currentSessionId = await AsyncStorage.getItem('currentSessionId');
      if (!currentSessionId) {
        Alert.alert('Erreur', 'Impossible de d√©terminer la session actuelle');
        return;
      }
      
      Alert.alert(
        'R√©initialiser l\'historique',
        'Cette action va supprimer tous les scans associ√©s √† votre session actuelle. Continuer?',
        [
          {
            text: 'Annuler',
            style: 'cancel'
          },
          {
            text: 'Supprimer',
            onPress: async () => {
              try {
                // Supprimer les scans associ√©s √† la session actuelle
                setLoading(true);
                console.log(`Suppression des scans de la session ${currentSessionId}...`);
                
                // Fonction c√¥t√© service qui devrait √™tre impl√©ment√©e
                // pour supprimer tous les scans de la session
                const result = await firebaseService.clearSessionScans(currentSessionId);
                
                // Supprimer l'historique local √©galement
                await AsyncStorage.removeItem('scanHistory');
                setHistoricalScans([]);
                
                setLoading(false);
                Alert.alert('Succ√®s', 'Historique r√©initialis√© avec succ√®s');
              } catch (error) {
                setLoading(false);
                console.error('Erreur lors de la suppression des scans:', error);
                Alert.alert('Erreur', `√âchec de la suppression: ${error.message}`);
              }
            },
            style: 'destructive'
          }
        ]
      );
    } catch (error) {
      console.error('Erreur:', error);
      Alert.alert('Erreur', 'Une erreur est survenue');
    }
  };

  // Handler de d√©connexion avec effacement complet de l'historique
  const handleLogout = async () => {
    try {
      Alert.alert(
        'D√©connexion',
        'Voulez-vous vous d√©connecter? L\'historique des scans sera effac√©.',
        [
          {
            text: 'Annuler',
            style: 'cancel'
          },
          {
            text: 'D√©connecter',
            onPress: async () => {
              try {
                setLoading(true);
                console.log('D√©connexion en cours...');

                // Appeler la m√©thode de d√©connexion de Firebase
                await firebaseService.logout();
                console.log('D√©connexion Firebase r√©ussie');
                
                // Effacer toutes les donn√©es de session
                await AsyncStorage.removeItem('userSessionActive');
                // On conserve current_session_id pour que la tourn√©e visit√©e reste en m√©moire
                await AsyncStorage.removeItem('scanHistory');
                await AsyncStorage.removeItem('user_selas_id');
                
                // R√©initialiser les √©tats
                setHistoricalScans([]);
                setScannedContenants([]);
                setSiteScanned(false);
                setSiteCode('');
                
                setLoading(false);
                
                // Rediriger vers l'√©cran de connexion
                navigation.reset({
                  index: 0,
                  routes: [{ name: 'Login' }]
                });
              } catch (error) {
                setLoading(false);
                console.error('Erreur lors du processus de d√©connexion:', error);
                Alert.alert('Erreur', 'Impossible de se d√©connecter. Veuillez r√©essayer.');
              }
            }
          }
        ]
      );
    } catch (error) {
      console.error('Erreur lors de la d√©connexion:', error);
    }
  };

  // Utiliser directement les fonctions de formatage de dateUtils
  // au lieu de red√©finir des fonctions similaires

  // Effet pour √©couter les √©v√©nements de scan Zebra
  useEffect(() => {
    if (isReadyForScan) {
      // Afficher un message pour indiquer que l'application est pr√™te pour le scan
      console.log('Pr√™t √† recevoir des scans du scanner Zebra');
      
      // Configuration pour recevoir les scans du mat√©riel Zebra
      const handleZebraScan = (event) => {
        // Le scanner Zebra envoie g√©n√©ralement les donn√©es comme des entr√©es clavier
        // Nous devons v√©rifier que nous sommes en mode scan et traiter les donn√©es
        if (event && event.nativeEvent && event.nativeEvent.key === 'Enter' && scanMode) {
          // R√©cup√©rer le texte scann√© (par exemple depuis un champ de texte cach√© ou via une API Zebra)
          // Pour les besoins de cet exemple, nous utiliserons la valeur de manualCodeInput
          if (manualCodeInput.trim()) {
            processScannedData(manualCodeInput.trim());
            setManualCodeInput(''); // R√©initialiser apr√®s le traitement
          }
        }
      };
      
      // Ajoutez ici l'initialisation sp√©cifique au scanner Zebra si n√©cessaire
      // Exemple : ZebraScanner.initialize() si une API Zebra est disponible
      
      // Pour cet exemple, on simule en utilisant l'√©couteur de clavier (pour Enter)
      Keyboard.addListener('keyDown', handleZebraScan);
      
      return () => {
        // Nettoyage lors du d√©montage
        Keyboard.removeListener('keyDown', handleZebraScan);
        // D√©sinitialiser le scanner Zebra si n√©cessaire
        // Exemple : ZebraScanner.deinitialize()
      };
    }
  }, [isReadyForScan, scanMode, manualCodeInput]);


  const loadHistoricalScans = async () => {
    try {
      const jsonValue = await AsyncStorage.getItem('scanHistory');
      if (jsonValue !== null) {
        const history = JSON.parse(jsonValue);
        
        // R√©cup√©rer l'ID de la tourn√©e actuelle
        const currentSession = await firebaseService.getCurrentSession();
        const currentTourneeId = currentSession?.tournee?.id || sessionData?.tournee?.id || '';
        
        // Filtrer l'historique local
        const today = new Date();
        today.setHours(0, 0, 0, 0); // D√©but de la journ√©e
        
        const filteredHistory = history.filter(item => {
          // Convertir la date de l'item en objet Date
          let itemDate;
          try {
            itemDate = new Date(item.date);
            if (isNaN(itemDate.getTime())) {
              // Si la date n'est pas valide, essayer un autre format
              const parts = item.date.split('/');
              if (parts.length === 3) {
                itemDate = new Date(parts[2], parts[1] - 1, parts[0]);
              }
            }
          } catch (e) {
            // En cas d'erreur, consid√©rer cet item comme non valide pour le filtre
            return false;
          }

          // S'assurer que nous avons une date valide
          if (!itemDate || isNaN(itemDate.getTime())) return false;
          
          itemDate.setHours(0, 0, 0, 0); // Normaliser √† minuit
          
          // V√©rifier la tourn√©e
          const isSameTournee = !currentTourneeId || item.tourneeId === currentTourneeId;
          
          // V√©rifier le statut (inclut les visites sans colis)
          const hasValidStatus = item.status === 'en-cours' || item.status === 'livr√©';
          
          // L'item doit √™tre du jour courant ET de la m√™me tourn√©e ET avoir un statut valide
          return itemDate.getTime() === today.getTime() && isSameTournee && hasValidStatus;
        });
        
        console.log(`Historique local filtr√©: ${filteredHistory.length} scans (jour + tourn√©e + statut)`);
        
        // Consolider l'historique filtr√© avant de mettre √† jour l'√©tat
        const consolidatedHistory = consolidateAndSortScans([], filteredHistory);

        // Enrichir avec le nom complet du site depuis Firestore
        const enrichedHistory = await Promise.all(
          consolidatedHistory.map(async (scan) => {
            // Tenter de r√©cup√©rer les d√©tails du site en utilisant siteId ou code
            try {
              const siteIdentifier = scan.siteId || scan.code; // Utiliser ID ou code
              // V√©rifier si l'identifiant est probablement un site avant d'appeler getSiteById
              if (siteIdentifier && 
                  !siteIdentifier.startsWith('TEST_CONTENANT_') && 
                  !siteIdentifier.match(/^[0-9]{13,}$/)) { 
                const siteInfo = await firebaseService.getSiteById(siteIdentifier);
                if (siteInfo) {
                  // Enrichir le scan avec les d√©tails complets
                  return { 
                    ...scan, 
                    siteName: siteInfo.nom || siteInfo.name, // Ajouter le nom pour affichage facile
                    siteDetails: { ...siteInfo } 
                  };
                }
              }
            } catch (e) {
              console.warn(`[loadHistoricalScans] Erreur r√©cup√©ration d√©tails site pour ${scan.code || scan.id}:`, e);
            }
            // Si non trouv√© ou erreur, retourner le scan original
            return scan;
          })
        );
        
        // Mettre √† jour l'√©tat avec l'historique enrichi
        setHistoricalScans(enrichedHistory);
        setSessionHistoryLoaded(true);
      }
    } catch (error) {
      console.error('Erreur lors du chargement de l\'historique:', error);
    }
  };

  const loadFirestoreScans = async () => {
    try {
      // On ne charge les scans Firestore que si la session est active
      const userSessionActive = await AsyncStorage.getItem('userSessionActive');
      if (userSessionActive !== 'true') {
        // Si aucune session active, on ne charge pas l'historique Firestore
        return;
      }

      // R√©cup√©rer l'ID de session actuel
      const currentSessionId = await AsyncStorage.getItem('currentSessionId');
      console.log('Chargement des scans pour la session:', currentSessionId);

      // R√©cup√©rer l'ID de la tourn√©e actuelle
      const currentSession = await firebaseService.getCurrentSession();
      const currentTourneeId = currentSession?.tournee?.id || sessionData?.tournee?.id || '';
      console.log('Tourn√©e actuelle:', currentTourneeId);

      setLoading(true); // Afficher l'indicateur de chargement

      // R√©cup√©rer tous les scans de l'utilisateur (sans limite)
      const scans = await firebaseService.getScans();
      
      if (scans && scans.length > 0) {
        // Ne garder que les scans du jour (J0)
        const today = new Date();
        today.setHours(0, 0, 0, 0); // D√©but de la journ√©e
        
        const filteredScans = scans.filter(scan => {
          // Convertir la date du scan en objet Date
          const scanDate = dateUtils.convertTimestampToDate(scan.scanDate || scan.createdAt);
          if (!scanDate) return false;
          
          // R√©cup√©rer juste la date (sans l'heure)
          const scanDateOnly = new Date(scanDate);
          scanDateOnly.setHours(0, 0, 0, 0);
          
          // V√©rifier la tourn√©e (si une tourn√©e actuelle est d√©finie)
          const isSameTournee = !currentTourneeId || scan.tourneeId === currentTourneeId;
          
          // V√©rifier le statut (inclut "pas_de_colis")
          const hasValidStatus = scan.status === 'en-cours' || scan.status === 'livr√©';
          
          // Le scan doit √™tre du jour courant ET de la m√™me tourn√©e ET avoir un statut valide
          return scanDateOnly.getTime() === today.getTime() && isSameTournee && hasValidStatus;
        });
        
        // Convertir les scans Firestore filtr√©s en format compatible avec l'historique local
        const formattedScans = filteredScans.map(scan => {
          // D√©duire le statut si manquant, bas√© sur le type d'op√©ration
          let status = scan.status;
          if (!status) {
            status = scan.operationType === 'sortie' ? 'livr√©' : 'en-cours';
          }
          
          return {
            id: scan.id || Date.now().toString(),
            code: scan.code,
            timeStamp: dateUtils.formatTime(scan.scanDate || scan.createdAt),
            date: dateUtils.formatDate(scan.scanDate || scan.createdAt),
            site: scan.site,
            fromFirestore: true,
            sessionId: scan.sessionId,
            // Utiliser le statut (corrig√© si n√©cessaire)
            status: status, 
            // S'assurer que le type est aussi pr√©sent
            type: scan.operationType || (status === 'livr√©' ? 'sortie' : 'entree'), 
            tournee: scan.tournee || '',
            tourneeId: scan.tourneeId || '',
            scanDate: scan.scanDate ? dateUtils.convertTimestampToDate(scan.scanDate).toISOString() : (scan.createdAt ? dateUtils.convertTimestampToDate(scan.createdAt).toISOString() : new Date().toISOString()) // Garder une date ISO pour le tri
          };
        });
        
        // Consolider et trier
        const consolidatedScans = consolidateAndSortScans(historicalScans, formattedScans);
        // Enrichir avec le nom complet du site depuis Firestore
        const enrichedScans = await Promise.all(
          consolidatedScans.map(async (scan) => {
            try {
              // Tenter de r√©cup√©rer les d√©tails du site
              try {
                // Utiliser l'ID du site si disponible, sinon le code barre
                const siteIdentifier = scan.siteId || scan.code; // Assumer que siteId existe
                if (siteIdentifier && 
                    !siteIdentifier.startsWith('TEST_CONTENANT_') && 
                    !siteIdentifier.match(/^[0-9]{13,}$/)) {
                  // Utiliser une variable locale au lieu de r√©assigner l'√©tat siteDetails
                  const siteInfo = await firebaseService.getSiteById(siteIdentifier); 
                  if (siteInfo) {
                    // Modifier l'objet scan directement
                    scan.siteName = siteInfo.nom || siteInfo.name; // Utiliser le nom du site s'il est trouv√©
                    scan.siteDetails = siteInfo; // Ajouter les d√©tails au scan
                  } else {
                     // Si siteInfo est null, indiquer le nom comme code
                     scan.siteName = scan.code; 
                  }
                } else {
                   scan.siteName = scan.code; // Fallback si aucun identifiant
                }
              } catch (siteError) {
                console.warn(`[loadFirestoreScans] Impossible de r√©cup√©rer les d√©tails du site pour l'identifiant ${scan.siteId || scan.code}:`, siteError);
                scan.siteName = scan.code; // Afficher le code si erreur
              }
              
              // Ne r√©cup√©rer les informations sur le site que s'il ne s'agit pas d'un conteneur
              if (scan.site && 
                  !scan.site.startsWith('TEST_CONTENANT_') && 
                  !scan.site.match(/^[0-9]{13,}$/)) {
                const siteInfo = await firebaseService.getSiteById(scan.site);
                if (siteInfo) return { ...scan, siteDetails: { ...siteInfo } };
              }
            } catch (e) {
              console.error('Erreur r√©cup√©ration nom site Firestore:', e);
            }
            return scan;
          })
        );
        
        // Mettre √† jour l'√©tat avec l'historique enrichi
        setHistoricalScans(enrichedScans);
        setSessionHistoryLoaded(true);
        
        // Sauvegarder √©galement dans AsyncStorage pour la persistance locale temporaire
        await AsyncStorage.setItem('scanHistory', JSON.stringify(enrichedScans));
      }
      
      setLoading(false); // Masquer l'indicateur de chargement
    } catch (error) {
      console.error('Erreur lors du chargement des scans depuis Firestore:', error);
      setLoading(false); // Masquer l'indicateur de chargement en cas d'erreur
    }
  };

  // --- AJOUTER CETTE FONCTION D'AIDE --- 
  // Fonction pour consolider et trier les scans
  const consolidateAndSortScans = (existingScans, newScans) => {
    const map = new Map();

    // Ajouter les scans existants √† la map
    existingScans.forEach(scan => {
      if (scan.code) map.set(scan.code, scan);
    });

    // Mettre √† jour ou ajouter les nouveaux scans
    newScans.forEach(scan => {
      if (scan.code) map.set(scan.code, scan);
    });

    // Convertir la map en tableau
    const consolidated = Array.from(map.values());

    // Trier
    consolidated.sort((a, b) => {
      const dateA = a.scanDate ? new Date(a.scanDate).getTime() : 0;
      const dateB = b.scanDate ? new Date(b.scanDate).getTime() : 0;
      if (isNaN(dateA) && isNaN(dateB)) return 0;
      if (isNaN(dateA)) return 1;
      if (isNaN(dateB)) return -1;
      return dateB - dateA;
    });

    return consolidated;
  };
  // --- FIN DE L'AJOUT ---

  const loadTakingCarePackages = async () => {
    try {
      const scansEnCours = await firebaseService.getScansEnCours();
      // Filtrer pour exclure les scans "pas_de_colis"
      const filteredScans = scansEnCours.filter(scan => 
        scan.status !== 'pas_de_colis' &&
        !(scan.code && scan.code.startsWith('SITE_'))
      );
      console.log(`‚úÖ ${filteredScans.length} paquet(s) pris en charge r√©cup√©r√©(s) (sans les "pas_de_colis")`);
      setTakingCarePackages(filteredScans);
    } catch (error) {
      console.error('‚ùå Erreur lors du chargement des paquets pris en charge:', error);
    }
  };

  // üîπ Simulation d'un scan avec des sites valides
  const simulateScan = () => {
    if (scanMode === 'site') {
      // Sites de test qui seront reconnus comme valides
      const sitesDemoValides = [
        'SITE123',
        'SITE456',
        'SITE789',
        'LAB001',
        '12345'
      ];
      
      // S√©lectionner un site al√©atoire parmi les sites valides pour la d√©mo
      return sitesDemoValides[Math.floor(Math.random() * sitesDemoValides.length)];
    } else {
      // Si on est en mode sortie (d√©p√¥t), on doit scanner un colis d√©j√† pris en charge
      if (operationType === 'sortie') {
        // V√©rifier si des colis sont disponibles
        if (takingCarePackages.length > 0) {
          // S√©lectionner un colis al√©atoire parmi les colis pris en charge
          const randomPackage = takingCarePackages[Math.floor(Math.random() * takingCarePackages.length)];
          return randomPackage.code;
        } else {
          // Aucun colis disponible pour le d√©p√¥t - cette condition est g√©r√©e dans handleSimulatedScan
          return '';
        }
      } else {
        // Simuler un scan de contenant pour prise en charge
        // Utiliser un pr√©fixe sp√©cifique pour les tests afin de pouvoir les identifier facilement
        const testId = Date.now(); // Utiliser le timestamp actuel pour cr√©er un ID unique
        return `TEST_CONTENANT_${testId}`;
      }
    }
  };

  // Modification pour les tests : fonction mock qui simule verifySiteCode
  const mockVerifySiteCode = async (siteCode) => {
    // Sites de test qui seront automatiquement valid√©s
    const sitesDemoValides = {
      'SITE123': { nom: 'Site Test 1', adresse: '123 Rue Principale', ville: 'Paris', codePostal: '75001' },
      'SITE456': { nom: 'Site Test 2', adresse: '456 Avenue R√©publique', ville: 'Lyon', codePostal: '69001' },
      'SITE789': { nom: 'Site Test 3', adresse: '789 Boulevard des Tests', ville: 'Toulouse', codePostal: '31000' },
      '12345': { nom: 'Laboratoire Central', adresse: '12 Rue des Sciences', ville: 'Montpellier', codePostal: '34000' },
      'LAB001': { nom: 'Laboratoire Mobile', adresse: 'Zone Industrielle', ville: 'Bordeaux', codePostal: '33000' }
    };

    // V√©rifier si le code scann√© est dans notre liste de sites de test
    if (sitesDemoValides[siteCode]) {
      // Retourner une structure simulant la r√©ponse de Firebase
      return {
        valid: true,
        site: {
          id: `mock_${siteCode}`,
          code: siteCode,
          nom: sitesDemoValides[siteCode].nom,
          adresse: sitesDemoValides[siteCode].adresse,
          ville: sitesDemoValides[siteCode].ville,
          codePostal: sitesDemoValides[siteCode].codePostal
        }
      };
    }

    // Si ce n'est pas un site de test, passer √† la v√©rification normale dans Firebase
    return await firebaseService.verifySiteCode(siteCode);
  };

  const processScannedData = async (data) => {
    console.log('Code scann√©:', data);
    try {
      // Cas 1: Nous n'avons pas encore scann√© de site
      if (!siteScanned && scanMode === 'site') {
        console.log('[processScannedData] Mode: Scan de site. Donn√©es:', data);
        const siteVerification = await firebaseService.verifySiteCode(data);
        console.log('[processScannedData] R√©sultat de verifySiteCode:', JSON.stringify(siteVerification));

        if (siteVerification.site) {
          // Enregistrer les infos du site
          setSiteCode(data);
          setSiteDetails(siteVerification.site);
          // setSiteScanned(true); // Mis plus bas pour ne l'activer qu'apr√®s succ√®s
          // setScanMode(''); // Mis plus bas
          // setShowOperationTypeSelection(true); // Mis plus bas

          // --- MODIFI√â: Ne trouver que le premier site non visit√© avec ce nom ---
          let occurrenceIndex = null;
          if (tourneeProgressRef.current?.getSitesWithStatus) {
            const sitesList = tourneeProgressRef.current.getSitesWithStatus();
            console.log('[processScannedData] sitesList depuis tourneeProgressRef:', JSON.stringify(sitesList.map(s => ({ id: s.id, name: s.name, visited: s.visited, uniqueDisplayId: s.uniqueDisplayId }))));
            const siteNameToFind = siteVerification.site.nom || siteVerification.site.name;
            console.log('[processScannedData] Nom du site √† trouver:', siteNameToFind);

            // Trouver le premier site non visit√© avec ce nom
            occurrenceIndex = sitesList.findIndex(s => !s.visited && (s.name === siteNameToFind || s.nom === siteNameToFind)); // Ajout de s.nom
            console.log(`[processScannedData] Occurrence index trouv√©e pour ${siteNameToFind}:`, occurrenceIndex);
            
            // Si aucun site non visit√© n'est trouv√©, ne rien faire
            if (occurrenceIndex === -1) {
              Alert.alert(
                'Site d√©j√† visit√© ou non trouv√©', // Message mis √† jour
                'Ce site a d√©j√† √©t√© visit√©, ne fait pas partie de cette tourn√©e, ou son nom ne correspond pas exactement.', // Message mis √† jour
                [{ text: 'OK', onPress: () => {
                  // R√©initialiser l'√©tat pour permettre un nouveau scan
                  setSiteScanned(false);
                  setSiteDetails(null);
                  setSiteCode('');
                  setShowOperationTypeSelection(false);
                }}]
              );
              return;
            }
          } else {
            console.warn('[processScannedData] tourneeProgressRef.current.getSitesWithStatus non disponible.');
            Alert.alert('Erreur', 'Impossible de r√©cup√©rer la liste des sites de la tourn√©e.');
            return;
          }

          // Marquage en session via l'index si trouv√©, sinon par site.id
          const identifier = siteVerification.site.id || (siteVerification.site.code || data);
          console.log('[processScannedData] Identifier pour markSiteVisitedInSession:', identifier);
          console.log('[processScannedData] currentSessionId avant appel:', currentSessionId);
          console.log('[processScannedData] occurrenceIndex avant appel:', occurrenceIndex);

          if (!currentSessionId) {
            console.error('[processScannedData] ID de session manquant avant markSiteVisitedInSession');
            Alert.alert('Erreur Critique', 'ID de session manquant. Impossible de continuer.');
            return;
          }
          
          // Ne marquer qu'un seul site √† la fois, en utilisant l'index sp√©cifique
          if (occurrenceIndex !== -1 && occurrenceIndex !== null) { // Condition d√©j√† pr√©sente, mais on log avant
            const markSuccess = await firebaseService.markSiteVisitedInSession(currentSessionId, identifier, occurrenceIndex);
            console.log('[processScannedData] R√©sultat de markSiteVisitedInSession:', markSuccess);
            
            if (markSuccess) {
              setSiteScanned(true); // Activer seulement si le marquage Firestore a r√©ussi
              setScanMode(''); 
              setShowOperationTypeSelection(true);

              // Mise √† jour du UI local - mettre √† jour uniquement le site sp√©cifique
              if (tourneeProgressRef.current?.markSiteAsVisitedLocally) {
                console.log('[processScannedData] Appel de markSiteAsVisitedLocally avec:', identifier, occurrenceIndex);
                await tourneeProgressRef.current.markSiteAsVisitedLocally(identifier, occurrenceIndex); // AJOUT DE AWAIT
                // Temporairement comment√© pour tester si la coche se met √† jour correctement sans rechargement imm√©diat
                // await updateTourneeProgress(); 
              } else if (tourneeProgressRef.current?.loadTourneeDetails) {
                console.log('[processScannedData] Appel de loadTourneeDetails(true) car markSiteAsVisitedLocally non dispo.');
                await tourneeProgressRef.current.loadTourneeDetails(true);
              }
            } else {
              Alert.alert('Erreur', '√âchec du marquage du site comme visit√© dans la session Firestore.');
              // Garder siteScanned √† false, etc.
            }
            
            // Si updateTourneeProgress a √©t√© comment√©, on peut appeler loadHistoricalData ici
            // si c'est n√©cessaire pour d'autres parties de l'UI non li√©es √† TourneeProgress.
            // Pour l'instant, on isole le probl√®me de la coche.
            // await loadHistoricalData(); 

          } else {
             console.warn('[processScannedData] occurrenceIndex invalide, markSiteVisitedInSession non appel√©.');
             // Potentiellement une alerte ici si ce cas ne devrait pas arriver
          }
          return;
        } else { // siteVerification.site est null/undefined
          console.log('[processScannedData] Aucun site valide retourn√© par verifySiteCode pour le code:', data);
          Alert.alert('Site Inconnu', 'Le code scann√© ne correspond √† aucun site connu.');
           // R√©initialiser pour permettre un nouveau scan
          setSiteScanned(false);
          setSiteDetails(null);
          setSiteCode('');
          setShowOperationTypeSelection(false);
        }
      }
      
      // Cas 2: Site d√©j√† scann√©, nous scannons maintenant un contenant
      if (siteScanned && scanMode === 'contenant') {
        console.log('[processScannedData] Mode: Scan de contenant. Donn√©es:', data);
        handleContenantScan(data);
        // Rester en mode scan contenant pour permettre les scans multiples
        setScanMode('contenant');
      }
    } catch (error) {
      console.error('Erreur lors de la gestion du scan:', error);
      setErrorMessage('Erreur: ' + error.message); // Afficher l'erreur √† l'utilisateur
      setScanMode(''); // R√©initialiser le mode scan
      // Optionnel: r√©initialiser d'autres √©tats si n√©cessaire
      setSiteScanned(false);
      setSiteDetails(null);
      setSiteCode('');
      setShowOperationTypeSelection(false);
    }
  };

  // G√©rer la simulation d'un scan (pour le d√©veloppement et les tests)
  const handleSimulatedScan = () => {
    // V√©rifier si on est en mode sortie sans colis pris en charge
    if (scanMode === 'contenant' && operationType === 'sortie' && takingCarePackages.length === 0) {
      Alert.alert(
        "Aucun colis disponible",
        "Vous n'avez aucun colis en prise en charge √† d√©poser.",
        [{ text: "OK" }]
      );
      return;
    }
    
    const fakeData = simulateScan();
    if (fakeData) {
      console.log(`Simulation de scan avec donn√©es: ${fakeData}`);
    processScannedData(fakeData);
    } else {
      console.error("Erreur lors de la simulation du scan: aucune donn√©e g√©n√©r√©e");
      Alert.alert(
        "Erreur",
        "Impossible de simuler un scan. Veuillez r√©essayer.",
        [{ text: "OK" }]
      );
    }
  };

  const handleManualScan = () => {
    if (manualCodeInput.trim() === '') {
      Alert.alert('Erreur', 'Veuillez entrer un code valide');
      return;
    }
    
    processScannedData(manualCodeInput.trim());
    setManualCodeInput('');
  };

  const activateSiteScan = () => {
    setScanMode('site');
    setErrorMessage('');
    setIsReadyForScan(true);
    
    // Montrer une alerte avec plusieurs options pour scanner
    Alert.alert(
      "Scanner un site",
      "Comment souhaitez-vous scanner le site ?",
      [
        {
          text: "Scanner manuellement",
          onPress: () => showManualSiteInput()
        },
        {
          text: "Simuler scan",
          onPress: handleSimulatedScan
        },
        {
          text: "Annuler",
          style: "cancel",
          onPress: () => setScanMode('')
        }
      ]
    );
  };

  // Fonction pour afficher une bo√Æte de dialogue pour saisir manuellement le code du site
  const showManualSiteInput = () => {
    // Utiliser Alert.prompt sur iOS, mais sur Android, cette fonction n'existe pas
    // donc nous utilisons une m√©thode alternative
    if (Platform.OS === 'ios') {
      Alert.prompt(
        "Scanner site manuellement",
        "Entrez le code ou le nom du site",
        [
          { text: "Annuler", onPress: () => setScanMode(''), style: "cancel" },
          { 
            text: "Scanner", 
            onPress: (code) => {
              if (code && code.trim()) {
                processScannedData(code.trim());
              } else {
                setScanMode('');
                Alert.alert("Erreur", "Veuillez entrer un code de site valide");
              }
            }
          }
        ],
        "plain-text"
      );
    } else {
      // Sur Android, utiliser une solution simple avec TextInput
      Alert.alert(
        "Scanner site manuellement",
        "Entrez le code du site dans le champ de texte en haut de l'√©cran, puis appuyez sur Scanner",
        [
          { text: "OK" }
        ]
      );
      // Focus sur le champ de saisie manuelle
      // Note: ceci est une approche simplifi√©e, une solution plus robuste
      // utiliserait un modal personnalis√© avec TextInput
      setManualCodeInput('');
      // On garde le mode scan actif pour que le bouton scanner manuel fonctionne
    }
  };

  // Afficher la page de s√©lection du type d'op√©ration
  const showOperationSelection = () => {
    setShowOperationTypeSelection(true);
  };

  // Commencer le scan de contenant avec un type d'op√©ration sp√©cifique
  const startContenantScan = (type) => {
    setOperationType(type);
    setShowOperationTypeSelection(false);
    setScanMode('contenant');
    setErrorMessage('');
    setIsReadyForScan(true);
    
    // Message diff√©rent selon le type d'op√©ration
    const message = type === 'entree' 
      ? "Veuillez scanner le code du contenant √† prendre en charge" 
      : "Veuillez scanner le code du contenant √† d√©poser";
    
    Alert.alert(
      type === 'entree' ? "Prise en charge" : "D√©p√¥t",
      message,
      [{ text: "Annuler", onPress: () => setScanMode('') }]
    );
  };

  const handleContenantScan = async (code) => {
    if (!siteScanned) {
      Alert.alert('Erreur', 'Veuillez d\'abord scanner un site');
      return;
    }

    try {
      // Mode d√©p√¥t (sortie) - v√©rifier que le colis est dans la liste des colis pris en charge
      if (operationType === 'sortie') {
        const isInTakingCare = takingCarePackages.some(pkg => pkg.code === code);
        if (!isInTakingCare) {
          Alert.alert(
            "Colis non reconnu",
            "Ce colis ne fait pas partie des colis que vous avez en prise en charge.",
            [{ text: "OK" }]
          );
          return;
        }
        
        // Retirer le colis de la liste des colis pris en charge
        setTakingCarePackages(takingCarePackages.filter(pkg => pkg.code !== code));
      }

      // Obtenir la date actuelle au format appropri√©
      const currentDate = new Date();
      const currentDateISO = currentDate.toISOString();

      // Ajouter le contenant √† la liste
      const newContenant = {
        id: Date.now().toString(),
        code: code,
        idColis: code,
        timeStamp: currentDate.toLocaleTimeString(),
        date: currentDate.toLocaleDateString(),
        scanDate: currentDateISO,
        site: siteCode,
        type: operationType, // Ajout du type d'op√©ration (entr√©e/sortie)
      };
      
      setScannedContenants([newContenant, ...scannedContenants]);
    } catch (error) {
      console.error('Erreur lors de la gestion du scan:', error);
      setScanMode('');
    }
  };

  const renderScannedItem = ({ item }) => (
    <View style={[styles.contenantItem, item.type === 'sortie' ? styles.contenantItemSortie : styles.contenantItemEntree]}>
      <View style={styles.contenantInfo}>
        <Text style={styles.contenantCode}>{item.code}</Text>
        <View style={styles.contenantTypeRow}>
          <View style={item.type === 'sortie' ? styles.typeTagSortie : styles.typeTagEntree}>
            <Text style={styles.typeTagText}>{item.type === 'sortie' ? 'D√©p√¥t' : 'Prise en charge'}</Text>
          </View>
          <Text style={styles.contenantTime}>{item.timeStamp}</Text>
        </View>
      </View>
      <TouchableOpacity
        style={styles.deleteContenantButton}
        onPress={() => removeScannedContenant(item.id)}
      >
        <Ionicons name="trash-outline" size={20} color="#e74c3c" />
      </TouchableOpacity>
    </View>
  );

  const removeScannedContenant = (id) => {
    setScannedContenants(scannedContenants.filter(contenant => contenant.id !== id));
  };

  const handleTransmit = async () => {
    if (scannedContenants.length === 0) {
      Alert.alert('Attention', 'Aucun contenant scann√© √† transmettre.');
      return;
    }

    setLoading(true);

    try {
      // V√©rifier et afficher les donn√©es de la session pour le d√©bogage
      console.log('Donn√©es de session:', JSON.stringify(sessionData, null, 2));
      console.log('Donn√©es de route:', JSON.stringify(route.params, null, 2));
      
      // R√©cup√©rer les donn√©es de la tourn√©e et du v√©hicule avec plus de v√©rifications
      const tourneeName = sessionData.tournee?.nom || route.params?.tournee?.nom || '';
      const tourneeId = sessionData.tournee?.id || route.params?.tournee?.id || '';
      const vehiculeName = sessionData.vehicule?.immatriculation || route.params?.vehicule?.immatriculation || '';
      const vehiculeId = sessionData.vehicule?.id || route.params?.vehicule?.id || '';
      
      // Utiliser les d√©tails du site valid√© s'ils sont disponibles
      let siteName, siteId, siteAdresse, siteCodePostal, siteVille;
      
      if (siteDetails) {
        // Utiliser les bonnes cl√©s du siteDetails (nommage uniforme)
        siteName = siteDetails.name || siteCode;
        siteId = siteDetails.id || '';
        siteAdresse = siteDetails.address || '';
        siteCodePostal = siteDetails.codePostal || '';
        siteVille = siteDetails.city || '';
      } else {
        // Sinon on utilise ce qu'on a par d√©faut
        siteName = sessionData.tournee?.siteDepart || route.params?.tournee?.siteDepart || siteCode || 'Non sp√©cifi√©';
        siteId = '';
      }
      
      console.log('Donn√©es r√©cup√©r√©es pour les scans:', {
        tourneeName,
        tourneeId,
        vehiculeName,
        vehiculeId,
        siteName,
        siteId,
        siteCode
      });

      // R√©cup√©rer l'ID de session actuel
      const currentSessionId = await AsyncStorage.getItem('currentSessionId') || `session_${Date.now()}`;
      
      // Pr√©parer les scans avec tous les champs n√©cessaires
      const scansToSubmit = scannedContenants.map(scan => {
        const scanDate = scan.scanDate || new Date().toISOString();
        
        // Le code du contenant devient l'ID du colis
        const scanItem = {
          code: scan.code,
          idColis: scan.code || scan.idColis,
          scanDate: scanDate,
          tournee: tourneeName,
          tourneeId: tourneeId,
          vehicule: vehiculeName,
          vehiculeId: vehiculeId,
          immatriculation: vehiculeName,
          site: siteName,
          siteId: siteId,
          siteCode: siteCode,
          siteDepart: siteName,
          siteD√©part: siteName,
          sessionId: currentSessionId, // Ajouter l'ID de session pour le filtrage ult√©rieur
          operationType: scan.type || 'entree', // Ajout du type d'op√©ration
          status: scan.type === 'sortie' ? 'livr√©' : 'en-cours', // Status bas√© sur le type d'op√©ration
          type: scan.type || 'entree' // Assurer que le type est inclus explicitement
        };
        
        // Ajouter siteFin uniquement pour les colis livr√©s
        if (scan.type === 'sortie') {
          // Pour les op√©rations de sortie (d√©p√¥t), ajouter des informations sp√©cifiques
          const currentDate = new Date();
          
          // Utiliser le nom du site actuel comme site d'arriv√©e
          scanItem.siteFin = siteName;
          // Ajouter date et heure d'arriv√©e au format correct
          scanItem.dateArrivee = currentDate.toLocaleDateString();
          scanItem.heureArrivee = currentDate.toLocaleTimeString();
          // Ajouter ces champs suppl√©mentaires pour assurer la compatibilit√©
          scanItem.dateHeureFin = currentDate.toISOString();
          scanItem.statut = 'Livr√©';
          scanItem.status = 'livr√©'; // Assurez-vous que les deux formats sont pr√©sents
          scanItem.coursierLivraison = sessionData.coursierCharg || route.params?.coursierCharg || '';
        }
        
        // Ajouter les d√©tails du site s'ils sont disponibles
        if (siteDetails) {
          scanItem.siteDetails = {
            adresse: siteAdresse,
            codePostal: siteCodePostal,
            ville: siteVille
          };
        }

        // Ajouter la localisation si disponible
        if (sessionData.location) {
          scanItem.location = {
            latitude: sessionData.location.coords.latitude,
            longitude: sessionData.location.coords.longitude,
            accuracy: sessionData.location.coords.accuracy
          };
        }

        return scanItem;
      });
      
      // Afficher les donn√©es qui seront transmises
      console.log('Transmission des scans:', JSON.stringify(scansToSubmit, null, 2)); // D√©comment√© pour d√©bogage
      
      // Envoyer les scans √† Firebase
      const result = await firebaseService.addScans(scansToSubmit);
      console.log('R√©sultat de la transmission:', result);
      
      // Si la transmission r√©ussit, mettre √† jour l'historique local
      if (result.success) {
        // --- Logique de consolidation --- 
        const updatedScansMap = new Map();
        historicalScans.forEach(scan => {
          // Assurer qu'on a un code pour la cl√© de la map
          if (scan.code) {
            updatedScansMap.set(scan.code, scan);
          }
        });
        scansToSubmit.forEach(scan => {
          if (scan.code) {
            const originalScan = scannedContenants.find(s => s.code === scan.code);
            const scanForHistory = {
              ...scan,
              timeStamp: originalScan?.timeStamp || dateUtils.formatTime(scan.scanDate),
            };
            updatedScansMap.set(scan.code, scanForHistory);
          }
        });
        const newHistory = Array.from(updatedScansMap.values());
        newHistory.sort((a, b) => {
          const dateA = a.scanDate ? new Date(a.scanDate).getTime() : 0;
          const dateB = b.scanDate ? new Date(b.scanDate).getTime() : 0;
          if (isNaN(dateA) && isNaN(dateB)) return 0;
          if (isNaN(dateA)) return 1;
          if (isNaN(dateB)) return -1;
          return dateB - dateA;
        });
        // --- Fin de la logique de consolidation ---

        // Sauvegarder l'historique consolid√© dans AsyncStorage
        await AsyncStorage.setItem('scanHistory', JSON.stringify(newHistory));
        
        // Mise √† jour de l'√©tat React DIFF√âR√âE apr√®s les interactions
        InteractionManager.runAfterInteractions(() => {
          setHistoricalScans(newHistory);
        });
        
        // Mettre √† jour la liste des paquets pris en charge
        if (operationType === 'entree') {
          setTakingCarePackages([...scansToSubmit, ...takingCarePackages]);
        } else if (operationType === 'sortie') {
          const codesDeposited = scansToSubmit.map(scan => scan.code);
          setTakingCarePackages(takingCarePackages.filter(pkg => pkg.code && !codesDeposited.includes(pkg.code)));
        }
        
        // R√©initialiser compl√®tement l'√©tat pour revenir √† l'√©cran de scan de site
        resetScan(); // Cette fonction r√©initialise les √©tats de base

        // S'assurer que tous les √©tats sont correctement r√©initialis√©s pour revenir √† l'√©cran initial
        setShowOperationTypeSelection(false);
        setOperationType('entree'); // R√©initialiser √† l'entr√©e de colis par d√©faut
        
        // Important: D√©sactiver le chargement AVANT l'alerte
        setLoading(false);
        
        // Afficher l'alerte de succ√®s
        Alert.alert(
          'Succ√®s',
          `${scansToSubmit.length} scan(s) transmis avec succ√®s`,
          [{ text: 'OK' }]
        );
      } else {
        setLoading(false);
        throw new Error(result.error || '√âchec de la transmission');
      }
    } catch (error) {
      console.error('Erreur lors de la transmission:', error);
      setLoading(false);
      Alert.alert('Erreur', `√âchec de la transmission: ${error.message}`);
    }
  };

  const resetScan = () => {
    setScanMode('');
    setSiteScanned(false);
    setSiteCode('');
    setScannedContenants([]);
    setManualCodeInput('');
    setSiteDetails(null);
  };

  const navigateToHistory = () => {
    setShowHistoryModal(true);
  };

  // Fonction pour obtenir les d√©tails de la session actuelle
  const getSessionDetails = async () => {
    try {
      const currentSession = await firebaseService.getCurrentSession();
      if (currentSession) {
        setSessionId(currentSession.id);
        setTournee(currentSession.tournee);
        setVehicule(currentSession.vehicule);
        setPole(currentSession.pole);
      }
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration de la session:", error);
    }
  };

  // Fonction pour effacer l'historique des scans
  const clearHistoricalScans = async () => {
    try {
      Alert.alert(
        'Effacer l\'historique',
        'Voulez-vous vraiment effacer tout l\'historique des scans?',
        [
          {
            text: 'Annuler',
            style: 'cancel'
          },
          {
            text: 'Effacer',
            onPress: async () => {
              await AsyncStorage.removeItem('scanHistory');
              setHistoricalScans([]);
              Alert.alert('Succ√®s', 'Historique effac√© avec succ√®s');
            },
            style: 'destructive'
          }
        ]
      );
    } catch (error) {
      console.error('Erreur lors de l\'effacement de l\'historique:', error);
      Alert.alert('Erreur', 'Impossible d\'effacer l\'historique');
    }
  };

  // Ajout d'une fonction pour effacer explicitement tous les scans de la session actuelle
  const clearCurrentSessionScans = async () => {
    try {
      const currentSessionId = await AsyncStorage.getItem('currentSessionId');
      if (!currentSessionId) {
        Alert.alert('Erreur', 'Impossible de d√©terminer la session actuelle');
        return;
      }
      
      Alert.alert(
        'R√©initialiser l\'historique',
        'Cette action va supprimer tous les scans associ√©s √† votre session actuelle. Continuer?',
        [
          {
            text: 'Annuler',
            style: 'cancel'
          },
          {
            text: 'Supprimer',
            onPress: async () => {
              try {
                // Supprimer les scans associ√©s √† la session actuelle
                setLoading(true);
                console.log(`Suppression des scans de la session ${currentSessionId}...`);
                
                // Fonction c√¥t√© service qui devrait √™tre impl√©ment√©e
                // pour supprimer tous les scans de la session
                const result = await firebaseService.clearSessionScans(currentSessionId);
                
                // Supprimer l'historique local √©galement
                await AsyncStorage.removeItem('scanHistory');
                setHistoricalScans([]);
                
                setLoading(false);
                Alert.alert('Succ√®s', 'Historique r√©initialis√© avec succ√®s');
              } catch (error) {
                setLoading(false);
                console.error('Erreur lors de la suppression des scans:', error);
                Alert.alert('Erreur', `√âchec de la suppression: ${error.message}`);
              }
            },
            style: 'destructive'
          }
        ]
      );
    } catch (error) {
      console.error('Erreur:', error);
      Alert.alert('Erreur', 'Une erreur est survenue');
    }
  };

  // Handler de d√©connexion avec effacement complet de l'historique
  const handleLogout = async () => {
    try {
      Alert.alert(
        'D√©connexion',
        'Voulez-vous vous d√©connecter? L\'historique des scans sera effac√©.',
        [
          {
            text: 'Annuler',
            style: 'cancel'
          },
          {
            text: 'D√©connecter',
            onPress: async () => {
              try {
                setLoading(true);
                console.log('D√©connexion en cours...');

                // Appeler la m√©thode de d√©connexion de Firebase
                await firebaseService.logout();
                console.log('D√©connexion Firebase r√©ussie');
                
                // Effacer toutes les donn√©es de session
                await AsyncStorage.removeItem('userSessionActive');
                // On conserve current_session_id pour que la tourn√©e visit√©e reste en m√©moire
                await AsyncStorage.removeItem('scanHistory');
                await AsyncStorage.removeItem('user_selas_id');
                
                // R√©initialiser les √©tats
                setHistoricalScans([]);
                setScannedContenants([]);
                setSiteScanned(false);
                setSiteCode('');
                
                setLoading(false);
                
                // Rediriger vers l'√©cran de connexion
                navigation.reset({
                  index: 0,
                  routes: [{ name: 'Login' }]
                });
              } catch (error) {
                setLoading(false);
                console.error('Erreur lors du processus de d√©connexion:', error);
                Alert.alert('Erreur', 'Impossible de se d√©connecter. Veuillez r√©essayer.');
              }
            }
          }
        ]
      );
    } catch (error) {
      console.error('Erreur lors de la d√©connexion:', error);
    }
  };

  // Utiliser directement les fonctions de formatage de dateUtils
  // au lieu de red√©finir des fonctions similaires

  // Effet pour √©couter les √©v√©nements de scan Zebra
  useEffect(() => {
    if (isReadyForScan) {
      // Afficher un message pour indiquer que l'application est pr√™te pour le scan
      console.log('Pr√™t √† recevoir des scans du scanner Zebra');
      
      // Configuration pour recevoir les scans du mat√©riel Zebra
      const handleZebraScan = (event) => {
        // Le scanner Zebra envoie g√©n√©ralement les donn√©es comme des entr√©es clavier
        // Nous devons v√©rifier que nous sommes en mode scan et traiter les donn√©es
        if (event && event.nativeEvent && event.nativeEvent.key === 'Enter' && scanMode) {
          // R√©cup√©rer le texte scann√© (par exemple depuis un champ de texte cach√© ou via une API Zebra)
          // Pour les besoins de cet exemple, nous utiliserons la valeur de manualCodeInput
          if (manualCodeInput.trim()) {
            processScannedData(manualCodeInput.trim());
            setManualCodeInput(''); // R√©initialiser apr√®s le traitement
          }
        }
      };
      
      // Ajoutez ici l'initialisation sp√©cifique au scanner Zebra si n√©cessaire
      // Exemple : ZebraScanner.initialize() si une API Zebra est disponible
      
      // Pour cet exemple, on simule en utilisant l'√©couteur de clavier (pour Enter)
      Keyboard.addListener('keyDown', handleZebraScan);
      
      return () => {
        // Nettoyage lors du d√©montage
        Keyboard.removeListener('keyDown', handleZebraScan);
        // D√©sinitialiser le scanner Zebra si n√©cessaire
        // Exemple : ZebraScanner.deinitialize()
      };
    }
  }, [isReadyForScan, scanMode, manualCodeInput]);


  const loadHistoricalScans = async () => {
    try {
      const jsonValue = await AsyncStorage.getItem('scanHistory');
      if (jsonValue !== null) {
        const history = JSON.parse(jsonValue);
        
        // R√©cup√©rer l'ID de la tourn√©e actuelle
        const currentSession = await firebaseService.getCurrentSession();
        const currentTourneeId = currentSession?.tournee?.id || sessionData?.tournee?.id || '';
        
        // Filtrer l'historique local
        const today = new Date();
        today.setHours(0, 0, 0, 0); // D√©but de la journ√©e
        
        const filteredHistory = history.filter(item => {
          // Convertir la date de l'item en objet Date
          let itemDate;
          try {
            itemDate = new Date(item.date);
            if (isNaN(itemDate.getTime())) {
              // Si la date n'est pas valide, essayer un autre format
              const parts = item.date.split('/');
              if (parts.length === 3) {
                itemDate = new Date(parts[2], parts[1] - 1, parts[0]);
              }
            }
          } catch (e) {
            // En cas d'erreur, consid√©rer cet item comme non valide pour le filtre
            return false;
          }

          // S'assurer que nous avons une date valide
          if (!itemDate || isNaN(itemDate.getTime())) return false;
          
          itemDate.setHours(0, 0, 0, 0); // Normaliser √† minuit
          
          // V√©rifier la tourn√©e
          const isSameTournee = !currentTourneeId || item.tourneeId === currentTourneeId;
          
          // V√©rifier le statut (inclut les visites sans colis)
          const hasValidStatus = item.status === 'en-cours' || item.status === 'livr√©';
          
          // L'item doit √™tre du jour courant ET de la m√™me tourn√©e ET avoir un statut valide
          return itemDate.getTime() === today.getTime() && isSameTournee && hasValidStatus;
        });
        
        console.log(`Historique local filtr√©: ${filteredHistory.length} scans (jour + tourn√©e + statut)`);
        
        // Consolider l'historique filtr√© avant de mettre √† jour l'√©tat
        const consolidatedHistory = consolidateAndSortScans([], filteredHistory);

        // Enrichir avec le nom complet du site depuis Firestore
        const enrichedHistory = await Promise.all(
          consolidatedHistory.map(async (scan) => {
            // Tenter de r√©cup√©rer les d√©tails du site en utilisant siteId ou code
            try {
              const siteIdentifier = scan.siteId || scan.code; // Utiliser ID ou code
              // V√©rifier si l'identifiant est probablement un site avant d'appeler getSiteById
              if (siteIdentifier && 
                  !siteIdentifier.startsWith('TEST_CONTENANT_') && 
                  !siteIdentifier.match(/^[0-9]{13,}$/)) { 
                const siteInfo = await firebaseService.getSiteById(siteIdentifier);
                if (siteInfo) {
                  // Enrichir le scan avec les d√©tails complets
                  return { 
                    ...scan, 
                    siteName: siteInfo.nom || siteInfo.name, // Ajouter le nom pour affichage facile
                    siteDetails: { ...siteInfo } 
                  };
                }
              }
            } catch (e) {
              console.warn(`[loadHistoricalScans] Erreur r√©cup√©ration d√©tails site pour ${scan.code || scan.id}:`, e);
            }
            // Si non trouv√© ou erreur, retourner le scan original
            return scan;
          })
        );
        
        // Mettre √† jour l'√©tat avec l'historique enrichi
        setHistoricalScans(enrichedHistory);
        setSessionHistoryLoaded(true);
      }
    } catch (error) {
      console.error('Erreur lors du chargement de l\'historique:', error);
    }
  };

  const loadFirestoreScans = async () => {
    try {
      // On ne charge les scans Firestore que si la session est active
      const userSessionActive = await AsyncStorage.getItem('userSessionActive');
      if (userSessionActive !== 'true') {
        // Si aucune session active, on ne charge pas l'historique Firestore
        return;
      }

      // R√©cup√©rer l'ID de session actuel
      const currentSessionId = await AsyncStorage.getItem('currentSessionId');
      console.log('Chargement des scans pour la session:', currentSessionId);

      // R√©cup√©rer l'ID de la tourn√©e actuelle
      const currentSession = await firebaseService.getCurrentSession();
      const currentTourneeId = currentSession?.tournee?.id || sessionData?.tournee?.id || '';
      console.log('Tourn√©e actuelle:', currentTourneeId);

      setLoading(true); // Afficher l'indicateur de chargement

      // R√©cup√©rer tous les scans de l'utilisateur (sans limite)
      const scans = await firebaseService.getScans();
      
      if (scans && scans.length > 0) {
        // Ne garder que les scans du jour (J0)
        const today = new Date();
        today.setHours(0, 0, 0, 0); // D√©but de la journ√©e
        
        const filteredScans = scans.filter(scan => {
          // Convertir la date du scan en objet
